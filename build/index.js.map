{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///./node_modules/jsts/org/locationtech/jts/math/MathUtil.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/buffer/BufferParameters.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/RobustLineIntersector.js","webpack:///./node_modules/jsts/java/lang/Double.js","webpack:///webpack/bootstrap 8dcccae87944a17eb73e","webpack:///./node_modules/jsts/extend.js","webpack:///./node_modules/jsts/java/util/ArrayList.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Coordinate.js","webpack:///./node_modules/jsts/inherits.js","webpack:///./node_modules/jsts/org/locationtech/jts/util/Assert.js","webpack:///./node_modules/jsts/hasInterface.js","webpack:///./node_modules/jsts/java/lang/IllegalArgumentException.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Location.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/Position.js","webpack:///./node_modules/jsts/java/lang/Comparable.js","webpack:///./node_modules/jsts/java/io/Serializable.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/Orientation.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Envelope.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Geometry.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/GeometryCollection.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/LineString.js","webpack:///./node_modules/jsts/java/lang/System.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/Label.js","webpack:///./src/control/control.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/CoordinateSequence.js","webpack:///./node_modules/jsts/java/util/Collection.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/GeometryFactory.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/TopologyException.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/CoordinateArrays.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/MultiLineString.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Dimension.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Polygon.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/LinearRing.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/overlay/OverlayOp.js","webpack:///./node_modules/jsts/java/lang/RuntimeException.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/GeometryComponentFilter.js","webpack:///./node_modules/jsts/java/util/Iterator.js","webpack:///./node_modules/jsts/java/util/TreeMap.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Point.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/MultiPolygon.js","webpack:///./node_modules/jsts/org/locationtech/jts/io/WKTWriter.js","webpack:///./node_modules/jsts/java/util/Collections.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/LineSegment.js","webpack:///./node_modules/jsts/java/lang/Cloneable.js","webpack:///./node_modules/jsts/java/util/Comparator.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/CoordinateFilter.js","webpack:///./node_modules/jsts/java/util/List.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/CoordinateSequenceFilter.js","webpack:///./node_modules/jsts/java/lang/StringBuilder.js","webpack:///./node_modules/jsts/java/lang/Integer.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Polygonal.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/MultiPoint.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/Quadrant.js","webpack:///./node_modules/jsts/org/locationtech/jts/noding/NodedSegmentString.js","webpack:///./node_modules/jsts/org/locationtech/jts/io/OL3Parser.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/BoundaryNodeRule.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/CoordinateList.js","webpack:///./node_modules/jsts/java/util/NoSuchElementException.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/GeometryFilter.js","webpack:///./node_modules/jsts/java/lang/StringBuffer.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/PointLocation.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/NotRepresentableException.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/HCoordinate.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/Distance.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/PlanarGraph.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/Node.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/ItemVisitor.js","webpack:///./node_modules/jsts/java/util/OperationNotSupported.js","webpack:///./node_modules/jsts/java/util/HashSet.js","webpack:///./node_modules/jsts/java/util/Arrays.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/CoordinateSequences.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/impl/CoordinateArraySequence.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/PrecisionModel.js","webpack:///./node_modules/jsts/org/locationtech/jts/noding/MCIndexNoder.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/strtree/AbstractNode.js","webpack:///./node_modules/jsts/org/locationtech/jts/noding/Noder.js","webpack:///./node_modules/jsts/org/locationtech/jts/noding/SegmentIntersector.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/Edge.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/intervalrtree/IntervalRTreeNode.js","webpack:///./src/control/topology.js","webpack:///./node_modules/jsts/java/lang/Long.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/CoordinateSequenceFactory.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/BoundaryOp.js","webpack:///./node_modules/jsts/java/util/Map.js","webpack:///./node_modules/jsts/java/util/Set.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Lineal.js","webpack:///./node_modules/jsts/java/util/TreeSet.js","webpack:///./node_modules/jsts/java/lang/Character.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Puntal.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/CGAlgorithmsDD.js","webpack:///./node_modules/jsts/java/util/HashMap.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/overlay/PolygonBuilder.js","webpack:///./node_modules/jsts/java/lang/Exception.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/RayCrossingCounter.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeRing.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/GraphComponent.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/DirectedEdge.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/NodeFactory.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/strtree/ItemBoundable.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/strtree/Boundable.js","webpack:///./node_modules/jsts/org/locationtech/jts/noding/Octant.js","webpack:///./node_modules/jsts/org/locationtech/jts/noding/SegmentString.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/chain/MonotoneChain.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/Angle.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/overlay/OverlayNodeFactory.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/locate/PointOnGeometryLocator.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/GeometryCollectionIterator.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeList.js","webpack:///./img/buffer.svg","webpack:///./node_modules/jsts/org/locationtech/jts/operation/overlay/snap/SnapIfNeededOverlayOp.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/PointLocator.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/index/SegmentIntersector.js","webpack:///./src/index.js","webpack:///./src/editor.js","webpack:///./src/toolbar.js","webpack:///./style/ole.css?3c37","webpack:///./style/ole.css","webpack:///./node_modules/css-loader/lib/css-base.js","webpack:///./node_modules/style-loader/lib/addStyles.js","webpack:///./node_modules/style-loader/lib/urls.js","webpack:///./src/control/index.js","webpack:///./src/control/cad.js","webpack:///./img/cad.svg","webpack:///./src/control/rotate.js","webpack:///./img/rotate.svg","webpack:///./img/rotate_map.svg","webpack:///./src/control/draw.js","webpack:///./img/draw_point.svg","webpack:///./img/draw_polygon.svg","webpack:///./img/draw_line.svg","webpack:///./src/control/move.js","webpack:///./img/move.svg","webpack:///./src/control/modify.js","webpack:///./img/modify_geometry.svg","webpack:///./src/control/delete.js","webpack:///./img/delete.svg","webpack:///./src/control/buffer.js","webpack:///./node_modules/jsts/org/locationtech/jts/util/NumberUtil.js","webpack:///./node_modules/jsts/org/locationtech/jts/util/AssertionFailedException.js","webpack:///./node_modules/jsts/java/util/IndexOutOfBoundsException.js","webpack:///./node_modules/jsts/java/util/SortedMap.js","webpack:///./node_modules/jsts/java/util/SortedSet.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/Length.js","webpack:///./node_modules/jsts/org/locationtech/jts/util/StringUtil.js","webpack:///./node_modules/jsts/java/io/PrintStream.js","webpack:///./node_modules/jsts/java/io/StringReader.js","webpack:///./node_modules/jsts/java/text/DecimalFormat.js","webpack:///./node_modules/jsts/java/io/ByteArrayOutputStream.js","webpack:///./node_modules/jsts/java/io/IOException.js","webpack:///./node_modules/jsts/java/io/LineNumberReader.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/Area.js","webpack:///./node_modules/jsts/org/locationtech/jts/math/DD.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/util/GeometryEditor.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/impl/CoordinateArraySequenceFactory.js","webpack:///./node_modules/jsts/Map.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/buffer.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/buffer/BufferOp.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/buffer/BufferBuilder.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/buffer/BufferSubgraph.js","webpack:///./node_modules/jsts/java/util/Stack.js","webpack:///./node_modules/jsts/java/util/EmptyStackException.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/buffer/RightmostEdgeFinder.js","webpack:///./node_modules/jsts/java/util/LinkedList.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/LineIntersector.js","webpack:///./node_modules/jsts/org/locationtech/jts/io/WKTParser.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/overlay/MaximalEdgeRing.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/overlay/MinimalEdgeRing.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/TopologyLocation.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/NodeMap.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeEnd.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/strtree/STRtree.js","webpack:///./node_modules/jsts/org/locationtech/jts/util/PriorityQueue.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/strtree/BoundablePairDistanceComparator.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/SpatialIndex.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/strtree/BoundablePair.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/strtree/AbstractSTRtree.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/strtree/ItemDistance.js","webpack:///./node_modules/jsts/org/locationtech/jts/noding/SegmentNodeList.js","webpack:///./node_modules/jsts/org/locationtech/jts/noding/SegmentNode.js","webpack:///./node_modules/jsts/org/locationtech/jts/noding/SegmentPointComparator.js","webpack:///./node_modules/jsts/org/locationtech/jts/noding/NodableSegmentString.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/chain/MonotoneChainOverlapAction.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/chain/MonotoneChainBuilder.js","webpack:///./node_modules/jsts/org/locationtech/jts/noding/SinglePassNoder.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/buffer/OffsetCurveBuilder.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/buffer/BufferInputLineSimplifier.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/buffer/OffsetSegmentGenerator.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/buffer/OffsetSegmentString.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/buffer/SubgraphDepthLocater.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/buffer/OffsetCurveSetBuilder.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Triangle.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/DirectedEdgeStar.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeEndStar.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/locate/SimplePointInAreaLocator.js","webpack:///./node_modules/jsts/org/locationtech/jts/noding/OrientedCoordinateArray.js","webpack:///./node_modules/jsts/org/locationtech/jts/noding/IntersectionAdder.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeIntersectionList.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeIntersection.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/IntersectionMatrix.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/index/MonotoneChainEdge.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/index/MonotoneChainIndexer.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/Depth.js","webpack:///./node_modules/jsts/org/locationtech/jts/noding/ScaledNoder.js","webpack:///./node_modules/jsts/org/locationtech/jts/noding/snapround/MCIndexSnapRounder.js","webpack:///./node_modules/jsts/org/locationtech/jts/noding/NodingValidator.js","webpack:///./node_modules/jsts/org/locationtech/jts/noding/snapround/HotPixel.js","webpack:///./node_modules/jsts/org/locationtech/jts/noding/snapround/MCIndexPointSnapper.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/chain/MonotoneChainSelectAction.js","webpack:///./node_modules/jsts/org/locationtech/jts/noding/InteriorIntersectionFinderAdder.js","webpack:///./src/control/union.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/union/UnionOp.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/overlay/snap/SnapOverlayOp.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/overlay/snap/GeometrySnapper.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/util/GeometryTransformer.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/overlay/snap/LineStringSnapper.js","webpack:///./node_modules/jsts/org/locationtech/jts/precision/CommonBitsRemover.js","webpack:///./node_modules/jsts/org/locationtech/jts/precision/CommonBits.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeNodingValidator.js","webpack:///./node_modules/jsts/org/locationtech/jts/noding/BasicSegmentString.js","webpack:///./node_modules/jsts/org/locationtech/jts/noding/FastNodingValidator.js","webpack:///./node_modules/jsts/org/locationtech/jts/noding/InteriorIntersectionFinder.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/util/GeometryCollectionMapper.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/overlay/LineBuilder.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/overlay/PointBuilder.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/GeometryGraphOperation.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/GeometryGraph.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/index/SimpleMCSweepLineIntersector.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/index/MonotoneChain.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/index/SweepLineEvent.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/index/EdgeSetIntersector.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/locate/IndexedPointInAreaLocator.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/intervalrtree/SortedPackedIntervalRTree.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/intervalrtree/IntervalRTreeLeafNode.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/intervalrtree/IntervalRTreeBranchNode.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/util/LinearComponentExtracter.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/ArrayListVisitor.js","webpack:///./src/helper/util.js","webpack:///./img/union.svg","webpack:///./src/control/intersection.js","webpack:///./img/intersection.svg","webpack:///./src/control/difference.js","webpack:///./img/difference.svg"],"names":[],"mappings":"AAAA,cACA,2BACA,uCACA,sCACA,WACA,YACA,qCAEA,UACA,GAAC,gGCID,sBCmEA,uBCNA,oDC7BA,WADA,8CJlCA,kBKTA,cAMA,IACA,iBAGA,mBACA,CACA,IACA,KAIA,2CAGA,aAGA,OACA,OAIA,IAzBA,eA4BA,MAGA,uBACA,GACA,kCACA,CACA,gBACA,cAGA,OAGA,iBACA,YACA,qBAA2B,UAA0B,UACrD,YAAiC,CAAe,QAChD,EAEA,aADA,QAIA,mBAAsD,wCAA+D,SAGrH,MAGA,8BC7DA,8BACA,QACA,mCAEA,qCCSA,YAKA,MAEA,gCACA,4BAEA,2DAXA,IAYA,yCACA,0BAEA,wCACA,kCAA+C,gBAI/C,EACA,2BACA,CAMA,MALA,kCAEA,oDAEA,QAGA,4BACA,MACA,SAIA,EACA,8BACA,aAA4B,aAC5B,sBAEA,QACA,QAKA,EACA,6BACA,YACA,UAEA,YADA,aAMA,EACA,+BACA,cACA,KAKA,EACA,2BACA,iBACA,gBAGA,iBACA,SAKA,EACA,8BACA,OACA,uBAKA,EACA,2BACA,oBACA,MAKA,EACA,8BACA,QAEA,wBAA2C,OAAS,IACpD,gBAGA,WACA,QAKA,EACA,8BACA,QAEA,wBAA2C,OAAS,IACpD,0BACA,sBACA,GACA,KACA,KAGA,CACA,QASA,EACA,iBAKA,MAKA,4BACA,CAKA,EACA,2BACA,qCACA,gBAEA,qCACA,YAKA,EACA,8BACA,yCAKA,OAKA,EACA,2BACA,2CACA,IAKA,EACA,6BACA,iDACA,2CCvLA,YACA,WACA,YACA,YACA,KACA,4BACE,uCACF,iBACA,yBACA,EAAE,8BACF,gCACA,qBACA,cAAE,8BACF,+CACA,QACA,SACA,SACA,GACA,EA0HA,YACA,2BACA,EACA,iCACE,gCACF,iBACA,iCACA,gDACA,mBACA,8EAtJA,GAoBA,wBACA,0BACA,CACA,iBACA,OACA,IACA,aACA,OACA,IACA,aACA,OACA,IACA,MACA,sBAEA,+BACA,qBACA,yBACA,iBACA,sBAGA,iBAIA,EAAG,yBACH,gCACA,4CAGA,yCAIA,IACA,CACA,yBACA,CACA,iBACA,cACA,SACA,cACA,SACA,cAEA,iBACA,6BACA,sBACA,kFACA,GACA,oBACA,UAGA,sBACA,WACA,wBACA,yCACA,IACA,uBACA,IACA,wBACA,aACA,cACA,aACA,EACA,CACA,kBACA,IACA,CAEA,MADA,KACG,SACH,gBACA,4DACA,0DACI,KACJ,OAAG,SACH,CACA,iBACA,cACA,KACA,qBACA,0CACA,GACA,wBACA,gBACA,aACA,aACA,mBACA,IACA,sBACA,gBACA,aACA,eACA,IACA,qBACA,OACA,GAGA,8BAFA,0BACA,IAEA,2BACA,UACA,WACA,WACA,CACA,wBACA,gBACA,IACA,qBACA,CACA,QACC,IACD,qBACA,wDACA,iBACA,aACA,mCACA,GACA,GAWA,wBACA,sBACA,IACA,KACA,sBACA,YACA,+BACA,YACA,4CACA,yBACA,GACA,QACA,wBACA,QACA,IACA,qBACA,CACA,QACC,IACD,uBACA,aACA,MACA,MACA,sBACA,GAEA,eACA,EACA,GACA,0BACA,uCACA,wBACA,MACA,MACA,qBCjMA,8BACA,6BACA,uBACA,6CCDA,mCADA,KAEA,wBACA,uBACA,CACA,QACA,qBACA,CACA,QACC,IACD,iCACA,IACA,4CACE,mCACF,iBACA,qDACA,WACA,GACA,mBACA,yBACA,iBACA,cACA,KAAE,8BACF,gCACA,MACA,MACA,kBAEA,mBAGA,OACA,GACA,mBACA,yBACA,gCACA,gBACA,KAAE,8BACF,+CACA,SACA,sEAEA,WACA,kBC5CA,8BACA,wBACA,8DCFA,2CCEA,mCADA,GAEA,wBACA,uBACA,CACA,QACA,qBACA,CACA,QACC,IACD,8BACA,CACA,iBACA,eACA,WACA,eACA,WACA,eACA,WACA,WAEA,mBACA,+BACA,aACA,aACA,aACA,wCC1BA,4BADA,GAEA,wBACA,uBACA,CACA,QACA,qBACA,CACA,QACC,IACD,sBACA,qBACA,oBAEA,QACA,OACA,SACA,0CCjBA,6CCAA,2CCGA,0CADA,IAEA,wBACA,uBACA,CACA,QACA,qBACA,CACA,QACC,IACD,uBACA,YACA,yBACA,mBACA,gBACA,uBACA,iFACA,KACA,IAAgB,IAAW,KAC3B,MACA,WACA,IACA,IAGA,QACA,KAEA,YACE,6BACF,UACA,KACA,QACE,6BACF,aACA,OACA,oDACA,iBACA,eACA,KAMA,SALA,YAEA,EAEA,OAEA,eACA,oBACA,qBACA,0BACA,cACA,qDbnDA,4BAFA,IAIA,kBACA,sCACA,mBAEA,UACA,iCAGA,wCACA,OACA,8BAEA,sBACA,sCACA,GACA,WACA,SAGA,cACA,SACA,MAVA,UAWA,OACA,IAEA,iBACA,SACA,gCACA,eACA,WACA,OACA,EACA,CAIA,cACA,OACA,YACA,yBAGA,WAAmB,KAAO,IAC1B,gBACA,UACA,MAGA,eACA,EACA,kCACA,aACA,QAGA,uBACA,mBACA,gBAEA,MAIA,EAEA,YACA,KACA,OAGA,iBAEA,eACA,OACA,gBAGA,aAEA,YACA,OACA,cAKA,eACA,EAGA,MAKA,KAGA,OAEA,SAMA,MAIA,OACA,MAQA,sBAEA,OACA,YACA,OAWA,sBACA,IAEA,QACA,IACA,KAOA,OACA,SACA,YAEA,QACA,EAEA,WAOA,aAKA,MAGA,QAKA,UAIA,YAEA,IACA,MACA,IAGA,UAEA,KAOA,IAKA,WAXA,KACA,EAIA,OAQA,MAQA,SACA,IAGA,WAXA,EACO,MAeP,OACA,OACM,iBAIN,CACA,KACA,KACA,UAIA,CACA,WACO,KACP,aAEA,MACA,KACA,CAIA,cACA,GAEA,QACA,SACA,gCACA,SAEA,SAGA,UAJA,qBAOA,qBAIA,QACA,EACA,mBAAkB,EAAS,MAC3B,IACA,aAEA,UAGA,EACA,wBAAmB,GAAS,MAC5B,IACA,aAEA,UAKA,YACA,IAEA,YAEA,QACA,IAEA,eACA,QAEA,SAEA,EAKA,OAGA,eACA,IACA,CACA,kCc9SA,YACA,eACA,gBACA,gBACA,gBACA,KACA,0BACE,eACF,oDACA,iBACA,2BACA,EAAG,kCACH,iBACA,QACA,OACE,+BACF,gCACA,2BACA,EAAE,8BACF,8DACA,QACA,aACA,qCAvBA,IAwBA,wBACA,mBACA,6BACA,WACA,oBACA,MACA,gBAEA,YACA,iBACA,WAEA,sGACA,SACA,0BACA,yDACA,6CACA,wCACA,wCACA,wCACA,YACA,eACA,mBACA,wBACA,KACA,oBACA,aACA,KACA,mBACA,yBACA,+BACA,iBACA,4BACA,EAAI,6BACJ,iBACA,2BAGA,yGACA,KACA,CAAG,8BACH,gCACA,eACA,+DACA,KACA,CACA,uBACA,yBACA,6BACA,iBACA,2BAGA,uFACA,MAAI,+BACJ,iBACA,gCACA,EACA,CAAG,8BACH,2DACA,gCACA,WACA,SAEA,6BACA,kBACA,6BACA,kBACA,6BACA,kBACA,6BACA,iBAEA,MAAI,iEACJ,gCACA,eACA,6DACA,MACA,CACA,CACA,oBACA,aACA,KACA,oBACA,aACA,KACA,4BACA,IACA,oDACA,iBACA,8BACA,EAAI,kCACJ,iBACA,QACA,eAEA,WACA,uBACA,uBACA,uBACA,uBAEA,yBACA,qBAEA,oBACA,qBAEA,oBACA,qBAEA,oBACA,qBAGA,OACG,+BACH,gCACA,QACA,eACA,aACA,aACA,aAEA,iBACA,aAEA,gBACA,aAEA,gBACA,aAEA,gBACA,aAGA,SACA,CACA,sBACA,kBACA,oBACA,kBACA,kBAEA,QACA,qBACA,aACA,SAEA,kBACA,KACA,uBACA,IACA,aACA,2BACA,GAEA,oBAEA,sBACA,qBACA,sBACA,qBACA,sBACA,qBACA,sBACA,qBACA,EACA,CACA,yBACA,aACA,SAEA,4EACA,YACA,qBACA,2EACA,GACA,sBACA,YACA,cACA,aACA,cACA,CACA,sBACA,aACA,SAEA,kBACA,KACA,sBACA,kBACA,oBACA,kBACA,kBAEA,QACA,qBACA,yBACA,iBACA,QACA,aAAG,8BACH,gCACA,0BACA,WACA,cACA,cACA,cACA,8DACA,WACA,CACA,qBACA,yBACA,6BACA,iBACA,eACA,SAAI,+BACJ,iBACA,eACA,SACA,CAAG,8BACH,gCACA,eACA,WACA,CACA,mBACA,sBACA,oEACA,aACA,iBACA,IACA,0BACG,oBACH,oDACA,iBACA,2BACA,EAAI,kCACJ,iBACA,gBACA,mBACA,mBACA,mBACA,KACG,+BACH,gCACA,2BACA,EAAG,8BACH,8DACA,GACA,UACA,aAEA,eACA,aAEA,SACA,UACA,aAEA,eACA,aAEA,QACA,CACA,oBACA,aACA,KACA,sBACA,6BACA,MACA,uCAA0D,0CAC1D,UACA,8CAA0D,0CAC1D,OACA,OACA,aACA,IACA,qBACA,OACA,GAKA,gCAJA,gCACA,gCACA,gCACA,QAEA,wBACA,YACA,IACA,qBACA,CACA,QACC,IACD,uBACA,yBACA,+CACA,sGAIA,EAAE,yBACF,8DACA,iBACA,aACA,aACA,aACA,WACA,QACA,iBACA,aACA,aACA,aACA,KACA,QAEA,KACA,GACA,qEChVA,YACA,gBACA,mBACA,gBACA,oBACA,qBACA,QACA,wBACA,6EATA,GAUA,wBACA,gCACA,+BACA,2BACA,uBACA,aACA,QACA,yBACA,OACA,KACA,oBACA,CACA,QACA,wBACA,CACA,QACA,mBACA,6BACA,iBACA,SACA,gBACA,aAAG,kCACH,iBACA,wBACA,YACA,iBACA,cACA,CACA,yBACA,qCACA,EACA,4BACA,cACA,sBACA,kCACA,gBACA,IACA,wBACA,OACA,qCACA,OACA,sBACA,CACA,QACA,6BACA,OACA,EACA,sBACA,yBACA,iBACA,MACA,mCACA,gCAGA,UAEA,OACA,WAEA,IACA,UAEA,OACA,2CAVA,aAUG,yBACH,gCACA,MACA,mCACA,gCAGA,UAEA,OACA,WAEA,IACA,UAEA,OACA,6CAVA,aAWA,CACA,wBACA,aACA,SACA,oBACA,aACA,KACA,wBACA,0CACA,sBACA,wCACA,wBACA,0CAEA,4DACA,uBACA,OACA,SAEA,YACA,cACA,iBACA,YACA,OAEA,SADA,aAEA,8BACA,sBACA,mBACA,gCACA,OACA,6CAEA,wCACA,UACA,qBACA,MACA,OACA,yBACA,MACA,WACA,uBACA,aACA,eACA,qCACA,SACA,WACA,WACA,gBACA,MAEA,QACA,UACA,UAEA,IACA,WAEA,EACA,CACA,qBACA,mCACA,UACA,0CACA,gLAIA,qBACA,wBACA,gBACA,IACA,qBACA,CACA,QACC,IACD,iCACA,WAAgB,MAAuB,OACvC,aACA,UAGA,SACA,UACA,6BACA,WAAgB,MAAkB,OAClC,OACA,YAGA,SACA,UACA,uCACA,mBACA,wBACA,wBACA,wBACA,6BACA,qBACA,0BACA,gCACA,yBACA,mCACA,mCACA,mCACA,6CACA,6BACA,uCACA,mDACA,wBACA,uBACA,QACA,IACA,oBACA,GACA,uBACA,iCCxMA,YACA,kBACA,oCACA,eACA,QACA,WAEA,UACA,iCAEA,kDACA,gIAZA,GAaA,mBACA,wBACA,mCACA,cACA,OAAiB,qBAA6B,OAC9C,0CAEA,uBACA,QACA,0BACA,aACA,cACA,2BACA,2CACA,SACA,IAAiB,uBAA6B,WAC9C,uBACA,2BAAkB,MAA6B,OAC/C,IACA,SAEA,IACA,CACA,QACA,oBACA,QACA,OAAiB,qBAA6B,OAC9C,2BAEA,UACA,QACA,wBACA,oFACA,gCACA,YACA,qBAEA,YACA,gDACA,OAEA,mBAAkB,qBAA6B,OAC/C,0CACA,kBAGA,SACA,QAAG,6CACH,UACA,sBACA,WAAiB,qBAA6B,OAC9C,wBAEA,0BACA,YACA,0BACA,uBACA,yBACA,eACA,iCACA,eACA,QAAiB,qBAA6B,OAC9C,8BAEA,wBACA,QACA,wBACA,YACA,2BACA,yBACA,eACA,QAAiB,qBAA6B,OAC9C,8BAEA,gBACA,QACA,sBACA,QACA,OAAiB,qBAA6B,OAC9C,2BAEA,YACA,QACA,yBACA,WACA,IAAiB,qBAA6B,OAC9C,2BAEA,eACA,QACA,6BACA,yBACA,MACA,oBACA,4BACA,uBACA,QAAiB,qBAA6B,OAC9C,6BAEA,mCACA,2BACA,+BACA,yBACA,iBACA,iCACA,qCACA,0BACA,YAAG,yBACH,gCACA,UACA,YACA,uBACA,qBACA,YACA,YACA,oBACA,oBACA,iCACA,SACA,GACA,YACA,OACA,EACA,CACA,CACA,kBACA,kCACA,iBACA,aAAkB,qBAA6B,OAC/C,wBAEA,QAAG,uCACH,iBACA,wCACA,gBAAkB,qBAA6B,6BAE/C,YAIA,UALA,iCAMA,iBAAG,uCACH,iBACA,YACA,gBAAkB,qBAA6B,OAC/C,wBAEA,QAAG,uCACH,iBACA,YACA,gBAAkB,qBAA6B,OAC/C,wBAEA,QACA,CACA,wBACA,wCACA,UACA,uBACA,IACA,4BACA,YACA,2BACA,iBACA,+CACA,QAAiB,MAAuB,OACxC,6BAEA,2BACA,SACA,oBACA,WAAiB,qBAA6B,OAC9C,4BACA,UAGA,SACA,QACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,sECpMA,YACA,cACA,oCACA,YACA,aACA,oIANA,GAOA,mBACA,wBACA,mCACA,aACA,aAEA,oCACA,KACA,mBACA,8BACA,UACA,2BACA,qBACA,mBACA,wBACA,oFACA,gCACA,YACA,qBAEA,YACA,wCACA,OAEA,mBAAkB,iBAAyB,OAC3C,2DACA,oBAGA,SACA,QAAG,6CACH,UACA,sBACA,WAAiB,4BAAyC,GAC1D,6BACA,yEACA,6EACA,oBACA,WACA,gBACA,SACA,OACA,KAEA,CACA,0BACA,uBACA,gCACA,EACA,iCACA,aACA,eAEA,MACA,CACA,qBACA,aAGA,mFACA,GACA,wBACA,aACA,UAEA,wCACA,EACA,wBACA,YACA,mBACA,yBACA,OACA,EACA,sBACA,wBACA,QACA,yBACA,qBACA,MACA,oBACA,oBACA,WACA,mCACA,oBACA,QACA,+BACA,yBACA,iBACA,UACA,OACA,IACA,6CACA,yDACA,qBACA,MAEA,SACA,IACA,GACA,uBACA,OAEA,cACA,QAEA,EACA,CAAG,yBACH,gCACA,MACA,qCACA,QACA,CACA,kBACA,kCACA,iBACA,aAAkB,iBAAyB,OAC3C,0BAEA,iBAAG,uCACH,iBACA,oCACA,gBAAkB,iBAAyB,uBAE3C,cAEA,UAHA,iCAIA,iBAAG,uCACH,iBACA,YACA,KAAG,uCACH,iBACA,YACA,KACA,CACA,wBACA,sBACA,aACA,+BACA,OACA,eACA,4BACA,qBACA,gBACA,4BACA,YACA,mBACA,iBACA,uCACA,SACA,kCACA,aACA,OACA,oBACA,OACA,wBACA,kBACA,IACA,8DAEA,YACA,qFAEA,8BACA,SACA,0BACA,WAAiB,iBAAyB,OAC1C,qCACA,UAGA,SACA,QACA,0BACA,aACA,UAEA,oBACA,EACA,uBACA,mDACA,iBACA,wBACA,QACA,IACA,qBACA,CACA,QACC,IACD,mECjNA,YAAmC,QAEnC,yBACA,OACA,SAAsB,OAAkB,IACxC,WACA,KAEA,KAEA,cACA,KAGA,2DCTA,YACA,uBACA,MACA,yCACA,iBACA,kBACA,uBACA,OAAG,kCACH,iBACA,6BACA,8BACA,GACE,+BACF,gCACA,2BACA,8BACA,kBACA,cAAE,8BACF,+CACA,kBACA,2BACA,WAAE,8BACF,8DACA,6CACA,gDACA,kBACA,mBACA,6CA5BA,KA6BA,wBACA,4BACA,OACA,EAGA,6BAFA,0BACA,KAEA,+BACA,aACA,kBACA,oBACA,oBACA,QACA,kCACA,yBACA,iBACA,8BACA,gCACA,IAAG,8BACH,gCACA,eACA,wBACA,CACA,oBACA,oBACA,QACA,mBACA,WAAiB,EAAO,IACxB,wBACA,sCAEA,4BAGA,OACA,iBACA,aACA,mBACA,MACA,wBACA,yBACA,iBACA,8BACA,GAAG,yBACH,gCACA,sBACA,MACA,CACA,qBACA,UACA,WACA,+BACA,2BAEA,aACA,8BACA,4BAEA,eACA,UACA,mBACA,IACA,8DACG,iCACH,iBACA,sBACA,QACA,CACA,uBACA,oBACA,WACA,wBACA,yBACA,gCACA,+BACA,KAAG,8BACH,+CACA,eACA,gBACA,CACA,6BACA,+EACA,KACA,iCACA,oBACA,oBACA,oBACA,iEACA,IACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,yBACA,qBACA,QAAgB,EAAO,IACvB,sBAEA,gBACA,yBCvIA,aAKM,eAAgB,IAAG,QAAQ,QAcnB,cACV,MAAM,GAAS,SAAS,cACxB,YAAoB,yBAAc,EAAkB,SAEpD,SACE,CAQF,iBAAK,UAAY,EAOjB,eAAK,MAAQ,EAEb,WAAM,GAAM,SAAS,cACrB,SAAI,IAAM,EAEV,QACA,iBAAO,MAAQ,KAOf,WAAK,OACH,EAAQ,QACR,GAAI,IAAG,OAAO,OACZ,UAAU,EAQd,gBAAK,OAEL,OAAO,iBAAiB,QAAS,KAAK,QAAQ,KAM9C,YACD,aAMD,aACE,OAAO,MACR,OAMD,UACE,CAAI,KACF,YAEA,kBAEH,UAOD,CAAO,SACL,MACA,YAAM,OAAO,KACd,IAOD,CAAU,YACR,MACD,QAKD,WACE,MACA,eAAK,QAAQ,WACb,eAAK,OAAO,kBACZ,WACD,YAKD,aACE,MACA,eAAK,QAAQ,UAAU,OACvB,eAAK,OAAO,kBACZ,WACD,aAMD,YACE,OAAO,MACR,MAED,cACM,KACF,sBAAK,UAAY,SAAS,cAE1B,YAAK,UAAuB;;YAEtB,KAAoB,cAI1B;;OATF,MASO,IAAI,mBAAmB,YAAY,KAE3C,WAOD,cACE,CAAI,KACF,gBAAK,IAAI,mBAAmB,YAAY,KAE3C,UAGH,CApJE,CAoJa,oCCrKf,mCADA,IAEA,wBACA,wBACA,kBACA,yBACA,0BACA,yBACA,WACA,EAAG,8BACH,gCACA,EACA,CACA,+BACA,0BACA,kBACA,4BACA,kBACA,kBACA,+BACA,wBACA,QACA,IACA,qBACA,CACA,QACC,IACD,MACA,MACA,MACA,oCCtBA,aAOA,SARA,IASA,2BASA,EACA,8BAMA,EACA,+BAMA,EACA,gCAMA,EACA,4BAMA,EACA,+BAQA,EACA,8DC5CA,YACA,yBACA,qCACA,gBACA,KACA,yCACE,WACF,uDACA,iBACA,uBACA,IAAG,oCACH,iBACA,qBACA,sCACE,+BACF,gCACA,qBACA,sCAAE,8BACF,+CACA,QACA,uBACA,kCACA,OACA,sKAxBA,IAyBA,wBACA,uBACA,UACA,cAEA,yDACA,iDAEA,uDACA,wFAEA,8NACA,KACA,6BACA,IACA,sFACG,oCACH,iCACA,iBACA,yCACA,mDAAI,kCACJ,iBACA,oBACA,KACA,CACA,CACA,kCACA,IACA,yCACG,8BACH,iBACA,oBACA,KACA,CACA,2BACA,WACA,KACA,KACA,SAAmC,aAAa,WAChD,SACA,WACA,WACA,UAEA,KACA,QAEA,yBACA,KACA,IACA,qBAEA,8BACA,4CAEA,uCACA,SACA,gBACA,gBACA,sCACI,kCACJ,yCACI,qCACJ,oCAEA,2EACA,UACA,CACA,QACA,wCACA,uCACA,mDACA,wBACA,IACA,iFACG,oCACH,+BACA,iBACA,oCACA,qDAAI,kCACJ,iBACA,oBACA,KACA,CACA,CACA,yCACA,aACA,0BACA,0BACA,IACA,oDACG,8BACH,kCACA,iBACA,kCACA,oBAAI,iCACJ,iBACA,kCACA,oBAAI,+BACJ,iBACA,+BACA,KACA,CAAG,8BACH,gCACA,sBACA,KACA,CACA,oBACA,aACA,KACA,qCACA,IACA,yCACG,8BACH,iBACA,oBACA,KACA,CACA,4BACA,eACA,sBACA,gBACA,oFACA,gCACA,0CACA,SACA,CAEA,GACA,8BACA,aACA,eACA,6BACA,IACA,sFACG,oCACH,iCACA,iBACA,yCACA,mDAAI,kCACJ,iBACA,oBACA,KACA,CACA,CACA,+BACA,IACA,yCACG,8BACH,iBACA,oBACA,KACA,CACA,6BACA,IACA,yCACG,8BACH,iCACA,iBACA,oBACA,KAAI,kCACJ,iBACA,MACA,8CAEA,sCACA,QAAmB,QAAwB,OAC3C,qDACA,iCACA,aAEA,2BACA,mBACA,CACA,CACA,wBACA,QACA,IACA,qBACA,CACA,QACC,IACD,iCACA,4BACA,eACA,YACA,6BACA,mBACA,iCACA,eACA,YACA,gDACA,YACA,YACA,oCACA,4BACA,eACA,YACA,+BACA,4BACA,eACA,YACA,+BACA,4BACA,eACA,YACA,+BACA,4BACA,eACA,YACA,0BACA,4BACA,eACA,YACA,4BACA,4BACA,eACA,YACA,4CACA,8BACA,8BACA,gBACA,sECtQA,YACA,YACA,0BACA,iBACA,YACA,OAAE,8BACF,gCACA,mBACA,6BACA,+BACA,OACA,sCAZA,GAaA,mBACA,wBACA,yBACA,aACA,EACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,4BACA,6BAEA,oCzBpBA,YACA,WACA,iGAHA,KAIA,mBACA,wBACA,iCACA,0DACA,yDACA,4BACA,WACA,gCACA,yBACA,+CACA,WACA,iBACA,yCACA,iCACA,6BACA,kBAEA,+BACA,mBAGA,sBACA,eAAG,0DACH,UACA,wCACA,2CACA,6CACA,UACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,CACA,+CACA,OACA,QACA,OACA,qBAAG,SACH,gBACA,SACI,6BACJ,QAAG,SACH,CACA,QACA,gCACA,YACA,uCAOA,YANA,sCAEA,2BACA,kDAEA,gBAEA,sCACA,IACA,YAaA,MAXA,UACA,MAEA,MACA,SACA,MAEA,MACA,SAEA,MAEA,6BACA,WACA,6BACA,yDACA,qCACA,6CAEA,YACA,iDACA,UACA,aACA,aACA,aACA,aACA,UACA,2CACA,qCAGA,cAFA,SACA,GAEA,gDACA,WACA,wBACA,wBACA,wBACA,wBACA,mBACA,iBACA,SAEA,wBACA,kBACA,iBACA,SAEA,wBACA,kBACA,iBACA,4BAEA,+CACA,kBACA,iBACA,4BAEA,+CACA,kBACA,iBACA,4BAEA,+CACA,kBACA,iBACA,4BAEA,mDACA,eACA,0CACA,qBACA,kBACA,kBACA,kBACA,kBACA,kBACA,kBACA,kBACA,IACA,UACA,UACA,UACA,UAGA,GAFA,SAGA,GAFA,cAGA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,CACA,oCACA,SACA,iDACA,0BACA,mBACA,+BACA,eAEA,0BACA,mBACA,+BACA,eAEA,4CAEA,WAEA,4DACA,YACA,8BACA,wBACI,sBACJ,wBACI,KACJ,wBACI,QACJ,wBACI,QACJ,wBACI,QACJ,0BAGA,gBACA,iCAEA,2BACA,mBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,mCACA,IACA,WACA,4BACA,sBAeA,MAdA,OACA,IAEA,WACA,sBACA,MACA,IAEA,WACA,sBACA,MACA,IAEA,sC0BlOA,cAmLA,cAcA,0EAlMA,IAEA,wBACA,uBACA,CACA,QACA,qBACA,CACA,QACC,IACD,oBACA,SACA,wCAEA,KACA,2BACA,WAAgB,QAAoB,OACpC,SACA,sBAEA,eACA,OACA,sBACA,SACA,0BACA,iCACA,8BACA,gCACA,oCACA,SACA,mBACA,yBACA,gCACA,YACA,+BACA,gCACA,mBAAiB,MAAmB,OACpC,0BAEA,SACA,QAAE,yBACF,+CACA,YACA,+BACA,gCACA,mBAAiB,MAAmB,OACpC,gCAEA,SACA,QACA,GACA,4BACA,cACA,OAAgB,MAAwB,OACxC,8BAEA,kBACA,qBACA,+BACA,WAAgB,MAAkB,OAClC,qBACA,MAGA,SACA,UACA,kCACA,4BACA,kBACA,oBACA,qBACA,qBACA,oBACA,QACA,KAAgB,IAAU,KAC1B,MACA,YACA,OAEA,QACA,wBACA,WACA,IAAgB,MAAkB,OAClC,iBAEA,wBACA,cACA,mBACA,IAAgB,MAAkB,OAClC,yBAEA,MACA,UACA,qBACA,yBACA,iBACA,kCACA,QAAiB,MAAwB,OACzC,iBAEA,MACA,QAAE,yBACF,6EACA,aAAiB,EAAY,IAC7B,qBAEA,KACA,GACA,+BACA,WAAgB,MAAiB,WACjC,OACA,oBACA,yBACA,QACA,CACA,UACA,sBACA,cACA,OAAgB,MAAwB,OACxC,sBAEA,MACA,UACA,+BACA,oBACA,iBACA,4CACA,UACA,gBACA,uBACA,WAAgB,MAAwB,OACxC,gBACA,MAGA,gBACA,GACA,iCACA,WAAgB,eAAgC,OAChD,gBACA,qBACA,eACA,QACA,OACA,IACA,uBACA,WACA,0BACA,sBACA,eACA,SACA,GACA,oBACA,aACA,EACA,GACA,2BACA,WACA,OAAgB,MAAwB,OACxC,cACA,yBAGA,MACA,UACA,yBACA,mBACA,2BACA,kBACA,UACA,mBACA,WACA,uBACA,cACA,mBACA,EAAoB,IAAU,KAC9B,WAEA,KACA,UAEA,wBACA,sBAGA,UACA,YACA,wBACA,QACA,IACA,qBACA,CACA,QACC,IAED,wBACA,sBACA,IACA,KACA,gCACA,6BACA,yBACA,WACA,iBACA,8BAEA,GACA,0BACA,IACA,KACA,gCACA,6BACA,yBACA,eACA,2BACA,wCACA,mBACA,IAAiB,QAAiB,WAClC,qBACA,YACA,SACA,KACA,IACA,OACA,EACA,wBACA,QACA,IACA,qBACA,CACA,QACC,IACD,sBACA,4BACA,6DCzOA,YACA,gCACA,YACA,uEAJA,GAKA,mBACA,wBACA,uBACA,oFACA,gCACA,gBAGA,qDACA,SAAG,6CACH,UACA,iCACA,aACA,eAEA,MACA,CACA,qBACA,SACA,UAEA,mBAAiB,qBAA6B,OAC9C,4BACA,WAGA,SACA,QACA,wBACA,YACA,wBACA,yBACA,OACA,EACA,oBACA,4BACA,uBACA,QAAiB,qBAA6B,OAC9C,iCAEA,mCACA,wBACA,wBACA,sBACA,aACA,4BACA,YACA,wBACA,iBACA,+CACA,QAAiB,MAAwB,OACzC,6BAEA,2BACA,SACA,wBACA,QACA,IACA,qBACA,CACA,QACC,IACD,qECtEA,0CADA,IAEA,wBACA,uBACA,CACA,QACA,qBACA,CACA,QACC,IACD,+BACA,CACA,iBACA,eACA,iBACA,cACA,gBACA,kBACA,oBACA,WACA,aACA,WACA,aACA,WAEA,qBACA,gCACA,8BACA,YACA,uBACA,mBACA,aACA,kBACA,YACA,sBACA,gBACA,eACA,SACA,eACA,SACA,eAEA,iBACA,iCACA,MACA,MACA,MACA,WACA,UACA,cACA,gBACA,eACA,mBACA,YACA,YACA,0CC1CA,YACA,aACA,iBACA,mDACA,eACA,QACA,+BAEA,oBACA,WAEA,UACA,iCAEA,4DACA,qCAEA,yCACA,cACA,qIApBA,GAqBA,mBACA,wBACA,mCACA,oBACA,qBACA,2BACA,SACA,UAEA,mDACA,SACA,gBACA,mBAAiB,MAA6B,OAC9C,IACA,SAEA,eAAiB,kBAAwB,WACzC,kBACA,2BAAkB,MAA6B,OAC/C,IACA,SAEA,IACA,CACA,QACA,oBACA,IACA,+BACA,mCAAiB,gBAAwB,OACzC,iCAEA,yBACA,QACA,wBACA,kCACA,+BACA,2CACA,+BACA,+BACA,wBAAiB,IAAO,QACxB,QACA,yCACA,iBACA,4CACA,QACA,kBACA,YACA,KAAiB,EAAQ,SACzB,SACA,YACA,UACA,QACA,cACA,SACA,IACA,GACA,CACA,QACA,wBACA,oFACA,gCACA,YACA,qBAEA,YACA,YACA,WACA,aACA,iBAEA,0CACA,OAEA,mBAAkB,gBAAwB,OAC1C,qCACA,aAGA,SACA,QAAG,6CACH,UACA,sBACA,yBACA,qBACA,qBAAkB,gBAAwB,OAC1C,wBAEA,4BACA,OAAG,8BACH,gCACA,QACA,gBAEA,oDACA,+CACA,kCACA,sBACA,qDACA,uCACA,eACA,qCAEA,iBACA,CACA,0BACA,oBACA,eACA,+BACA,oBACA,MACA,iCACA,OACA,EACA,wBACA,YACA,gBACA,yBACA,OACA,EACA,sBACA,IACA,oBACA,sBAAiB,gBAAwB,OACzC,sBAEA,YACA,QACA,yBACA,uBACA,iBAAiB,gBAAwB,OACzC,sBAEA,eACA,QACA,oBACA,YACA,mCACA,kDACA,gBAAiB,gBAAwB,OACzC,sCAEA,UACA,QACA,uBACA,+BACA,YACA,+BACA,yBACA,iBACA,cACA,WACA,gBACA,qBAAG,yBACH,gCACA,MACA,YACA,WACA,WACA,iCACA,wBACA,yBACA,uBACA,YACA,YACA,wBACA,wBACA,iCACA,SACA,GACA,YACA,OACA,EACA,CACA,CACA,kBACA,kCACA,iBACA,eACA,mBAAkB,gBAAwB,OAC1C,mBAEA,QAAG,uCACH,iBACA,kBACA,YACA,mBAAmB,gBAAwB,wBAE3C,YAGA,UAJA,iCAKA,iBAAG,uCACH,iBACA,YACA,KAAG,uCACH,iBACA,YACA,kBACA,mBAAkB,gBAAwB,OAC1C,mBAEA,QACA,CACA,wBACA,SACA,mCAEA,+DACA,gBACA,iBAAiB,gBAAwB,OACzC,gBAEA,qEACA,2CACA,wBACA,4BACA,YACA,gBACA,iBACA,uBACA,wCACA,QAAiB,gBAAwB,OACzC,wBAEA,6BACA,SACA,4BACA,aACA,MACA,oBACA,oBACA,SACA,8BACA,aACA,SACA,wBACA,QACA,IACA,qBACA,CACA,QACC,IACD,sEC3QA,YACA,6DACA,gCACA,gDACA,YAAE,mEACF,gCACA,YACA,eACA,sBACA,qFAVA,GAWA,mBACA,wBACA,gCACA,YACA,KACA,qBACA,cAGA,uCACA,KACA,wBACA,YACA,mBACA,oBACA,oBACA,WACA,mCACA,oBACA,QACA,iCACA,kDACA,oBAEA,yIACA,sHAEA,wBACA,4BACA,YACA,mBACA,iBACA,uCACA,SACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,uBACA,sEC3CA,YACA,oBACA,oBACA,sBACA,iBACA,uBACA,6BACA,6BACA,8BACA,oCACA,YACA,iCACA,yBACA,6KAdA,IAeA,mBACA,wBACA,6BACA,sBACA,6BACA,SACA,eACA,aACA,kCACA,cAEA,gBACA,aACA,YAEA,SACA,SACA,QACA,qBAEA,MACA,qBACA,aACA,MACA,uCACA,qCAAqD,aAAc,WACnE,SACA,WACA,2BACA,iBACA,kBAEA,gBACA,CACA,2BACA,+BACA,0CAEA,gBACA,mCACA,UACA,cACA,YACA,YACA,uGACA,0BACA,gBACA,2BACA,kCAAsD,eACtD,eACA,oBAEA,gBACA,yBACA,aAAoC,aAAc,WAClD,SACA,yBACA,gCACA,QACA,CACA,QACA,kCACA,cACA,sBAA0C,eAC1C,eACA,SACA,kBACA,iBAGA,oCACA,SACA,gCACA,kCAAsD,aAAkB,WACxE,SACA,sBACA,wBACA,QACA,CACA,+BACA,aACA,uBACA,WACA,+BACA,aAAgC,eAChC,eACA,YAEA,mBACA,4BACA,iBACA,mBACA,sCACA,2CACA,gEACA,iBACA,kBACA,kCAEA,0BACA,0BACA,+BACA,sDACA,gDACA,iBACA,wBACA,4BACA,4BACA,gDACA,sBACA,+BACA,qDACA,mCACA,gDACA,oCACA,+FACA,kBACA,mCACA,6DACA,4BACA,gBACA,wBACA,wBAAqD,oBAAa,WAClE,SACA,+BACA,2CACA,eACA,CACA,iCACA,qCAAqD,aAAc,WACnE,SACA,WACA,8GACA,aAEA,eACA,CACA,oCACA,0BAA0C,aAAc,WACxD,SACA,WACA,eACA,0BACA,GACA,sBAAmB,EAAO,IAC1B,gCACA,YACA,oBAEA,4CACA,4FACA,yCACA,8FAIA,SACA,CACA,CACA,6BACA,kCAAsD,eACtD,eACA,0CAEA,WACA,sBACA,qBACA,iCACA,WACA,2BAAkD,aAAc,WAChE,SACA,WACA,aACA,eACA,2CAAwD,8BAExD,iBACA,kBACA,CACA,0BACA,+BAEA,gBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,2BACA,OACA,eACA,qBACA,UACA,qBACA,6BACA,sEACA,sCACA,+BACA,MACA,qEACA,wFACA,QACA,4BACA,6EACA,0CAEA,kBACA,uBACA,QACA,MACA,iBACA,UACA,eAEA,GACA,qEACA,wFACA,eACA,6BACA,6BACA,8EACA,sCACA,+BACA,MACA,qEACA,wFACA,gBACA,iCACA,SACA,mBACA,kBAEA,EAcA,aAbA,eAEA,aACA,QAEA,aACA,WAEA,UACA,gBAGA,iBAEA,qCACA,OACA,cACA,6BACA,MACA,2BACA,UACA,OACA,cACA,UACA,OACA,mBACA,UACA,OAGA,iBACA,UACA,0BACA,8DACA,sCACA,2EACA,wFACA,aACA,yBACA,yBACA,gCACA,uBACA,mBACA,YACA,mBAAE,yBACF,+CACA,mCACA,mCAEA,gBACA,uCACA,eACA,gCACA,eACA,qCACA,eACA,8EAGA,SACA,GACA,iBACA,UACA,eACA,8CC5UA,aACA,WACA,wBACA,iCACA,iBACA,cAEA,2CACA,4DCPA,4BADA,GAEA,wBACA,mBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,mBCVD,aAKA,aAKA,CANA,MAOA,+BAKA,EACA,4BAKA,EACA,8DCjBA,aAAsB,0BACtB,aAAuB,8BACvB,eAA0B,uBAC1B,aAAqB,4BACrB,aAAsB,4BAQtB,CACA,YAKA,YAKA,gBACA,gCA5BA,IAEA,QACA,MA0BA,eAKA,KACA,2BACA,gBACA,gBACA,qBACA,QACA,QACK,aACL,QAEA,oBAEA,KACA,OACA,KAKA,EACA,6BACA,IACA,oCACA,CACA,MACA,aACA,WACA,YACA,KACA,kBAAkB,kBAClB,UAAgB,gBAEhB,cACA,EAEA,wBACA,EACA,MACA,oBACA,KACA,QACK,aACL,QACK,UACL,SACA,MAEA,SADA,SAEG,OACH,gBACA,CACA,WACA,WACA,KACA,QACA,SACA,kBAAgB,kBAChB,UAAc,gBAEd,SACA,OAEA,SAEA,aACA,0BACA,QACA,IAKA,EACA,yCACA,OACA,yCACA,8BACA,WACA,OACA,WACA,QACA,WACA,aAEA,aACA,UACA,UAEA,iBACA,YACA,4BAEA,OAAK,KACL,WACA,OACA,WACA,QACA,WACA,aAEA,aACA,UACA,UAEA,kBACA,YACA,2BAEA,OAEA,YACA,OAKA,EACA,6BACA,UACA,YACA,mBACA,qBACA,OACA,mCAGA,OACA,QAKA,EACA,+BACA,UACA,YACA,mBACA,eACA,OACA,6BAGA,OACA,QAKA,EACA,kCACA,YACA,SACA,gBACA,KACA,sBACA,qBACA,OACA,oBACA,iBACA,iBAEA,gBACA,UACA,SACA,QACA,CAKA,EACA,mCACA,YACA,SACA,cACA,8BACA,qBACA,OACA,oBACA,iBACA,kBACA,iBACA,SACA,UACA,QACA,CAKA,EACA,oCACA,YACA,SACA,aACA,kBAGA,KACA,QAOA,EACA,uBACA,IACA,eACA,wBACA,aACA,MACA,mBAEA,KACA,QACA,aACA,OACA,oBACA,OACA,QAEA,OAEA,QAKA,EACA,2BACA,aACA,qCCjQA,YACA,mBACA,oCACA,YACA,aACA,2GANA,GAOA,mBACA,wBACA,mCACA,SACA,oBAEA,cACA,KAEA,0EADA,KAEA,2BACA,gCACA,gBACA,wBACA,oFACA,gCACA,gBAGA,yCAGA,gCAGA,8CACA,mBAAG,6CACH,UACA,uBACA,0BACA,qCACA,uCACA,iCACA,YACA,KACA,wBACA,YACA,cACA,yBACA,OACA,EACA,yBACA,yBACA,CACA,oBACA,aACA,MACA,iBACA,IACA,4DAEA,0DACA,CACA,+BACA,yBACA,iBACA,MACA,6CACA,gBAAG,yBACH,gCACA,MACA,0CACA,aACA,CACA,kBACA,kCACA,iBACA,WACA,gBAEA,oBACA,gBAAG,uCACH,iBACA,2BACA,iCACA,+BACA,iBAAG,uCACH,iBACA,YACA,KAAG,uCACH,iBACA,YACA,KACA,CACA,wBACA,0BACA,0BACA,4BACA,YACA,cACA,iBACA,4CACA,SACA,kCACA,aACA,YACA,iBACA,IACA,4DAEA,0DACA,CACA,oBACA,OACA,6BACA,kBACA,CACA,8DAEA,uBACA,kBACA,cACA,qBACA,CACA,QACA,wBACA,QACA,IACA,qBACA,CACA,QACC,IACD,qECtIA,YACA,gCACA,YACA,8DAJA,GAKA,mBACA,wBACA,uBACA,oFACA,gCACA,gBAGA,qDACA,SAAG,6CACH,UACA,iCACA,OACA,EACA,wBACA,YACA,qBACA,yBACA,OACA,EACA,oBACA,4BACA,uBACA,QAAiB,qBAA6B,OAC9C,6BAEA,mCACA,qBACA,wBACA,SACA,mCAEA,qCACA,OAAiB,qBAA6B,OAC9C,mBACA,mBACA,gBAAkB,MAA8B,mBAChD,YAGA,4CACA,uDACA,WACA,4BACA,YACA,qBACA,iBACA,+CACA,QAAiB,MAAqB,OACtC,6BAEA,2BACA,SACA,wBACA,QACA,IACA,qBACA,CACA,QACC,IACD,qEC7CA,aACA,gBACA,sBA3BA,SAwBA,GAKA,wBASA,SACA,oBACA,QACC,IAED,cAWA,kBACA,IACA,qCAGA,sEACA,IACC,kDC5DD,GAEA,QACA,wBACA,OACA,aACA,UACA,YAEA,EACA,iBACA,UACA,cACA,EACA,oBACA,WAEA,gBAEA,cAEA,kBACA,2BAAsC,OAAY,IAClD,MACA,aAEA,KACA,2BACA,YACA,KAEA,SADA,QAIA,uCCzBA,YACA,YACA,aACA,KACA,4CACE,mCACF,iBACA,sBACA,GAAE,8BACF,gCACA,QACA,UACA,IAAE,8BACF,8DACA,+BACA,UACA,qFAjBA,IAkBA,wBACA,gBACA,4BACA,EACA,6BACA,6BACA,iBACA,qCACA,kCACA,sBACA,kBACA,OACA,CAAG,+BACH,iBACA,iCACA,KACA,CACA,wBACA,yCACA,IACA,uBACA,4BACA,CACA,oBACA,MACA,gBAEA,YACA,mDACA,GACA,0BACA,UACA,yDACA,0CACA,GACA,IACA,oBACA,+BACA,iBACA,qDACA,mBACA,yBACA,KAGA,0CAFA,sCACA,IACG,6BACH,iBACA,iCACA,8BACA,wBACA,0BACA,2BACA,iBACA,iBACA,yBACA,wBACA,iBACA,IACA,UACA,CACA,sBACA,oCACA,SACA,kBACA,gDACA,EACA,2BACA,mBACA,QACA,EACA,mCACA,oDACA,GACA,iBACA,4BACA,EACA,qBACA,gCACA,GACA,8BACA,sBACA,8BACA,iCACA,sBACA,QACA,uBACA,0CACA,QACA,QACA,2BACA,YACA,mBACA,eAEA,sBACA,YACA,YACA,2BACA,mBACA,MACA,YACA,6BACA,mBACA,IACA,MACA,MACA,YAEA,8BACA,sBACA,IACA,MACA,cACA,KAEA,gCACA,IAOA,yBANA,IACA,MACA,cACA,KAEA,OAEA,0BACA,YACA,4BACA,gBAEA,yBACA,sBACA,4BACA,QACA,EACA,iBACA,4BACA,EACA,sBACA,8BACA,GACA,uBACA,IACA,2BACA,UACA,2BACA,KACA,oBACA,YACA,gBACA,QACA,IACA,wBACA,2FACA,GACA,8BACA,IACA,+CACA,IACA,QAAG,SACH,gBAAkD,UAClD,QAAG,SACH,OACA,KACA,iBACA,4BACA,EACA,gCACA,sCACA,oCACA,uBACA,sBACA,UACA,KACA,IACA,aACA,yCACA,yDACA,QACA,KACA,OACA,MACA,SACA,UACA,QACA,2BACA,yBACA,iBACA,8BACA,GAAG,8BACH,gCACA,eACA,cACA,cACA,cACA,CACA,CACA,6BACA,YACA,oBAEA,WAFmC,0BACnC,MAEA,qBACA,2EACA,GACA,yBACA,4BACA,CACA,qBACA,6BACA,iBACA,sDACA,GAAG,+BACH,iBACA,4CACA,GACA,CACA,wBACA,UACA,KAGA,0CAFA,sCACA,IAEA,qBACA,iDACA,MACA,gEACA,gDACA,MACA,gEACA,UACA,IACA,wBACA,YACA,IACA,qBACA,CACA,QACC,IACD,wBACA,sCACA,IACA,uEC5QA,6CCAA,2CCCA,4BADA,GAEA,wBACA,mBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCCDD,YAAgC,gBADhC,IAEA,yCACA,YAMA,cACA,0BAAiC,CASjC,EACA,0BAAiC,CAMjC,EACA,8BAAqC,iCClCrC,4BADA,GAEA,wBACA,mBACA,oBACA,+BACA,wBACA,CACA,QACA,qBACA,CACA,QACC,gCCZD,aACA,MACA,KAEA,qCACA,MACA,MAEA,qCACA,mDACA,EAEA,iCACA,aACA,iCCdA,aACA,MACA,cAEA,+BACA,aACA,OACA,iCACA,sBACA,eACA,EACA,GAEA,gDCZA,4BADA,GAEA,wBACA,uBACA,CACA,QACA,qBACA,CACA,QACC,kCCHD,YACA,gCACA,YACA,+DAJA,GAKA,mBACA,wBACA,mBACA,CACA,QACA,wBACA,oFACA,gCACA,gBAGA,qDACA,SAAG,6CACH,UACA,0BACA,0CACA,iBACA,8BACA,eAAG,+CACH,UACA,iCACA,YACA,KACA,wBACA,YACA,mBACA,yBACA,OACA,EACA,wBACA,0BACA,0BACA,4BACA,YACA,mBACA,iBACA,+CACA,QAAiB,MAAmB,OACpC,6BAEA,2BACA,SACA,wBACA,QACA,IACA,qBACA,CACA,QACC,IACD,sECxDA,0CADA,GAEA,wBACA,uBACA,CACA,QACA,qBACA,CACA,QACC,IACD,wBACA,wBACA,IACA,0BACA,UACA,iBAGA,WAFA,IAGA,+BACA,UACA,uBACA,SACA,QACA,UACA,0BAEA,KACA,6BACA,cACA,mBAEA,gBACA,GACA,qBACA,iEACA,gCACA,qFACA,YACA,aAAqC,KAErC,UAAqC,KAErC,EAAE,2DACF,gCACA,yCACA,yEACA,aAAwC,KAExC,cAAwC,KAExC,EACA,GACA,OACA,OACA,OACA,qCClDA,YACA,wBACA,gBACA,gBACA,oCACA,QACA,YACA,4EARA,KASA,wBACA,0BACA,aACA,IACA,iBACA,kBACA,MACA,2BACA,aACA,OACA,qBACA,uDACA,GACA,8BACA,gCACA,6DACA,GACA,qBACA,MACA,OACA,0BACA,sBACA,MACA,WACA,oBACA,aACA,KACA,4BACA,yBACA,gCACA,QACA,wBAAG,8BACH,8DACA,mBACA,yBACA,oBACA,CACA,qBACA,sCACA,MACA,wBACA,aACA,SACA,mCACA,IACA,SACA,wBACA,YACA,UACA,cAEA,IACA,sBACA,SACA,QACA,kCACA,WAAiB,MAA6B,qBAC9C,SAEA,wBACA,wBACA,QACA,IACA,qBACA,CACA,QACC,IACD,+BACA,yBACA,iBACA,YACA,KAEA,SADA,yBACE,yBACF,gCACA,eAAqC,eACrC,eACA,uBAEA,gBACA,iCCtFA,aAAkB,gBAOlB,CACA,eACA,4BACA,wCACA,wBArBA,QAQA,GAeA,wBAKA,wBACA,SACA,MACA,2FAGA,sBAOA,SACA,cACA,0BACA,kBACK,+CACL,gBACK,6CACL,gBACK,6CACL,aACK,0CACL,gBACK,6CACL,qBACK,kDACL,kBACK,+CACL,wBAEA,+BAEA,qBACA,WACA,wEACA,IAEA,0BACA,gFACA,uBACA,GACA,GAEA,0BACA,gFACA,uBACA,GACA,GAEA,uBACA,WACA,uBACA,KACA,eAAmB,MAAwB,WAC3C,oCACA,MACA,MAEA,MAEA,OACA,6BACA,kBAEA,0BACA,sCACA,aACA,mBAAK,EACL,kCACA,mBAEA,+BACA,2CACA,aACA,wBAAK,EACL,kCACA,wBAEA,4BACA,wCACA,aACA,qBAAK,EACL,kCACA,qBAEA,0BACA,0CACA,aACA,OAAK,EACL,kCACA,2BAQA,UACA,IACA,2DACK,uBACL,wCACK,uBACL,wCACK,uBACL,qCACK,oBACL,wCACK,uBACL,6CACK,4BACL,0CACK,yBACL,gDAEA,6BAEA,mBACA,sCACA,GAEA,wBACA,8BACA,+BACA,aAEA,wBACA,8BACA,+BACA,aAEA,qBACA,sCACA,kBAAmB,aAA2B,OAC9C,4CAEA,gCACA,UAEA,wBACA,uDACA,OAEA,6BACA,IACA,gBAAmB,kBAAwC,OAC3D,sDAEA,0CACA,kBAEA,0BACA,IACA,gBAAmB,kBAAqC,OACxD,mDAEA,0CACA,eAEA,wBACA,IACA,gBAAmB,kBAA2C,WAC9D,SACA,2BACA,SACA,yBACA,qBACC,kCCrMD,cAUA,cAYA,cAYA,cAYA,4BA/CA,GAEA,wBACA,yBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IAED,wBACA,yBACA,OACA,OACA,wBACA,OACA,GACA,qBACA,CACA,QACC,IAED,wBACA,yBACA,OACA,IACA,wBACA,OACA,GACA,qBACA,CACA,QACC,IAED,wBACA,yBACA,OACA,IACA,wBACA,OACA,GACA,qBACA,CACA,QACC,IAED,wBACA,yBACA,OACA,MACA,wBACA,OACA,GACA,qBACA,CACA,QACC,IACD,yBACA,6BACA,wCACA,uCACA,2BACA,+BACA,2CACA,0CACA,2EC7DA,YACA,cACA,MAA+B,mDAC/B,iBACA,yBACA,aACA,SAAE,8BACF,gCACA,yBACA,aACA,QACA,oDAZA,GAaA,mBACA,wBACA,0BACA,aACA,MACA,mBACA,wFACA,gCACA,UACA,UAAgC,aAChC,sBACA,UAEA,KACA,QAAG,wCACH,UACA,kBACA,oCACA,QAAiB,SAAiB,OAClC,wBAEA,SACA,QACA,8BACA,uBACA,eACA,gBACA,yBACA,iBACA,0BACA,OAAG,8BACH,iEACA,gCACA,GAEA,YADA,cACI,+DACJ,gCACA,MACA,mBACA,4BACA,0BACA,KAEA,wBACA,OAAI,uEACJ,gCACA,GAEA,YADA,WAEA,CAAG,8BACH,iGACA,+CACA,GACA,eAAoB,MAAkB,OACtC,aAGA,gCAAmC,EAAQ,KAC3C,aAGA,QACA,QAAI,gFACJ,+CACA,SACA,YACA,cACA,QACA,kBACA,0BACA,KACA,QACA,YACA,8BACA,KACA,CACA,CACA,wBACA,SACA,CAAG,8BACH,8DACA,SACA,WACA,UAAsB,KAAW,MACjC,cAEA,QACA,QACA,CACA,sBACA,0CACA,OACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,8CCrHA,aAMA,aACA,iBACA,GAHA,MAIA,eAKA,OACA,wECdA,4BADA,GAEA,wBACA,mBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,gCCVD,aACA,MACA,YAEA,8BACA,MACA,QAEA,mCACA,mDACA,IAEA,+BACA,aACA,mC1DbA,YACA,6BACA,8CACA,4BACA,8BACA,yBACA,yCACA,wBAA+B,mDAC/B,iBACA,QACA,sBAAE,8BACF,gCACA,QACA,4BACA,iBAAE,8BACF,8DACA,QACA,4BACA,uBACA,qBACA,gBACA,gBAtBA,GAuBA,wBACA,0BACA,aACA,YACA,0BACA,aACA,cACA,iCACA,MACA,mEACA,YACA,6CACA,mCAEA,oBACA,8BAEA,uBACA,sCAEA,0BACA,yBACA,aACA,UACA,0BACA,MACA,YACA,+BACA,0BACA,GACA,8BACA,aACA,eACA,gCACA,aACA,iBACA,4BACA,MACA,cACA,0BACA,aACA,WACA,2BACA,MACA,aACA,4BACA,MACA,gBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,iCACA,iBAEA,KACA,cACA,aACA,eACA,eACA,eACA,eACA,8BACA,wBACA,6D2DnFA,wEADA,IAEA,wBACA,uBACA,CACA,QACA,qBACA,CACA,QACC,IACD,qBACA,8DACA,gCACA,gBACA,UACA,UACA,SACA,SAAiB,EAAO,IACxB,yBACA,OACA,qBACA,6BACA,kBAGA,SACA,QAAE,6DACF,gCACA,gBACA,OAAiB,MAAiB,WAClC,WACA,KACA,UACA,6BACA,kBAEA,QACA,CACA,QACA,GACA,4BACA,YACA,wBACA,wBACA,kCACA,wCChDA,YACA,eACA,2FAHA,GAIA,mBACA,wBACA,uBACA,CACA,QACA,qBACA,CACA,QACC,kCCVD,YACA,WACA,YACA,YACA,KACA,0BACA,SACA,SACE,iCACF,iBACA,YACA,WACA,OACA,GAAE,SACF,sFACA,gCACA,QACA,SACA,SACA,GAAG,4DACH,gCACA,wBACA,uBACA,uBACA,CAAG,gEACH,gCACA,gBACA,eACA,uBACA,CACE,+BACF,+CACA,QACA,SACA,SACA,GAAE,8BACF,8DACA,eACA,UACA,kBACA,UACA,UACA,kBACA,aACA,eACA,eACA,GACA,uCAhDA,GAiDA,wBACA,gBACA,mBACA,uBACA,uBAEA,KACA,QACA,iBACA,mBACA,uBACA,uBAEA,KACA,QACA,0BACA,UACA,KAGA,gBAFA,gBACA,QAEA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,gCACA,aACA,UACA,kBACA,UACA,UACA,kBACA,QAGA,MACA,KAHA,SAIA,KAHA,6DAIA,uBAEA,eACA,yCC5FA,kDADA,IAEA,wBACA,uBACA,CACA,QACA,qBACA,CACA,QACC,IACD,oCACA,yBACA,8CACA,yBACA,cACA,oBACE,SACF,4CACA,MACA,KACG,SACH,4CACA,0CACA,KACA,MACA,oBACA,OAEA,KACA,CAEA,4FAGA,0BACA,gCACA,kCACA,uDACA,2CACA,uBACA,6BACA,wDACA,kBACA,MACA,0CACA,4CACA,2CACA,kBACA,MACA,oCACA,+BACA,sEACA,MAAgB,eAAqB,EACrC,kCACA,IACA,MAGA,KACA,wCCnDA,YACA,mBACA,iBACA,0BACA,KACA,4CACE,qCACF,iBACA,kBACA,OACA,6FAXA,IAYA,wBACA,uBACA,WACA,oBAAiB,gBAAwB,WACzC,qBACA,uBACA,SACA,kBACA,QACA,CACA,kBACA,oBACA,OACA,oBACA,+BACA,iBACA,sBACA,UAAG,+BACH,iBACA,sBACA,UACA,CACA,4BACA,oBACA,UACA,oCACA,uBAA2C,eAC3C,eACA,oBAEA,yBACA,0BACA,SACA,UACA,8BACA,mBACA,oBACA,iBACA,mDAEA,QACA,iCACA,uBAA2C,eAC3C,eACA,oBAEA,sBACA,wCACA,WACA,qEAEA,aACA,wBACA,aACA,YACA,wBACA,SACA,QACA,4BACA,oBACA,UACA,uCACA,WAAiB,gBAAwB,WACzC,mBACA,WACA,6DACA,uEACA,QACA,OACA,KACA,wBACA,aACA,MACA,yBACA,8BAA6C,eAC7C,kBACA,uBAEA,eACA,KACA,sBACA,aAAsC,eAAc,WACpD,KACA,mBACA,gBACA,gBACA,aACA,YACA,eACA,YACA,MACA,CACA,iBACA,aACA,yBACA,MACA,qBACA,oBACA,QACA,wBACA,WAAiB,gBAAwB,WACzC,mBACA,WACA,mDACA,QACA,OACA,KACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,qCACA,aAAoC,eACpC,eACA,oBAEA,yDCxIA,YACA,WACA,kBACA,iBACA,oCACA,QACA,cACA,mCACA,iDATA,IAUA,mBACA,wBACA,kCACA,sCAAsD,eACtD,kBACA,gCAEA,SACA,QACA,uBACA,OACA,mCACA,0BACA,aACA,MACA,mBACA,6CACA,OACA,uBACA,qCACA,WACA,sBACA,4BACA,SACA,kCACA,IACA,CACA,QACA,qBACA,2DACA,gCACA,GACA,kCACI,sBACJ,gBAAG,+CACH,UACA,qBACA,aACA,MACA,uBACA,6BACA,iBACA,qBACA,OAAG,oCACH,iBACA,aAAkB,EAAO,QACzB,YACA,yCACA,yCACA,gBACA,CACA,CACA,iBACA,aACA,oBACA,KACA,8BACA,6BACA,gBACA,wCACA,sBACA,KACA,mBACA,eACA,SACA,eACA,eACA,SACA,MACA,cAGA,sBACA,gBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCC7FD,4BADA,GAEA,wBACA,sBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,mBCVD,aAMA,aACA,iBACA,GAHA,MAIA,eAKA,OACA,uEnEbA,oCADA,GAEA,wBACA,uBACA,CACA,QACA,qBACA,CACA,QACC,IACD,mBACA,uBAEA,oBACA,eACA,QACA,uBACA,IACA,KAIA,aAHA,WACA,WACA,QAEA,kBACA,gGACA,+CACA,SACA,OAEA,OAAE,sDACF,+CACA,SACA,OAEA,OACA,GACA,oBACA,OACA,OAEA,MACA,KACA,gBACA,yBACA,+CACA,MACA,KAGA,aAFA,WACA,MACE,yBACF,8DACA,MACA,KAIA,aAHA,WACA,WACA,MAEA,GACA,uBACA,QACA,QACA,yDoEjDA,YAKA,MAEA,gCACA,4BAEA,kDAXA,IAYA,eAKA,KACA,gCACA,2BAA2C,SAAS,IACpD,cACA,UACA,MAGA,SACA,QAKA,EACA,2BACA,aAIA,0BAGA,WAKA,EACA,8BACA,aAA4B,aAC5B,sBAEA,QACA,QAKA,EACA,6BACA,2BACA,qBAKA,EACA,2BACA,oBACA,MAKA,EACA,8BACA,OACA,uBAKA,EACA,8BACA,QAEA,wBAA2C,OAAS,IACpD,gBAGA,WACA,QAKA,EACA,+BACA,cACA,KASA,EACA,iBAKA,MAKA,0BACA,CAKA,EACA,2BACA,mCACA,gBAEA,sCACA,YAKA,EACA,8BACA,uCAKA,OAKA,EACA,6BACA,UACA,oCCzJA,aAGA,eAJA,GAKA,iBACA,0BACA,KACA,qBAKG,sBAJH,UACA,YACA,SACA,WAEA,iCACA,kBACA,OACA,eACA,IACG,qCACH,kCACA,MACA,qEACA,0BACA,UAAe,MAAc,OAC7B,WAEA,MACA,MAAG,yBACH,sCACA,gBACA,kBACA,OACA,eACA,IACA,kEACA,sBACA,UAAe,MAAc,OAC7B,WAGA,KACA,EAMA,EACA,oBACA,cACA,aAAqC,OAAS,IAC9C,UAEA,MACA,wCCxDA,mEADA,IAEA,wBACA,uBACA,CACA,QACA,qBACA,CACA,QACC,IACD,6BACA,gCACA,kBAAkB,EAAc,IAChC,wBAEA,mBACA,oBACA,SACA,eACA,UACA,yGACA,IACA,uBACA,SACA,WACA,gBACA,wCACA,kBAAgB,EAAa,IAC7B,cAAiB,EAAS,QAC1B,SACA,qBACA,2CACA,sCACA,UACA,QAEA,CACA,UACA,wBACA,oBACA,oBACA,uBACA,KACA,WAAiB,KAAU,yBAE3B,GACA,UACA,qBACA,oBACA,QACA,KAAgB,EAAU,KAC1B,eAEA,MACA,sBACA,gBACA,gBAAkB,QAA0B,eAC5C,QACA,qCACA,oBAEA,oBACA,0BACA,WAAgB,EAAY,IAC5B,wBAEA,MACA,qBACA,wDACA,iBACA,WACA,sBACA,aACA,oBACA,cACA,eAAiB,EAAU,QAC3B,eACA,eAAkB,EAAS,IAC3B,kBACA,6BAEA,kBACA,iBACA,OACA,UACA,GACA,+BACA,SACA,gBACA,+CACA,2GAEA,uCACA,IACA,kCACA,oBACA,oBACA,oBACA,YAAgB,KAAU,uBAC1B,GACA,wCCjGA,YACA,oBACA,oBACA,KACA,sDACA,iBACA,iBACA,EAAG,yBACH,iBACA,mCACA,gBAAkB,EAAU,IAC5B,4BAEA,IAAG,uCACH,iBACA,MACA,0CACA,MAEA,uBACA,sDACA,gBAAkB,sBAA8B,OAChD,2BAEA,oBACE,UACF,sEACA,gCACA,QACA,oBACA,kDACA,MAAG,0CACH,gCACA,mCACA,WACA,uBAAkB,EAAU,IAC5B,4BAEA,IAEA,oEAzCA,IA0CA,wBACA,4BACA,CACA,mBACA,uBACA,IACA,eACA,uBACA,IACA,eACA,uBACA,IACA,MACA,sBAEA,0BACA,iBACA,0BACA,MACA,2BAEA,gBACA,uBACA,UACA,uBACA,UACA,uBAEA,MACA,GACA,0BACA,yBACA,iBACA,eACA,eAAG,yBACH,gCACA,4BACA,2BACA,2BACA,CACA,CACA,+BACA,qBACA,gBACA,yBACA,aACA,UACA,kBACA,6BACA,CACA,4BACA,WAAiB,sBAA8B,OAC/C,2BAEA,iBACA,QACA,iBACA,mCACA,QAAiB,sBAA8B,OAC/C,8BAEA,2BACA,WACA,qBACA,+BACA,oCACA,iBACA,gCACA,cAAkB,sBAA8B,OAChD,aACA,oBAEA,iCACA,OACA,UACA,OAEA,IACA,kBACA,6BACA,CACA,8BACA,aACA,YACA,wBACA,YACA,IACA,qBACA,CACA,QACC,IACD,qECrIA,YACA,oBACA,iBACA,KACA,uCACE,iBACF,iDACA,iBACA,QACA,mBACA,YAEA,WAAG,uCACH,iBACA,qBACA,WACA,WAAG,kCACH,iBACA,qBACA,yBACA,MAEA,EA+EA,YACA,YACA,qBACA,QACA,8BACA,iEA3GA,IAwBA,wBACA,mBACA,MACA,gBAEA,YACA,4DACA,MACA,uBACA,CACA,WACA,kCACA,6DACA,QACA,qBACA,aACA,MACA,uBACA,0DACA,eACA,oBACA,aACA,UACA,qBACA,OACA,UAQA,2BAPA,WACG,+BACH,kBACG,sCACH,0CAEA,MAEA,wBACA,kCACA,iBACA,mBACA,gDACA,IACA,KACA,QACA,4BACA,4BAGA,QAAG,+BACH,iBACA,yCACA,6BACA,0BACA,EACA,CACA,wCACA,OACA,GAQA,2BAPA,WACG,uBACH,kBACG,sBACH,uBAEA,kCAEA,sBACA,aACA,IACA,wBACA,YACA,IACA,qBACA,CACA,QACC,IACD,2BACA,OAEA,wBAOA,wBACA,uBACA,iCACA,MACA,qBACA,aACA,KACA,wBACA,QACA,IACA,qBACA,CACA,QACC,IACD,wCACA,wBACA,SACA,uCACA,uBACA,6BACA,2CACA,qEC/HA,YACA,wBACA,oBACA,qBACA,wBACA,qBACA,EAA+B,mDAC/B,iBACA,YACA,OACA,EAkDA,YACA,WACA,eACA,qBACA,QACA,4EAlEA,KAYA,mBACA,wBACA,6BACA,aACA,WACA,+BACA,oCACA,iBACA,qBACA,aACA,MACA,iBACA,2BACA,wBAAoC,eACpC,eACA,oBACA,mCACA,kCAEA,MACA,0BACA,MACA,+BAA0C,aAC1C,sBAEA,aACA,iBACA,4BACA,sBACA,4BAA2C,aAC3C,uBACA,6BACA,mBAAyC,eACzC,kBACA,mBACA,YACA,0BAEA,0CAGA,KACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IAOD,mBACA,wBACA,mBACA,yBACA,8DACA,WACA,iBACA,sBACA,6BAAG,8CACH,UACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,uDCtFA,YACA,6BACA,kBACA,iBACA,KAA+B,mDAC/B,iBACA,QACA,QACA,8CATA,GAUA,wBACA,oBACA,aACA,MACA,iBACA,8BACA,MACA,+BACA,aACA,gBACA,+BACA,YACA,2CACA,MACA,oBACA,8BACA,SACA,sBACA,OACA,yCAEA,sBACA,OACA,wBACA,YACA,IACA,qBACA,CACA,QACC,IACD,qEC3CA,4BADA,GAEA,wBACA,yBACA,gCACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCCVD,4BADA,GAEA,wBACA,iCACA,oBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCCCD,YACA,cACA,eACA,eACA,yBACA,iBACA,eACA,UACA,8BACA,sBACA,uBACA,iBACA,iBACA,KAAE,8BACF,gCACA,QACA,WACA,QACA,wGAnBA,IAoBA,mBACA,wBACA,oBACA,aACA,MACA,6BACA,iBACA,oBACA,iBACA,sCACA,SACA,QACA,uBACA,aACA,WACA,2BACA,aACA,GACA,yBACA,MACA,aACA,qBACA,MACA,OACA,oBACA,sBACA,YACA,uCACA,gBACA,MACA,gBACA,SAAiB,aAAqB,OACtC,8BACA,UAEA,iCACA,QAEA,aAEA,SACA,QACA,0BACA,IACA,uDACA,GACG,6BACH,iBACA,eACA,MACA,CACA,mBACA,4BACA,cACA,0BAAiB,aAAqB,OACtC,iBACA,2CAEA,sCACA,YACA,uBACA,iBACA,SACA,wBACA,qBACA,YACA,oDAEA,GACA,qBACA,oDACA,GACA,mCACA,wBACA,CACA,0BACA,aACA,WACA,yBACA,iBACA,MACA,0BACA,4BACA,gCAAmC,EAAQ,KAC3C,wBAEA,eACA,GACA,iCACA,6CACA,YACA,IACA,wBACA,qBACA,cACA,eAAkB,aAAqB,OACvC,mCAEA,OACA,aACA,IACA,mCACA,iBACA,oBACA,QACA,yBACA,uBACA,YACA,SACA,cACA,IAEA,IACA,aACA,UACA,qBACA,UACA,iCACA,eACA,0BAAiB,aAAqB,OACtC,kBACA,4CAEA,8CACA,eACA,UACA,8BACA,mCACA,mBAAiB,aAAqB,OACtC,+BACA,QAGA,SACA,QACA,2BACA,MACA,aACA,oCACA,aACA,MACA,kCACA,WAAiB,MAA6B,qBAC9C,SAEA,wBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,qBACA,iFACA,gCACA,uEACA,KACA,mFACA,6EAEA,GAAE,+CACF,0CC5LA,YACA,eACA,gCACA,kBAsBA,0DA1BA,IAKA,wBACA,kBACA,aACA,IACA,0BACA,0BAEA,YACA,mBACA,aACA,IACA,qBACA,gEACA,GACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IAED,wBACA,sBACA,IACA,KACA,sBACA,oBACA,cACA,MACA,EACA,CACA,wBACA,QACA,IACA,qBACA,CACA,QACC,IACD,mFC5CA,KAKM,eAAwB,IAO5B,CAAY,cACV,OAAM,OAAO,OACX,OACA,sBACA,6BAAO,EAOT,YAAK,kBAAoB,GAAI,IAAG,YAAY,OAC1C,iBACA,oBAAc,EAAQ,cACtB,UAAQ,KACR,OAGF,gBAAK,kBAAkB,GAAG,SAAU,IAClC,MAAM,GAAQ,KAAK,kBAEnB,iBACE,MAAK,uBAAuB,EAC7B,WAFD,CAES,QACP,KAAK,SACL,iCACD,OACF,CACF,EAMD,CAAuB,yBACrB,MACD,kBAKD,WACE,MAAK,IAAI,eAAe,KACxB,wBACA,uBACD,UAKD,aACE,MACA,sBAAK,IAAI,kBAAkB,KAC3B,yBACD,YAGH,EAAe,kCCzEf,eACA,UACA,cACA,UAEA,4BACA,WACA,KAA6B,WAAU,SACvC,wBACA,cAA6B,WAAU,SACvC,sBACA,IACA,Q,gCCTA,0CADA,IAEA,wBACA,kBACA,IACA,sDACA,WACA,EAAI,uCACJ,WACA,EACG,+BACH,gCACA,EACA,CACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCCfD,YACA,eACA,oBACA,kBACA,uBACA,0BACA,iBACA,qBACA,mBAAE,8BACF,gCACA,QACA,yBACA,kBACA,SACA,EA+EA,YACA,YACA,iEAhGA,IAgBA,wBACA,oCACA,eACA,sBAEA,gCACA,oCACA,2CAEA,mBACA,6BACA,wBACA,+DACA,mEACA,kBACA,aACA,gCACA,eACA,sBAEA,qCACA,iCAEA,cAEA,+BAEA,kBACA,6DACA,eACA,+BACA,uBACA,kBACA,wCACA,UACA,0BACA,eAAiB,QAA8B,mBAC/C,QACA,gBACA,yDACA,uDAEA,4CAAwD,aAAc,WACtE,SACA,WACA,eACA,mBACA,yBAEA,SACA,YACA,oBACA,yBACA,yBACA,OACA,aACA,wBAEA,YACA,OACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,wBACA,yBACA,iBACA,SACA,kBACA,aAAE,yBACF,gCACA,SACA,oBACA,aACA,GAIA,wBACA,uBACA,CACA,QACA,qBACA,CACA,QACC,mBC9GD,aAMA,aAQA,CATA,MAUA,2BASA,EACA,2BAMA,EACA,4BAMA,EACA,8BAiBA,EACA,gEChDA,4BADA,IAEA,eASA,KACA,gECnBA,4BADA,GAEA,wBACA,uBACA,CACA,QACA,qBACA,CACA,QACC,kCCID,YAKA,MAEA,gCACA,4BAEA,kDAXA,KAYA,eAKA,KACA,gCACA,2BAA2C,SAAS,IACpD,cACA,UACA,mBAGA,SACA,QAKA,EACA,2BACA,SACA,YAGA,mCAA2C,SAAS,IACpD,cACA,UACA,mBAKA,4BAJA,QAOA,mBADA,UAMA,EACA,8BACA,aAA4B,aAC5B,sBAEA,QACA,QAKA,EACA,6BACA,UACA,IAKA,EACA,2BACA,oBACA,MAKA,EACA,8BACA,OACA,uBAKA,EACA,8BACA,QAEA,wBAA2C,OAAS,IACpD,gBAGA,WACA,QAKA,EACA,+BACA,cACA,KASA,EACA,iBAKA,MAKA,0BACA,CAKA,EACA,2BACA,mCACA,gBAEA,sCACA,YAKA,EACA,8BACA,uCAKA,OAKA,EACA,6BACA,UACA,kCCzKA,oBACA,wCACA,iECDA,4BADA,GAEA,wBACA,uBACA,CACA,QACA,qBACA,CACA,QACC,kCCND,0CADA,KAEA,wBACA,uBACA,CACA,QACA,qBACA,CACA,QACC,IACD,kCACA,SACA,sCACA,2CACA,iCACA,iCACA,iCACA,4DACA,UACA,yBACA,+BACA,8DACA,sCACA,sBACA,QAAE,kCACF,8DACA,aACA,iBACA,iBACA,iBACA,0CACA,sBACA,QACA,GACA,gCACA,uFACA,sFACA,QACA,8FACA,sFACA,QACA,8BACA,6FACA,gGACA,sFACA,QACA,8BACA,6FACA,wBACA,WACA,wCACA,OACA,wBACA,sBACA,KACA,WACA,IACA,cAEA,YAEA,GAAE,aACF,IACA,cAEA,YAEA,IACA,eAEA,kBACA,+BACA,QAEA,UACA,GACA,oBACA,YACA,OACA,EACA,GACA,sDCrEA,YAKA,WACA,2CAjBA,KAEA,oDAQA,QAQA,eAIA,KACA,2BACA,0BACA,IAIA,EACA,6BACA,CAEA,iBADA,UAKA,EACA,6BACA,YACA,iBACA,qBACA,UACA,cACA,WAEA,OACA,QAIA,EACA,+BACA,YACA,KAEA,0CADA,SAKA,EACA,2BACA,kBACA,sCC3DA,YACA,uBACA,wBACA,qBACA,QACA,+EANA,IAOA,wBACA,mCACA,aAAqC,eACrC,eACA,SACA,WAEA,SAGA,MACA,6BACA,cACA,SAAqC,aAAc,WACnD,SACA,0BACA,oBACA,MACA,CACA,QACA,8BACA,aAAwC,eACxC,kBACA,2BACA,YACA,yGACA,MACA,WAEA,CACA,uCACA,cACA,SAAwC,eACxC,kBACA,8BACA,GACA,+CACA,2BACA,aACA,WAKA,gBAJA,yBAEA,OAGA,QAGA,OACA,QACA,2BACA,2BAA2C,eAC3C,kBACA,0BAEA,SACA,QACA,mCACA,cACA,SAAoC,eACpC,kBACA,oCACA,iCACA,sBACA,oBACA,SACA,aAGA,CACA,QACA,iCACA,aAAwC,eACxC,eACA,SACA,YAGA,WACA,wBACA,iCACA,YACA,QACA,sCACA,aACA,oBACA,yCACA,KACA,OACA,SAAqC,aAAc,WACnD,SACA,WACA,oBACA,oDACA,0BACA,0DAEA,qBACA,eAGA,IACA,CACA,QACA,uBACA,WACA,IACA,SAAwC,eACxC,eACA,SACA,WACA,IAGA,KAEA,uBADA,6CAEA,gBACA,yBACA,iBACA,8BACA,WAAG,8BACH,gCACA,OACA,sCACA,8BACA,yCACA,6CACA,uCACA,aACA,CACA,wBACA,CACA,QACA,qBACA,CACA,QACC,oCCtJD,2CCMA,YACA,SACA,yBACA,OACA,qCACA,QACA,uDAPA,IAQA,wBACA,2BACA,uCACA,wCACA,cACA,qBAEA,yCACA,SACA,MACA,QACA,WACA,MAEA,yBACA,YAEA,sBACA,IACA,iEACA,0BACA,eACA,sBACA,qBAEA,WACA,MAEA,YACA,WAEA,gBACA,CACA,6BACA,iCACA,QACA,wBACA,mCACA,SACA,6BAEA,aACA,QACA,wBACA,aACA,iBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,8BACA,8DACA,gCACA,aACA,cACA,UACA,OAAiB,MAAiB,OAClC,SACA,qCACA,OACA,2CAEA,uBACA,aAAE,6DACF,gCACA,aACA,WAAiB,MAAiB,WAClC,OACA,WACA,QACA,2CACA,aACA,UACA,aACA,iCCjFA,YACA,eACA,0BACA,iBACA,kBACA,6BACA,iBACA,kBACA,iBACA,oBACA,2BACA,oCACA,QACA,wBACA,sBACA,wFAhBA,GAiBA,wBACA,uBACA,4BACA,6CACA,QAAiB,cAAsB,OACvC,mBAEA,wCACA,sDACA,iBACA,uBACA,OACA,mCACA,2BACA,MACA,cACA,KACA,OACA,2BACA,4HACA,6BACA,eACA,wBACA,eACA,2CACA,eACA,wBACA,aACA,UAAG,gBACH,SACA,0BACA,aACA,KACA,2BACA,kBACA,MACA,iCACA,qBACA,aACA,WACA,SACA,2CACA,mCACA,yBACA,UAAG,gBACH,+BACA,CACA,2BACA,SACA,sBACA,OACA,QACA,UAA2B,SAAoB,OAC/C,kBAEA,KAAG,KACH,gBACA,iBACA,UAA2B,KAAQ,KACnC,kBAEA,KACA,CACA,mBACA,aACA,OACA,wBACA,YACA,SACA,eACA,oBACG,yBACH,SACA,2BACA,YACA,oBACA,wCACA,gDACA,+BAAsC,eACtC,kBACA,0BAEA,SACA,QACA,qBACA,aACA,MACA,oBACA,OACA,mBACA,qBACA,aACA,MACA,qBACA,aACA,MACA,6BACA,oCACA,4BACA,cACA,qBACA,aACA,MACA,uBACA,yBACA,iBACA,qBACA,qBACA,EAAG,8BACH,gCACA,6BACA,6BACA,0CACA,wBACA,iBAEA,IACA,CACA,sBACA,MACA,6BACA,KACA,uBACA,0CACA,QAAiB,gBAAwB,OACzC,4BAEA,2CACA,mBACA,QACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCC/JD,YACA,gBACA,UACA,oBACA,mBACA,sBACA,cAA+B,mDAC/B,iBACA,QACA,QACA,uBAXA,GAYA,wBACA,uBACA,MACA,YACA,yBACA,MACA,aACA,sBACA,aACA,UACA,yBACA,aACA,aACA,sBACA,MACA,QACA,qBACA,aACA,MACA,wBACA,MACA,kBACA,gBACA,sBACA,8CACA,4BACA,YACA,uBACA,aACA,WACA,sBACA,aACA,UACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCC7CD,YACA,iBACA,UACA,oBACA,wBACA,gBACA,mBACA,oBACA,uBACA,UACA,oDACA,GAGA,YAFA,aACA,4DAEE,QACF,wBACA,iDACA,GACA,MACA,mFArBA,GAsBA,mBACA,wBACA,sBACA,aACA,QACA,sBACA,aACA,SACA,wBACA,MACA,YACA,iCACA,gCACA,yCACA,MACA,oBACA,aACA,KACA,wBACA,KACA,2FAEA,sBACA,WACA,+BACA,QACA,QAAiB,EAAO,IACxB,0HACA,WAGA,MACA,QACA,wBACA,MACA,UACA,mBACA,0BACA,8DACA,0CACA,+BACA,YACA,4BACA,MACA,cACA,uBACA,iDACA,iEACA,wEACA,gBACA,QACA,yBACA,MACA,WACA,2BACA,aACA,YACA,0BACA,kBACA,gBAEA,2BADA,KAEA,yBACA,MACA,aACA,mBACA,aACA,IACA,sBACA,aACA,UACA,oBACA,aACA,KACA,uBACA,MACA,iBACA,gCAA6C,oBAC7C,eACA,oBACA,MACA,MACA,4BACA,MACA,wBACA,aACA,6BACA,sBACA,oCACA,UACA,oBACA,aACA,cACA,SAEA,mBACA,WAFA,IAGA,wBACA,aACA,SACA,uBACA,aACA,WACA,qBACA,MACA,OACA,sBACA,aACA,UACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,2BACA,6CAAwF,8CACxF,EACA,iCCjJA,oCADA,GAEA,wBACA,uBACA,kBACA,KACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCCVD,YACA,cACA,gBACA,oCACA,QACA,eACA,qCAPA,IAQA,wBACA,mBACA,aACA,KACA,sBACA,aACA,OACA,wBACA,YACA,IACA,qBACA,CACA,QACC,kCCtBD,4BADA,GAEA,wBACA,sBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCCPD,0CADA,GAEA,wBACA,uBACA,CACA,QACA,qBACA,CACA,QACC,IACD,mBACA,iEACA,gCACA,mFACA,YACA,OACA,WACA,MACA,UAA6B,EAE7B,OAA6B,EAG7B,EACA,UAA6B,EAE7B,OAA6B,EAG7B,CAAE,2DACF,gCACA,eACA,UACA,8BACA,kEACA,WACA,iCCrCA,4BADA,GAEA,wBACA,2BACA,kBACA,2BACA,sBACA,qBACA,qBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCCbD,YACA,WACA,iBACA,eACA,eACA,mBACA,cACA,kEACA,QACA,YACA,cACA,YACA,gCAbA,IAcA,wBACA,6BACA,WACA,yBACA,EACA,iCACA,YACA,eACA,WACA,uBACA,QAEA,iCACA,oBACA,GACA,UAEA,uBACA,UAEA,sBACA,2BACA,+CACA,QACA,SAA2B,eAAgB,KAC3C,gBAEA,QACA,QACA,4BACA,yBACA,gCACA,2DACA,OAAG,8BACH,4FACA,cACA,wBACA,YAEA,wCACA,oBACA,aACA,GACA,gBACA,uCAEA,8BACA,gBACA,uCAEA,6BACA,CACA,mBACA,MACA,KACA,sBACA,uCACA,OACA,wBACA,qBACA,sBACA,yBACA,mBACA,SACA,aACA,IACA,8BACA,6DACA,QACA,wBACA,aACA,IACA,0BACA,aACA,MACA,uBACA,aACA,QACA,kBACA,aACA,GACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCCpGD,mCADA,IAEA,wBACA,uBACA,CACA,QACA,qBACA,CACA,QACC,IACD,uBACA,OACA,UACA,uBACA,gBACA,4BACA,WACA,UACA,kBACA,yBACA,iBACA,kBACA,EAAE,yBACF,gCACA,eACA,UACA,QACA,OACA,GACA,yBACA,aACA,UACA,UACA,UACA,QAEA,OADA,KAEA,0BACA,aACA,UACA,UACA,UACA,QAEA,OADA,KAEA,+BACA,SACA,eACA,oBACA,MACA,+BACA,QACA,gBACA,6BACA,IAAE,KACF,4BACA,iBACA,IACA,CACA,UACA,8BACA,SACA,eACA,oBACA,WACA,oBACA,OACA,KASA,SARA,IAEA,IAEA,IACA,QAEA,UAEA,uBACA,YACA,KACA,uBACA,SACA,WACA,OAEA,iBACA,MAEA,YACA,MACA,sCACA,SACA,eACA,aACA,qBACA,mBAEA,cACA,iBACA,gBACA,gBACA,wCACA,0BACA,mDCnGA,YACA,WACA,mDAHA,IAIA,mBACA,wBACA,uBACA,qBACA,OACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCClBD,4BADA,GAEA,wBACA,mBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCCND,YACA,cACA,mBACA,eACA,iBACA,iCACA,qBACA,QACA,eACA,wBACA,cACA,wDAZA,IAaA,wBACA,gBACA,SACA,qBACA,2CACA,cAEA,8CACA,gCACA,6CAEA,mCAEA,IACA,sBACA,cAEA,0CACA,6BACA,kCACA,qCAGA,SACA,mBACA,yDACA,UACA,oBACA,SACA,SAEA,+CACA,gCACA,UAEA,qCACA,IACA,2BAIA,KACA,wBACA,QACA,IACA,qBACA,CACA,QACC,IACD,sBACA,qBACA,qCC/DA,YACA,gBACA,qBACA,0CAJA,IAKA,wBACA,kBACA,SACA,gCAAiB,kBAAwB,WACzC,eACA,oBACA,aACA,iBACA,mBAAkB,MAAgB,OAClC,iBACA,6BAEA,aACA,IACA,SACA,MACA,oBACA,aAAmC,aACnC,sBAEA,OACA,2BACA,WAAiB,gBAAwB,OACzC,oCAEA,gBACA,CACA,qBACA,oBACA,UACA,qBACA,aACA,MACA,iBACA,oBACA,MACA,2BACA,iBACA,iCACA,OACA,QACA,iBACA,aACA,uBACA,+BACA,QACA,wBACA,CACA,QACA,qBACA,CACA,QACC,iBC5DD,UAAqC,u/JCIrC,YACA,sBACA,qCACA,cACA,gBACA,2CANA,IAOA,wBACA,8BACA,OACA,KACA,OACA,QACA,0CAEA,MACA,IAAG,SACH,gBACA,KACI,QACJ,QAAG,SACH,IACA,MACA,0CACA,KAAI,SACJ,gBACA,KACK,YACL,QAAI,SAEJ,CACA,QACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,2BACA,OACA,oBACA,sBACA,qBACA,4BACA,QACA,4BACA,4BACA,eACA,6BACA,4BACA,gBACA,0BACA,4BACA,2CC7CA,YACA,2BACA,iCACA,yBACA,KAA+B,mDAC/B,iBACA,6BACA,8BACA,eACA,sGAVA,IAWA,wBACA,kCACA,mEAEA,sBADA,QAEA,0BACA,+BACA,QACA,gCACA,yBACA,iCACA,gBACA,+BACA,gBACA,mCAEA,gCACA,kCACG,6CACH,kCACG,0CACH,YACA,OAAkB,QAA2B,mBAC7C,QACA,6CAEG,6CACH,YACA,OAAkB,QAA8B,mBAChD,QACA,6CAEG,0CACH,kBACA,YACA,eACA,mBAGA,oBACA,6BACA,SACA,yCACA,aACA,QACA,kCACA,sDACA,iBACA,iCACA,6EACA,SAGA,aACA,kBAEA,aACA,QACA,+BACA,2BACA,iBACA,yBACA,wDACA,wCACA,mBAAiB,MAA+B,yBAChD,SACA,2BACA,wDACA,wCACA,QACA,YACA,QACA,sBACA,wBACA,qBACA,UACG,oCACH,UAEA,2BACA,6BACA,OACA,8EACA,+CACA,aACA,SACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCCjHD,YACA,MACA,yBACA,mBACA,oDACA,cACA,yBACA,0BACA,8BACA,4BACA,gBACA,iBACA,UACA,gBACA,sEACA,QACA,WACA,sBACA,gCAnBA,GAoBA,wBACA,wCACA,IACA,yCACA,8BACA,yBACA,wBACA,0BACA,MAEA,QACA,CAEA,CACA,QACA,uCACA,aACA,wBACA,kCACA,MACA,sBACA,0CACA,aACA,kBACA,uCACA,aAAmC,aAAa,WAChD,SACA,WACA,uCACA,QACA,CACA,QACA,kCACA,aACA,UACA,4BACA,aACA,gBACA,mBACA,aACA,OACA,+BACA,OACA,+CACA,wCAEA,IACA,gCACA,0BACA,qBACA,oBACA,IACA,oCACA,uBACA,WACA,mBACA,2CACA,OACA,2CACA,YACA,sCACA,yBACA,oBACA,kBAEA,sBACA,0BACA,sCACA,oDACA,4CACA,iCAEA,aACA,uEACA,YACA,mBACA,4BAEA,kEAIA,yBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,kCACA,OACA,8NC/GA,yCCCA,KAwIe,IApIT,KAQJ,CAAiB,gBAKf,MAMA,WAAK,SAAW,GAAI,IAMpB,gBAAK,eAAiB,GAAI,IAM1B,gBAAK,QAOL,WAAK,YAEL,KACE,WADE,QAAO,MAAK,QAAQ,mBACjB,QAGP,gBAAI,KAAK,QACP,mBAAK,QAAU,GAAI,KAAQ,KAAK,IAAK,KAExC,UAMD,CAAW,aACT,GAAQ,OAAO,KACf,OAAQ,UACR,WAAK,SACN,OAMD,CAAY,cACV,MAAM,GAAQ,YAAoB,IAAgB,aAC9C,GAAI,IAER,kBAAK,GAAI,GAAI,EAAG,EAAI,EAAM,YAAa,GACrC,OAAK,WAAW,EAEnB,QAKD,SACE,MAAK,SAAS,QAAS,KACrB,GACD,YAED,QAAK,QACN,SAMD,oBACE,OAAO,MACR,cASD,CAAe,iBACb,MACD,aAMD,iBACE,OAAO,MACR,WAOD,CAAkB,oBAEhB,IAAI,EAAK,aAAe,EACtB,eAAK,GAAI,GAAI,EAAG,EAAI,KAAK,SAAS,YAAa,GAC7C,EAAK,KAAK,SAAqB,aAC5B,KAAK,SAAc,QACpB,iBAAK,SAAc,QAKzB,kBAAM,GAAQ,KAAK,SAAS,WAAW,OAAO,KAAK,EACnD,kBAAK,eACL,aAAK,eACN,SAGH,kDCxIA,KAKM,eAAgB,IAAG,QAAQ,OAO/B,CAAiB,gBACf,MAAM,GAAU,SAAS,cACzB,SAAQ,aAAa,KAErB,qBACE,CAOF,iBAMA,gBAEA,WAAK,IAAI,mBAAmB,YAAY,KACxC,cACA,YAAK,SAAS,GAAG,gBAAiB,KAAK,KACxC,KAMD,OACE,KAAK,GAAI,GAAI,EAAG,EAAI,KAAK,SAAS,YAAa,GAAK,EAClD,MAAM,GAAM,KAAK,SAAc,QAC/B,kBAAK,QACN,cACF,CAMD,UACE,KAAK,GAAI,GAAI,EAAG,EAAI,KAAK,SAAS,YAAa,GAAK,EAClD,MAAM,GAAM,KAAK,SAAc,QAC/B,kBAAK,QACN,cACF,CAGH,EAAe,uBC7Df,QAEA,0CAEA,GAKe,YAAf,EAEA,cACA,EAEA,oBAEA,iCA2BA,4BC5CA,cAIA,SACA,YAAgzC,2xCAEhzC,iBCHA,CA6CA,eACA,aACA,OACA,MACA,GAGA,uCACA,OACA,gCACA,uCACA,KAEA,wCACA,KAEA,gBACA,KAEA,CACA,aAEA,6CACA,8BAEA,kEACA,MAtEA,qBACA,IAGA,MAsCA,4BArCA,4BACA,OACA,gBACA,kBAAmC,MAInC,KAAG,QACH,GAGA,mBACA,CACA,gCACA,aACA,QAAgB,WAAiB,OACjC,cACA,GACA,qBAEA,eAAY,MAAoB,WAChC,OAKA,gCACA,YACA,KAEA,mCAEA,OAEA,QACA,CACA,qBC3CA,CAiHA,eACA,WAAgB,MAAmB,WACnC,OACA,WAEA,SACA,GAEA,iBAAiB,YAA2B,OAC5C,iBAGA,UAAQ,eAAuB,OAC/B,qBAEA,YAAG,KACH,QAEA,QAAiB,YAAuB,OACxC,eAGA,sBAA2B,eAC3B,QACA,CACA,EAEA,eACA,QACA,MAEA,OAAgB,MAAiB,WACjC,OACA,4BACA,OACA,OACA,OACA,MAAc,cAEd,6BAEA,qBAFkD,WAClD,KAGA,CACA,SAEA,eACA,WAEA,eACA,mBAGA,mIAEA,MAEA,uBAEA,+BAEA,eAEA,kCALG,cAMD,gBACF,wBACE,sEACF,qCACA,UACA,iBACA,sBAEA,sMAEA,aACA,wBACA,sBAEA,uBACA,WACA,iBAEA,GAEA,aACA,8BAEA,SAMA,oBAJA,iBACA,OAEA,SAGA,aACA,8BAEA,QAOA,oBANA,uBAEA,mBACA,OAEA,SAGA,eACA,mCACA,kBACA,KACA,GAEA,eACA,WAGA,oBACA,IAKA,mBAHA,SAOA,4BAEA,CAIA,iBACA,OAEA,YAEA,eACA,sBAEA,YACA,QACA,WACA,wBACA,wCACA,wCACA,yBAEA,2BACA,cACA,sBACA,CAEA,mCACA,KAEA,MACA,cACA,oBACA,CACA,IAGA,SAEA,iBACA,MACA,CACA,aACA,iBACA,uBAEA,UAGA,SACA,IACA,KAEA,IACA,EAYA,mBACA,cAEA,SACA,gCACE,WACF,gBACA,sBAEA,+BAEA,QACA,wBAEA,QAEA,cACA,EAEA,eACA,SACA,QAGA,2BAGA,aACA,wBACE,cACF,QACA,4BAGA,mCACA,kBACA,EAEA,iBACA,SACA,QAQA,cAEA,qCACA,8BAKA,aAAuD,6GAGvD,0BAA6B,MAE7B,iBAEA,gBAEA,0BACA,mBAlXA,GAEA,mBACA,IAEA,oBACA,CAEA,6CADA,aAEA,CAEA,YAMA,gDACA,IAEA,gBACA,iBACA,gBAEA,cACA,IAEA,wBAMA,IACA,2BAEA,iCACA,cAEA,yDACA,qBAGA,qBACA,IAAK,SACL,GACA,IAEA,CACA,MACA,OACA,KACA,CAEA,MACA,OACA,EAEA,cAEA,uBACA,+BACA,iDAGA,kEAEA,yCAIA,kEAGA,iCAGA,gCAEA,gBAEA,aAEA,mBACA,QAEA,QAAiB,MAAmB,WACpC,OACA,WAEA,MACA,SACA,OAEA,MACA,OACA,OACA,MAEA,WAAiB,QAAsB,OACvC,SAEA,gBACA,WAAmB,YAA2B,aAE9C,sBACA,GAEA,CACA,GAyLA,gBACA,IAEA,0BACA,OAEA,+BACA,KACA,CAAC,gBCvSD,CAEA,qBAEA,0CAEA,YACA,mBAIA,2CACA,mBAGA,iCACA,wCA4BA,oFAEA,OACA,EACA,uCAAwC,CAAW,QACnD,mCAAwC,CAAW,QAGnD,0DACA,QAIA,YAEA,YAGG,sBAEH,mBAGA,wBAIA,6BACA,GAGA,GACA,4mBC9EA,0DCPA,KAKM,eAAmB,KAcX,qBACJ,OAAO,OACX,OACA,wBACA,wBAAO,EAOT,YAAK,YAAc,EAOnB,iBAAK,mBAAqB,GAAI,IAAG,YAAY,QAC3C,iBAAiB,KAAK,OAAO,KAQ/B,aAAK,UAAY,GAAI,IAAG,MAAM,OAC5B,QAAQ,GAAI,IAAG,OACf,aAAO,CACL,GAAI,IAAG,MAAM,MACX,OAAO,GAAI,IAAG,MAAM,aAClB,MAAM,GAAI,IAAG,MAAM,KACjB,OAEF,mBAAQ,GAAI,IAAG,MAAM,OACnB,OACA,QAEF,mBACA,SACA,UACA,QAAY,EAEd,WAAQ,GAAI,IAAG,MAAM,OACnB,OACA,EACA,sBAYR,sBAAK,WAAa,GAAI,IAAG,MAAM,OAC7B,QAAQ,GAAI,IAAG,OACf,aAAO,CACL,GAAI,IAAG,MAAM,MACX,QAAQ,GAAI,IAAG,MAAM,OACnB,OACA,EACA,sBAWR,sBAAK,cAAgB,EAAQ,eAO7B,QAAK,gBAAkB,GAAI,IAAG,YAAY,KACxC,gBAAgB,KAChB,qBAAQ,KAAK,UAQf,mBAAK,eAAiB,EAOtB,oBAAK,cAAgB,EAAQ,eAO7B,QAAK,cAAgB,EAErB,cACE,WADE,QAAK,qBAQT,uBAAM,GAAY,KAAK,YAAc,YACrC,UAAK;;;;;;YAMG,KAAK,cAAgB,UAAe;;;;;;;;;YASpC,KAAK,eAAiB,UAAe,EAEM;;6CAjB5B;qDAkB0B,KAAmB,aAIpE;;KA5IA,MA6ID,aAKD,CAAO,SACL,OACA,eAAK,IAAI,SAAS,KAClB,gBAAK,IAAI,SAAS,KAIlB,iBAAK,IAAI,kBAAkB,GAAG,gBAAkB,KAC9C,MAAM,GAAM,EAAE,OAAO,WAAW,QAAQ,KAExC,iBAAI,KAAK,QAAgB,CAAC,CAAP,IAAY,IAAQ,EAAE,OAAO,YAC9C,SACA,kBAEH,WACF,EAOD,CAAO,SACL,MAAM,GAAW,KAAK,mBAAmB,EAAI,WAG7C,GAAM,EAAc,KAAK,OACzB,iBAAI,GAA+C,CACjD,CADiB,GAAiB,cACzB,OAAO,EAAiB,WAGnC,QAAK,WAAW,YAChB,aAAK,UAAU,YAEf,QAAI,KACF,oBAAmB,gBAAU,EAG/B,YAAI,KAAK,gBAAkB,EACzB,aAAK,eAAe,EAAI,WAAY,EAEvC,GAUD,CAA+B,uBAC7B,CAAM,KACA,GAAM,CAAC,CAAC,SAAU,CAAC,SAAU,SACnC,UAEA,UAAK,OAA8B,yBAAM,KACvC,MAAM,GAAS,EAAE,cACjB,mBAAM,EAAK,EAAO,GAAK,EACvB,GAAM,EAAK,EAAO,GAAK,EACjB,GAEP,EAFoB,IACnB,MAGF,QAAM,GAAQ,OACd,QACA,KAAM,EAAa,EAAI,EAEvB,OAhBY,GACZ,KAeM,KAAS,OAEf,SAAK,GAAI,GAAI,EAAO,IAAO,GACzB,IAAS,KAAK,EAGhB,OACD,QASD,CAAwB,kBACtB,IAEA,UAAK,GAAI,GAAI,EAAG,EAAI,EAAS,OAAQ,GAAK,EACxC,MAAM,GAAgB,KACtB,cAAM,EAAe,EAErB,oBAAI,YAAgB,IAAG,KACrB,QACD,YAEC,IAAI,YAAgB,IAAG,KACrB,eAAK,GAAI,GAAI,EAAG,EAAI,EAAa,OAAQ,GACvC,IAAU,KAEb,UAAM,IAAI,YAAgB,IAAG,KAC5B,YAAK,GAAI,GAAI,EAAG,EAAI,EAAa,GAAG,OAAQ,GAC1C,IAAU,KAAK,EAKnB,YAAM,GAAS,GAAG,KAAK,QAAQ,WAAW,EAAK,aAC5C,iBACH,KAAY,EACb,SACF,CAED,MAAM,GAAK,KAAK,IAChB,6BAAI,GAEJ,SAAK,GAAI,GAAI,EAAG,EAAI,EAAU,OAAQ,GAAK,EACzC,MAAM,GAAM,KACZ,cAAM,EAAQ,KAAK,IAAI,uBACvB,MAAM,EAAa,EAAG,GAAK,EAAM,GAAM,KAAK,cAAgB,GACzD,EAAG,GAAK,EAAM,GAAM,KAAK,cAC5B,EAAM,EAAa,EAAG,GAAK,EAAM,GAAM,KAAK,cAAgB,GACzD,EAAG,GAAK,EAAM,GAAM,KAAK,cAE5B,EAAI,KACF,IAAI,GAAO,EACX,MAAS,EAAG,GAAK,EAAM,GAAa,CAAN,IAC9B,CADwC,QAClC,GAAQ,KAAK,IAAI,uBAAuB,CAAC,EAC/C,SAAa,CAAC,CAAW,KAAG,GAAI,EAAM,IACvC,KALD,KAKW,MACT,IAAI,GAAO,EACX,MAAS,EAAG,GAAK,EAAM,GAAa,CAAN,IAC9B,CADwC,QAClC,GAAQ,KAAK,IAAI,uBAAwB,GAAM,EACrD,OAAa,CAAC,CAAC,EAAM,GAAc,KAAG,IACvC,KAED,CAAI,KACF,MAAM,GAAI,GAAI,IAAG,KACjB,mBAAK,UAAU,YAAY,WAAW,GAAI,IAC3C,WACF,CAED,IAAI,GACJ,KAAI,EACJ,UAAM,GAAe,KAAK,UAAU,YAEpC,iBAAI,EAAa,OACf,GAAa,QAAS,KACpB,MAAM,GAAe,EAAQ,cAC7B,iBAAM,EAAK,EAAa,GACxB,GAAM,EAAK,EAAa,GACxB,GAAM,EAAK,EAAa,GACxB,GAAM,EAAK,EAAa,GAExB,GACE,QAEF,KACE,QAEH,IAED,QAEA,SAAiB,KACf,GACA,UACA,aAAK,WAAW,YAEhB,oBAAK,UAAU,YACf,aAAM,GAAW,GAAI,IAAG,KACxB,cAAK,UAAU,YAAY,WAAW,GAAI,IAC3C,WACF,CACF,CAQD,CAA2B,mBACzB,MAAM,GAAY,EAAQ,cAE1B,mBAAM,EAAK,KAAK,IAChB,6BAEA,SAAI,KACF,cAAa,CACX,CAAC,EAAU,GAAK,KAAK,cAAe,EAAU,IAC9C,CAAC,EAAU,GAAK,KAAK,cAAe,EAAU,IAC9C,CAAC,EAAU,GAAI,EAAU,GAAK,KAAK,eACnC,CAAC,EAAU,GAAI,EAAU,GAAK,KAEjC,oBACC,MAAM,GAAS,CACb,CAAC,EAAG,GAAK,KAAK,cAAe,EAAG,IAChC,CAAC,EAAG,GAAK,KAAK,cAAe,EAAG,IAChC,CAAC,EAAG,GAAI,EAAG,GAAK,KAAK,eACrB,CAAC,EAAG,GAAI,EAAG,GAAK,KAGlB,oBAAK,GAAI,GAAI,EAAG,EAAI,EAAO,OAAQ,GACjC,IAAW,KAAK,KAAK,IAAI,uBAE5B,MAED,MAAM,GAAW,GAAI,IAAG,KACxB,mBAAK,UAAU,YAAY,WAAW,GAAI,IAC3C,WAKD,WACE,OACA,gBAAK,IAAI,eAAe,KACxB,yBAAK,IAAI,eAAe,KAExB,0BAAS,eAAe,UAAU,iBAAiB,SAAW,KAC5D,MAAK,cAAgB,EAAI,OACzB,aAAK,eAAiB,CAAC,KACxB,aAED,YAAS,eAAe,WAAW,iBAAiB,SAAW,KAC7D,MAAK,eAAiB,EAAI,OAC1B,aAAK,cAAgB,CAAC,KACvB,cAED,YAAS,eAAe,eAAe,iBAAiB,QAAU,KAChE,CAAI,WAAW,EAAI,OACjB,cAAK,cAAgB,WAAW,EAAI,OAEvC,OACF,EAKD,aACE,OACA,kBAAK,IAAI,kBAAkB,KAC3B,yBAAK,IAAI,kBAAkB,KAC5B,gBAGH,CAzYE,CAyYa,mBC/Zf,UAAqC,ssOCIrC,KAKM,eAAsB,IAK1B,CAAY,cACV,OAAM,OAAO,OACX,OACA,mBACA,oBAAO,EAOT,YAAK,mBAAqB,GAAI,IAAG,YAAY,QAC3C,iBAAiB,KAAK,OAAO,KAC7B,sBAAiB,KAAK,OAAO,KAC7B,oBAAe,KAAK,KAAK,KAO3B,aAAK,gBAAkB,EAAQ,iBAO/B,oBAAK,YAAc,GAAI,IAAG,MAAM,OAC9B,QAAQ,GAAI,IAAG,OACf,aAAQ,KACN,MAAM,GAAW,EAAE,IAAI,KACvB,uBAAO,CACL,GAAI,IAAG,MAAM,MACX,UAAU,GAAI,IAAG,KAAK,MAAM,KAC5B,cAAO,GAAI,IAAG,MAAM,KAClB,CACA,eAAK,EAIZ,MAEJ,GAOD,CAAO,SACL,aACA,iBAAK,QAAU,KAAK,IAAI,sBAAsB,EAAI,MAChD,KAA2C,CAI3C,CAJI,MAAK,OAAO,cAAsB,aAOxC,MAAI,KAAK,QAAU,KACjB,eAAK,QAAQ,IACX,KAAK,gBACL,KAAK,QAAQ,IAAI,KAAK,kBAIxB,QAAK,gBACE,EACH,EAAI,WAAW,GAAK,KAAK,OAAO,GAChC,EAAI,WAAW,GAAK,KAAK,OAAO,IAC9B,KAAK,QAAQ,IAAI,KAGzB,oBAAI,KAKL,OAOD,CAAO,SACL,SAEA,YAAI,KAAK,SAAW,KAAK,OACvB,MAAM,GAAgB,EACpB,EAAI,WAAW,GAAK,KAAK,OAAO,GAChC,EAAI,WAAW,GAAK,KAAK,OAG3B,IAAM,EAAe,KACrB,kBAAM,EAAe,EAAe,KAAK,QAAQ,IAAI,KAErD,sBAAK,QAAQ,cAAc,OAAQ,GAAc,KACjD,aAAK,cAAc,cAAc,OAAQ,GAAc,KAEvD,aAAK,QAAQ,IAAI,KACjB,wBAAK,cAAc,IAAI,KACxB,kBACF,CAOD,CAAK,OACC,CAAC,KACH,WAAI,KACF,cAAK,cAAgB,KACrB,aAAK,OAAS,EACd,gBAAK,YAAY,YACjB,aAAK,YAAY,YAAY,WAAW,KAExC,qBAAK,YAAY,YAGtB,QAKD,WACE,MAAK,IAAI,eAAe,KACxB,yBAAK,IAAI,SAAS,KAClB,mBACD,UAKD,aACE,MAAK,YAAY,YACjB,aAAK,IAAI,YAAY,KACrB,kBAAK,IAAI,kBAAkB,KAC3B,0BACD,YAGH,EAAe,mBC9Jf,UAAqC,kgKCArC,UAAqC,w1KCKrC,KAKM,eAAoB,IAOxB,CAAY,cACV,IAAI,GAEJ,YAAQ,EACN,UACE,YAAQ,EACR,EACF,UACE,eAAQ,EACR,EACF,MACE,UAAQ,EAGZ,SAAM,OAAO,OACX,CAAQ,cAAQ,EAAQ,MAAiB,OACzC,aACA,mBAOF,kBAAK,gBAAkB,GAAI,IAAG,YAAY,KACxC,MAAM,EAAQ,MACd,iBAAU,EACV,gBAAQ,EAEX,QAKD,WACE,MAAK,IAAI,eAAe,KACxB,uBACD,UAKD,aACE,MAAK,IAAI,kBAAkB,KAC3B,uBACD,YAGH,EAAe,mBCjEf,UAAqC,smICArC,UAAqC,s3ICArC,UAAqC,4mKCGrC,KAKM,eAAoB,IAKxB,CAAY,cACV,OAAM,OAAO,OACX,OACA,4BACA,oBAOF,YAAK,WAML,UAAK,OACL,eAAK,eAML,UAAK,QAML,UAAK,mBAAqB,GAAI,IAAG,YAAY,QAC3C,iBAAiB,KAAK,gBAAgB,KACtC,sBAAiB,KAAK,gBAAgB,KACtC,sBAAiB,KAAK,gBAAgB,KACtC,oBAAe,KAAK,cAAc,KAErC,OAOD,CAAgB,kBACd,MAAM,GAAU,EAAI,IAAI,sBAAsB,EAAI,MAChD,KAA2C,CAG3C,CAHI,MAAK,OAAO,cAAsB,aAOtC,uBACO,WADH,EAAQ,uBAAyB,IAAG,KACtC,MAAkB,GAAG,OAAO,UAAU,EACnC,cAEE,aAAa,EAGpB,gBACA,eAAK,OAKR,qBAOD,CAAgB,kBACd,MAAM,GAAS,EAAI,WAAW,GAAK,KAAK,WACxC,GAAM,EAAS,EAAI,WAAW,GAAK,KAAK,WAExC,QAAK,QAAQ,cACb,oBAAK,WAAa,EACnB,UAOD,CAAgB,kBACd,IAAI,KAAK,OACP,MAAM,GAAU,EAAI,IACpB,mBAAM,EAAU,EAAI,IAAI,sBAAsB,EAAI,MAGhD,UAAI,EAAQ,MAAM,SAAW,KAC3B,cAAK,eAAiB,EAAQ,MAC9B,SAAQ,MAAM,OAAS,KAEpB,QACL,IADS,QAAK,mBACN,MAAM,OAAS,KACvB,oBAAK,eAER,KACF,CAOD,gBACE,CAID,YAJM,WACL,UAAK,QACL,UAAK,OAAO,eACZ,QAMF,WACE,MAAK,IAAI,eAAe,KACxB,0BACD,UAKD,aACE,MAAK,IAAI,kBAAkB,KAC3B,0BACD,YAGH,EAAe,mBChJf,UAAqC,omQCGrC,KAKM,eAAsB,IAS1B,CAAY,cACV,OAAM,OAAO,OACX,OACA,4BACA,6BAOF,YAAK,kBAAoB,GAAI,IAAG,YAAY,OAC1C,QAAQ,KACR,gBAAU,KAOZ,gBAAK,kBAAoB,GAAI,IAAG,YAAY,OAC1C,UAAU,KAAK,kBAElB,eAKD,WACE,MAAK,IAAI,eAAe,KACxB,wBAAK,IAAI,eAAe,KACxB,yBACD,UAKD,aACE,MAAK,IAAI,kBAAkB,KAC3B,wBAAK,IAAI,kBAAkB,KAC3B,yBACD,YAGH,EAAe,mBC7Df,UAAqC,4tMCGrC,KAKM,eAAsB,IAQ1B,CAAY,cACV,OAAM,OAAO,OACX,OACA,4BACA,2BAAO,EAOT,YAAK,kBAAoB,GAAI,IAAG,YAAY,OAC1C,QAAQ,KACR,aAAO,EAOT,iBAAK,kBAAkB,GAAG,SAAW,KACnC,GAAI,SAAS,QAAS,KACpB,MAAK,OACL,sBAAK,kBAAkB,cACxB,OACF,EACF,EAKD,WACE,MAAK,IAAI,eAAe,KACxB,yBACD,UAKD,aACE,MAAK,IAAI,kBAAkB,KAC3B,yBACD,YAGH,EAAe,mBC7Df,UAAqC,qrSCKrC,KAKM,eAAsB,KASd,cACV,OAAM,OAAO,OACX,OACA,4BACA,2BAAO,EAOT,YAAK,kBAAoB,GAAI,IAAG,YAAY,OAC1C,QAAQ,KACR,oBAAc,EAAQ,cACtB,WAAgD,WAAzC,QAAQ,GAAQ,QAAgC,EAGzD,aAAuB,eAIxB;;;KAMD,CAAO,SACL,MAAM,GAAS,GACf,KAAM,EAAW,KAAK,kBAAkB,cACxC,eAAK,GAAI,GAAI,EAAG,EAAI,EAAS,OAAQ,GAAK,EACxC,MAAM,GAAW,EAAO,KAAc,KACtC,eAAM,EAAK,GACX,QAAM,EAAW,EACjB,qBAAS,KAAG,YAAY,EACzB,SACF,CAKD,WACE,MAAK,IAAI,eAAe,KACxB,yBAEA,oBAAS,eAAe,cAAc,iBAAiB,QAAS,IAC9D,MAAM,GAAQ,SAAS,eACvB,gBAAM,EAAQ,SAAS,EAAM,MAG3B,YAEH,SACF,EAKD,aACE,MAAK,IAAI,kBAAkB,KAC3B,yBACD,YAGH,CAhEE,CAgEa,oCClFf,4BADA,GAEA,wBACA,uBACA,CACA,QACA,qBACA,CACA,QACC,IACD,qCACA,UACA,uCCTA,YACA,IACA,8BACE,mCACF,iBACA,YACA,OACA,+BARA,GASA,mBACA,wBACA,uBACA,CACA,QACA,qBACA,CACA,QACC,mBCnBD,aAMA,aACA,iBACA,GAHA,MAIA,eAIA,OACA,2ECLA,4BADA,IAEA,kDCDA,4BADA,IAEA,kDCRA,mCADA,GAEA,wBACA,uBACA,CACA,QACA,qBACA,CACA,QACC,IACD,oBACA,SACA,eACA,YACA,UACA,qBACA,iBACA,MACA,IAAgB,EAAO,QACvB,GACA,2BACA,MACA,IACA,MACA,aACA,KACA,IACA,GACA,CACA,wCCpBA,sGADA,KAEA,wBACA,uBACA,CACA,QACA,qBACA,CACA,QACC,IACD,qBACA,yBACA,QAAgB,EAAO,IACvB,IAEA,iBACA,YACA,0BACA,yBACA,iBACA,YACA,UACA,iBACA,qBACA,UAAE,yBACF,gCACA,aACA,eACA,uBACA,UAAiB,EAAW,IAC5B,OACA,mBACA,OAAI,SACJ,gBACA,SACK,2BACL,QAAI,SAEJ,CACA,QACA,GACA,qBACA,aACA,YACA,OACA,SACA,iBACA,mBACA,OACA,qBACA,SACA,UACA,eACA,sCACA,QAAgB,MAAgB,OAChC,WAEA,OACA,UACA,qBACA,wDACA,iBACA,mCACA,SACA,GACA,oBACA,gBACA,QACA,4CACA,wEC9EA,6CCAA,6CCAA,6CCAA,6CCAA,6CCAA,2CCIA,iDADA,IAEA,wBACA,uBACA,CACA,QACA,qBACA,CACA,QACC,IACD,mBACA,iCACA,iBACA,cACA,gBAAE,kCACF,iBACA,cACA,gBACA,GACA,yBACA,iCACA,iBACA,iBACA,gBACA,YACA,IAAiB,aAAqB,MACtC,YACA,aACA,WACA,QACA,IACA,OACA,IAAE,kCACF,iBACA,WACA,cACA,kBACA,UACA,UACA,qBACA,qBACA,aACA,IACA,YACA,OAAiB,MAAW,EAC5B,UACA,QACA,QACA,oBACA,OACA,mBAEA,SACA,IACA,iCCjDA,YACA,SACA,WACA,MACA,0BACE,gBACF,uDACA,iBACA,QACA,OAAG,kCACH,iBACA,QACA,OAAG,uCACH,iBACA,iBACA,SACE,+BACF,gCACA,QACA,SACA,sEArBA,IAsBA,wBACA,eACA,sDACA,GACA,wCACA,YACA,sBACA,aACA,WACA,iBACA,mBACA,QACG,UACH,sBACA,QAEA,eACA,OACA,0BACA,IAAiB,EAAgB,SACjC,IACA,gBAEA,eACA,aACA,IACA,IAEA,SACA,QACA,EACA,KACA,OAEA,OAEA,QACA,gDACA,oBACA,QACA,sBACA,yBACA,SACA,KACA,UACA,OACA,UACA,gBACA,sBACA,KACA,wBACA,sBACA,GACA,qBACA,6BACA,iBACA,qBACA,SAAG,kCACH,iBACA,mBACA,GACA,CACA,mBACA,mDACA,iBACA,yCACA,GACA,CACA,mBACA,+BACA,GACA,yBACA,6BACA,iBACA,uBACA,4BACA,IAAG,kCACH,iBACA,uBACA,kBACA,KACA,CACA,mCACA,sBACA,mBACA,OACA,IACA,iBACA,aACA,MAIA,MACA,uBACA,yBACA,6BACA,iBACA,kCACA,IAAI,kCACJ,iBACA,eACA,eACA,CAAG,8BACH,gCACA,0DACA,mBACA,UACA,UACA,QACA,UACA,MACA,MACA,MACA,MACA,MACA,oBACA,6BACA,SACA,SACA,eACA,MACA,IACA,CACA,iBACA,oCACA,GACA,mBACA,6BACA,iBACA,0DACA,kBACA,QACA,UACA,gBACA,MACA,MACA,UACA,UACA,MACA,QACA,sBACA,wCACA,MACA,OACA,OACA,YACA,WAAG,kCACH,iBACA,yBACA,yBACA,eACA,CACA,gBACA,sDACA,GACA,iBACA,mBACA,uBACA,UACA,aACA,QACA,SACA,KACA,UAEA,mBACA,YAGA,WAEA,kBAEA,cACA,iBACA,0BACA,iBACA,KACA,oBACA,eAEA,MACA,UACA,uBACA,IACA,4BACA,iBACA,kBACA,iBACA,EACA,CACA,iBACA,uBACA,qBACA,cACA,OACA,qBACA,6BACA,iBACA,eACA,QACA,IAAG,kCACH,iBACA,eACA,QACA,IACA,CACA,iBACA,aACA,MAIA,MACA,iBACA,2BACA,mBACA,sBAEA,mBACA,YACA,UACA,6BACA,gBACA,gBACA,MACA,oBACA,yBACA,6BACA,iBACA,+BACA,IAAI,kCACJ,iBACA,4CACA,mBACA,eACA,MACA,gBACA,gBACA,MACA,SACA,cACA,uBACA,KACA,IACA,CAAG,8BACH,gCACA,0DACA,YACA,aACA,eACA,aACA,MACA,MACA,gBACA,mBACA,SACA,MACA,SACA,OACA,UACA,SACA,iBACA,WACA,MACA,IACA,CACA,yBACA,yBACA,6BACA,iBACA,oCACA,IAAI,kCACJ,iBACA,eACA,iBACA,CAAG,8BACH,gCACA,4CACA,oBACA,aACA,QACA,UACA,WACA,QACA,WACA,QACA,MACA,yCACA,aACA,MACA,UACA,gBACA,WACA,MACA,IACA,CACA,oBACA,0BACA,KACA,kBACA,0BACA,iBACA,KACA,oBACA,eAEA,MACA,UACA,mBACA,qBACA,2BACA,IACA,kBACA,IACA,OACA,KAAG,SACH,gBACA,kCACI,MACJ,OAAG,SACH,CACA,qBACA,6BACA,iBACA,sBACA,yBACA,eAAG,kCACH,iBACA,yBACA,yBACA,iBACA,CACA,kBACA,uBACA,IACA,qBACA,eACA,IACA,qBACA,wBACA,6BACA,0BACA,eACA,+BACA,YACA,qCACA,wBACA,aACA,sCACA,EACA,OACA,oBACG,cACH,8BACG,kCACH,WACA,wBACA,aACA,IACA,0BAEA,OACA,uBACA,wDACA,cACA,QACA,UACA,mBACA,MACA,MACA,aACA,aACA,MACA,WACA,sBACA,8BACA,UACA,MACA,YACA,WACA,0BACA,2BACA,wBACA,qCACA,wBACA,aACA,2DACA,MACA,kDAEA,gCACA,8BACA,sBACA,+BACA,QACA,GACA,gBACA,uBACA,2BACA,eACA,KACA,uBACA,yCACA,GACA,gBACA,qDACA,GACA,gBACA,6BACA,iBACA,uBACA,UAAG,kCACH,iBACA,uBACA,UACA,CACA,iBACA,IACA,uDACA,iBACA,QACA,WACA,KAAI,kCACJ,iBACA,cACA,eACA,GACG,+BACH,gCACA,QACA,WACA,KACA,CACA,gBACA,qDACA,GACA,uBACA,yCACA,GACA,kBACA,uBACA,2BAA6C,aAC7C,MACA,mBACA,mBACA,cACA,aACA,cACA,EACA,CACA,wBACA,gBACA,IACA,qBACA,CACA,QACC,IACD,iBACA,qBACA,iBACA,oBACA,kCACA,iBACA,YACA,QAAE,kCACF,iBACA,SACA,SACA,GACA,kBACA,qBACA,QACA,mBACA,WACA,MACA,sCACA,OACA,aACA,SACA,oBACA,WACA,cAEA,MACA,WACA,QACA,IACA,IAEA,MACA,eACA,UACA,mBACA,SACA,qBACA,OACA,WACA,IACA,QACA,YACA,CACA,IACA,QACA,qBACA,SACA,gBACA,OACA,WAAI,SACJ,gBACA,6EACK,qBACL,QAAI,SACJ,CACA,KACA,iFAEA,oBACA,OACA,SACA,KACE,gBACF,aACA,WACA,SAAE,aACF,iBACA,QACA,WAEA,YAGA,YACA,sBACA,0BACA,MACA,kBACA,OACA,WACA,uBACA,OACA,OACA,2BACA,UACA,MAEA,oBADA,MAEA,4BACA,cACA,OAAgB,EAAS,IACzB,MAEA,mBACA,YACA,qDACA,yDACA,uDACA,oDACA,6BACA,2BACA,kBACA,sBACA,oBACA,mBACA,4BACA,qDCxkBA,YACA,kBACA,UACA,qBAA+B,mDAC/B,iBACA,QACA,UACA,EA8EA,cAEA,cAYA,cAsBA,yGA1HA,IASA,wBACA,4BACA,MACA,mBACA,oBACA,mBACA,iBACA,kBAIA,YAHA,mCAEA,gBAEA,4BACA,+CACA,0BACA,WAEA,wCACA,UAEA,6BACA,mBAEA,sBACA,mBAEA,gFACA,WACA,KACA,sCACA,yBACA,eACA,OAAiB,QAA0C,mBAC3D,mBACA,iCAGA,eAEA,6BACA,qCAEA,4BACA,0CAEA,4BACA,uCAEA,sDACA,YACA,2BACA,qBACA,wCACA,mBACA,UAEA,2BACA,oCACA,+BAEA,6BACA,OAAiB,QAAqC,qBACtD,mBACA,qCAGA,eAEA,8CACA,YACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IAED,4BAEA,wBACA,iBACA,CACA,QACA,wBACA,OACA,GACA,qBACA,CACA,QACC,IAED,wBACA,mBACA,mBACA,uCACA,gBAA+D,qBAE/D,gCACA,gBAA+D,qBAE/D,gCACA,8BAAsF,8BAGtF,KACA,wBACA,OACA,GACA,qBACA,CACA,QACC,IAED,wBACA,mBACA,oBACA,oCAEA,wCACA,oCAEA,wCACA,+BAGA,6BACA,wBACA,OACA,GACA,qBACA,CACA,QACC,IACD,0BACA,wBACA,8DCrJA,kEADA,IAEA,wBACA,uBACA,UACA,UACA,mBACA,yBACA,iCACA,iBACA,aACA,OAAI,kCACJ,iBACA,aACA,OACA,CAAG,8BACH,gCACA,kBACA,UACA,WACA,SACA,CACA,wBACA,YACA,IACA,qBACA,CACA,QACC,IACD,qBACA,UACA,gBACA,wCACA,sCCtCA,aAIA,eAAoB,2BAEpB,CAgDA,aAEA,6BAEA,2BAA+B,oBAAuB,EACtD,MAiBA,eACA,uDAEA,qEAAqD,eACrD,mBACA,kBACA,IA4BA,iBACA,IACA,OACA,cACA,QACA,gBACA,SAEA,GADA,gBAEA,wBACA,OAEA,OACA,2BAEA,IAAc,QACd,QAEA,GAEA,YACA,qBACA,OAnIA,4BAEA,MAyBA,aACA,cACA,6CAEA,cACA,gBACA,aAGA,uBACA,SAPA,QAWA,CAUA,qBATA,CAKA,UACA,gBAEA,eA3CA,CAGA,OAkDA,WACA,aACA,6BACA,yBAEA,gCAAoC,eAGpC,KACA,KAzDA,IAuEA,WACA,yBACA,UAvEA,IAyDA,WACA,yBACA,mBAzDA,IAuEA,aACA,sEACA,KACA,MAxEA,KA+EA,UACA,yBACA,QA/EA,OAiFA,UACA,yBACA,UAjFA,QAmFA,UACA,oCACA,UAnFA,QA6GA,aACA,CACS,eAAT,YACA,SACA,iBACA,qCACA,KACA,GAnHC,MAmED,UACA,iBACA,2BACA,uFC1FA,iCCIA,YACA,kBACA,oBACA,wBACA,0BACA,yBACA,0BACA,iBACA,QACA,UAAE,8BACF,gCACA,QACA,gBACA,YACA,yFAfA,KAgBA,wBACA,iCACA,qCACA,2BACA,cACA,8BACA,6DACA,UACA,mCACA,yBACA,aAAuD,qBAAiB,SACxE,IACA,MACA,yBAAK,SACL,gBACA,UACM,qBACN,QAAK,SACL,sCACA,KACA,YACA,cAAG,8BACH,iBACA,mDACA,kBACA,aACA,uBACA,CACA,4BACA,SACA,4DACA,uCACA,iDAAiF,6BACjF,wBACA,iCACA,iBACA,sBACA,oCACA,IACA,oBACA,6DACA,UAAG,SACH,gBACA,UACI,qBACJ,QAAG,SACH,CACA,+BACA,aACA,iBACA,uBACA,eACA,4BACA,iBACA,iBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,qBACA,yBACA,gCACA,SACA,aACA,qBACA,QAAE,yBACF,+EACA,+CACA,SACA,WACA,+BACA,qBACA,QAAG,0FACH,+CACA,SACA,eACA,qBACA,QACA,CAAE,8BACF,8DACA,SACA,WACA,yBACA,0BACA,qBACA,QACA,GACA,sCACA,SACA,iFACA,cACA,YAEA,IADA,4BAGA,KADA,KAEA,UACA,0BACA,wBACA,wBACA,4BACA,wDC9GA,YACA,iBACA,iCACA,wBACA,oBACA,iBACA,uBACA,qBACA,QACA,8KAVA,IAWA,wBACA,qCACA,MACA,wBACA,8BACA,sBACA,6BACA,SACA,eACA,aACA,kCACA,cAEA,UACA,iBACA,kBACA,kBAEA,cADA,IAEA,qBACA,sCAEA,YACA,8BACA,cACA,SAAuC,aAAa,WACpD,SACA,WACA,8BACA,YACA,cACA,kBACA,oBACA,oCACA,WACA,CACA,6BACA,cACA,oBAA2C,eAC3C,kBACA,sBACA,UACA,OACA,YACA,MAEA,CAEA,sBADA,iBAEA,sCACA,sBACA,gBACA,QACA,sBACA,0CACA,uBACA,UACA,KAGA,SAFA,gDACA,UAEA,sBACA,YACA,sCACA,sCACA,kCACA,iBACA,gBACA,eACA,wBAEA,iCACA,8CACA,4CACA,4CACA,uBACA,gBACA,4BACA,iBACA,wBAEA,iDACA,iBACA,QACA,iCACA,YACA,cACA,4BACA,yBAA0C,aAAa,WACvD,SACA,WACA,oDACA,cACA,0CACA,cACA,oBACA,CACA,sBACA,MACA,eACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,wBACA,2BACA,4BACA,mDAAwE,8CACxE,EACA,GACA,+BACA,cACA,UACA,kBACA,SACA,8BACA,oBACA,MACA,UACA,gDC7IA,YACA,cACA,0BACA,oBACA,0BACA,eACA,qBACA,0FARA,IASA,wBACA,6BACA,6BAA6C,eAC7C,eACA,SAEA,cACA,mCACA,aACA,eACA,8BACA,WACA,oBAAuC,eACvC,kBACA,6CACA,CACA,IACA,KAEA,yEACA,8BACA,wCAAuC,eACvC,eACA,SACA,oBAEA,gBACA,0BACA,MACA,uCACA,cACA,cACA,+BACA,cACA,sBACA,gBACA,oBACA,MACA,2CACA,gDACA,eACA,4BACA,6BAA6C,eAC7C,eACA,6DACA,wBAGA,eACA,2BACA,UACA,UACA,SACA,gBACA,aACA,SACA,6BACA,SACA,gBACA,YACA,2CAAwC,aAAa,WACrD,SACA,WACA,eACA,qBACA,YACA,gBACA,aAEA,QACA,CACA,CACA,uBACA,IACA,qDACA,GAEA,2CACA,EAEA,EACA,CACA,wBACA,qBACA,cACA,yBAA8C,aAC9C,uBACA,qBACA,mBAAmB,aAAoB,EACvC,sBAGA,WACA,MACA,aACA,IACA,0BACA,UACA,WACA,mBACA,SACA,WACA,QACA,CACA,2BACA,SACA,4CACA,4CACA,MACA,mBACA,GACA,2BACA,8BAA0C,eAAa,WACvD,KACA,yBACA,eACA,aACA,2BACA,OACA,CACA,qBACA,aACA,MACA,6BACA,aACA,YACA,wBACA,QACA,IACA,qBACA,CACA,QACC,kCC5ID,YAKA,MACA,iCAPA,IAQA,eAKA,KACA,2BACA,CAEA,mBADA,UAMA,EACA,2BACA,iBACA,gBAGA,uCACA,SAOA,EACA,4BACA,CAEA,mBADA,SAQA,EACA,0BACA,IACA,gCAGA,wBACA,KAOA,EACA,2BACA,IACA,gCAGA,2CACA,EAOA,EACA,4BACA,SAKA,uBAKA,EACA,8BACA,aACA,OAgBA,EACA,8BACA,oBACA,UAMA,EACA,2BACA,oBACA,MAKA,EACA,8BACA,QAEA,wBAA2C,OAAS,IACpD,gBAGA,WACA,yBC7IA,aAMA,aACA,iBACA,GAHA,MAIA,eAKA,OACA,qECXA,YACA,iBACA,iBACA,iBACA,sBACA,yCANA,GAOA,wBACA,yBACA,aACA,SACA,gCACA,YACA,+BAMA,kDALA,IACA,qBACA,UAEA,iCAEA,sCACA,6BACA,sEACA,iFACA,sBACA,oBACA,eACA,yDACA,iBACG,yDACH,YAGA,gBAEA,SACA,yCACA,SACA,cACA,8CACA,8BACA,YACA,KAEA,+BADA,QAEA,oBACA,aACA,WACA,yCACA,uBACA,mBAAiB,aAAsB,EACvC,kDACA,UACA,cACA,2BAGA,KACA,oCACA,mBACA,cACA,yBACA,+BACA,sCACA,sEAEA,EACA,sBACA,aAAsC,eACtC,eACA,SACA,kBAEA,iHACA,yCACA,wBAEA,+BAEA,kDACA,oDACA,mBACA,oCAEA,SACA,wBACA,CACA,QACA,qBACA,CACA,QACC,gCC9FD,YACA,MACA,gBACA,+BACA,aACA,SACA,kCACA,oBACA,SACA,8BACA,OACA,uDCNA,YACA,cACA,sCACA,gCACA,yBACA,oBACA,cACA,cACA,0BACA,uBACA,uBACA,0BACA,wBACA,gBACA,6CAfA,IAgBA,wBACA,mCACA,aACA,2BACA,mBACA,+BACA,UACA,wCACA,sCACA,wCACA,gBACA,UACA,uCACA,qBACA,yBACA,yBACA,yBACA,uBACA,yBACA,+BACA,aACA,OACA,gCACA,IACA,qBACA,+DACA,mCACA,4BAEG,iCACH,iBACA,gCACA,4BACA,GACA,8BACA,2BAEA,6BACA,2BAEA,EACA,CACA,qBACA,qCACA,SACA,+BACA,MACA,iBACA,mCACA,IACA,yDACA,kCAEG,2BACH,iBACA,aAAkB,SAAkB,QACpC,sGACA,KAGA,SACA,QACA,CACA,6BACA,aACA,SACA,uBACA,sCACA,SACA,4BACA,yBACA,eACA,+BACA,uFACA,IACA,QACA,wBACA,yBACA,sBACA,qBACA,mJACA,oBACA,2BACA,aACA,iBACA,4BACA,WAAiB,SAAkB,QACnC,sBACA,YAGA,SACA,QACA,2CACA,aACA,uCACA,oBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,qCACA,eACA,aACA,KACA,QACA,UACE,cACF,YACE,YACF,eACA,aACA,KACA,iBACA,cAEA,OACA,CAEA,qCADA,+BAEA,4CACA,aACA,UACA,UACA,KAEA,qCADA,mCAEA,mBACA,iBACA,cACA,oBACA,uBACA,yDCjIA,aACA,4BACA,8CACA,iDA3BA,GAEA,QACA,SACA,8CACA,+BACA,iBACA,+BACA,mCAeA,uBAMA,wBAUA,QACA,SACA,wBACA,qBACA,YACA,yCACA,UAGA,sBACA,kBACA,GACA,mBAIA,qCAEA,0BACA,QASA,UACA,aACA,kBASA,oBACA,2BACA,kBACA,WAEA,cACA,cACA,EAMA,WALA,YAEA,iCAEA,KAQA,IACA,QACA,cACA,kBACA,CASA,UACA,2DACA,GAUA,eACA,IACA,kCAAwD,OAAS,IACjE,mDAEA,mBACA,IAQA,eACA,IACA,2CAAiE,OAAS,IAC1E,4CAEA,gCACA,IAEA,eACA,IACA,2CAAiE,OAAS,IAC1E,4CAEA,gCACA,IASA,oBACA,IACA,kCAA6D,OAAS,IACtE,WACA,6BACA,gBAEA,mBACA,IAQA,YACA,OACA,sCACA,4BAAgD,OAAS,IACzD,mDAEA,mBACA,IAQA,iBACA,IACA,kCAA0D,OAAS,IACnE,qDAEA,mBACA,IASA,uBACA,IACA,kCAAwD,OAAS,IACjE,kCAEA,+BACA,IAQA,KAEA,SACA,4CACA,8BACA,KAEA,2BADA,gBAUA,UACA,OACA,iCACA,4DACA,QASA,eACA,IACA,uCACA,wCAEA,KACA,KAFA,kBAEwC,OAAS,IACjD,gCACA,0BAEA,qCACA,mBASA,eACA,IACA,uCAGA,wCACA,KAEA,qBAAwC,OAAS,IACjD,6BAEA,mCACA,mBASA,eACA,IACA,uCAGA,wCACA,KAEA,qBAAwC,OAAS,IACjD,6BAEA,mCACA,mBASA,oBACA,IACA,uCAGA,+CAEA,YACA,KAFA,kBAEuC,OAAS,IAChD,gCACA,+BAEA,qCACA,wBASA,YACA,IACA,uCAGA,uCAEA,YAEA,SAHA,EAEA,kBACuC,OAAS,IAChD,gCACA,0BACA,kDACA,SACA,MAEA,MAGA,oCACA,kBASA,iBACA,IACA,uCAGA,4CAEA,kBACA,KAFA,kBAE0C,OAAS,IACnD,gCACA,4BAEA,qCACA,qBASA,uBACA,IACA,uCAIA,yDACA,4BACA,KACA,qBAA0C,OAAS,IACnD,qBAEA,mCACA,2BACA,iCC3YA,YACA,gCACA,YACA,uDAJA,GAKA,mBACA,wBACA,6BACA,UACA,YACA,WACA,8BACA,sBACA,oBACA,MACA,KACA,SAAG,gBACH,UACA,QACA,2BACA,GACA,cACA,iDACA,YACA,WACA,SACA,gDACA,UACA,SAAG,gBACH,SACA,qBACA,UACA,SACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCCxCD,YACA,gCACA,YACA,uCAJA,GAKA,mBACA,wBACA,0BACA,GACA,iBACA,qBACA,UACA,YACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCCjBD,YACA,kBACA,KACA,sDACA,iBACA,eACA,OAAG,yBACH,iBACA,aACA,qBACA,KAAG,kCACH,iBACA,2BACA,QACA,mBAAmB,kBAA0B,OAC7C,uBAGA,WACE,+BACF,+CACA,aACA,qBACA,wBACA,0BACA,QACA,sCA3BA,GA4BA,wBACA,4BACA,WAAiB,kBAA0B,OAC3C,SAEA,aACA,mBACA,WAAiB,kBAA0B,OAC3C,mCAEA,SACA,QACA,mCACA,WAAiB,kBAA0B,OAC3C,uCAEA,cACA,mBACA,OACA,yBACA,mBACA,2CACA,kBACA,kCACA,oBACA,sBACA,UACA,UACA,WAAiB,kBAA0B,OAC3C,0EAEA,YACA,yBACA,aACA,QACA,iBACA,kCACA,8BACA,gDACA,yBACA,QACA,qBACA,UACA,oFACA,wDACA,8EACA,WACA,UACA,8BACA,mBACA,wBACA,0BACA,QACA,iBACA,oCACA,gBACA,IACA,mBACA,OACA,uBACA,sBACA,WAAiB,kBAA0B,OAC3C,mCAEA,SACA,QACA,wBACA,yBACA,iBACA,wBACA,KAAG,8BACH,gCACA,QACA,aACA,CACA,kBACA,6BACA,+BACA,KACA,6BACA,6BACA,WACA,+BACA,WAAiB,kBAA0B,OAC3C,4BAEA,SACA,QACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCCvHD,YACA,iBACA,mBACA,qBACA,QACA,6DANA,IAOA,wBACA,iBACA,qBACA,MACA,oBACA,+BACA,iBACA,sBACA,OAKA,MAJA,4BACA,2BAEA,WACG,+BACH,iBACA,4BACA,uBACA,8BAGA,yBAEA,gBACA,CACA,mBACA,gBAAgC,eAChC,eACA,SAEA,QACA,qBACA,8BACA,UACA,mBACA,qBACA,QACA,8BACA,cACA,YAA+B,eAC/B,eACA,qDAEA,OACA,QACA,iBACA,SACA,uBACA,aACA,MACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCC9DD,YACA,eACA,iBACA,gBACA,cACA,cACA,cACA,cACA,oBACA,0BACA,iBACA,QACA,OAAE,8BACF,+CACA,qBACA,KAAE,8BACF,8DACA,UACA,aACA,eACA,QACA,8CAtBA,GAuBA,wBACA,6BACA,2CACA,6BACA,8BACA,6BACA,IACA,kBACA,aACA,GACA,0BACA,aACA,GACA,qBACA,MACA,OACA,mBACA,uBACA,uBACA,0BACA,qBACA,mFACA,OACA,uBAEA,aACA,mBACA,kCACA,aACA,GACA,kBACA,aACA,GACA,qBACA,aACA,MACA,oBACA,aACA,KACA,wBACA,aACA,SACA,oBACA,aACA,KACA,qBACA,uBACA,uBACA,0BACA,qBACA,iFACA,MACA,0BACA,oBACA,MACA,WACA,qBACA,iBACA,4CACA,2CACA,yCACA,wBACA,QACA,IACA,qBACA,CACA,QACC,kCC5ED,YACA,IACA,mCACE,oDACF,iBACA,YACA,OACA,EAwLA,YACA,iBACA,YACA,8JAnMA,KASA,mBACA,wBACA,uDACA,YACA,yBACA,OAAiB,MAA2B,OAC5C,0DAEA,SACA,QACA,wBACA,OACA,SACA,iBACA,OACA,8CACG,oCACH,UACA,mBACA,oFACA,gCACA,QACA,eAEA,gCACA,SAAG,6CACH,UACA,4BACA,UACA,YACA,8BACA,iBACA,2BACA,UACA,aAAiB,EAAgB,QACjC,SACA,eACA,oBACA,SACA,YACA,OACA,GACA,CACA,CACA,QACA,kBACA,yBACA,iBACA,mCACA,OAAG,yBACH,gCACA,4BACA,SACA,CACA,0BACA,UACA,WACA,uDACA,kDACA,SACA,mBACA,oFACA,gCACA,oCACA,SAAG,wCACH,UACA,kBACA,OACA,+CACG,qCACH,UACA,sCACA,eACA,mCACA,yBACA,qBACA,6CACA,oBACA,6CACA,6BACA,yBACA,kCACA,iBACA,qCACA,yBACA,mBAAI,+BACJ,iBACA,sCACA,kBACA,CAAG,8BACH,4DACA,gCACA,kCACA,yBACA,mBAAI,8DACJ,gCACA,MACA,OACA,UACA,WACA,0BACA,SACA,WACA,sBACA,QACA,YACA,IAEA,OAEA,kBACA,sDACA,UAAI,gDACJ,gCACA,sCACA,oBACA,CAAG,8BACH,6FACA,+CACA,YACA,yBACA,+CACA,EAAI,+EACJ,+CACA,MACA,UACA,OACA,uDACA,8BACA,SACA,WACA,iBACA,KAEA,QACA,aACA,WAEA,iBACA,oBACA,SAEA,mBAGA,iBAEA,kBACA,UACA,WACA,CAAG,8BACH,8DACA,YACA,yBACA,2BACA,qBACA,CACA,wBACA,YACA,IACA,qBACA,CACA,QACC,IACD,qBACA,4BACA,YACA,mBACA,aACA,GACA,sBACA,gCACA,UACA,aACA,IACA,yCACA,UAEA,IACA,UACA,qBACA,4BACA,YAKA,mBACA,wBACA,yBACA,WACA,iCAAoD,eACpD,eACA,OACA,oBAEA,iCAGA,aACA,QACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,gBACA,sCACA,cACA,uBACA,QACA,IACA,uBACA,gEACA,aACA,GACA,cACA,uBACA,QACA,IACA,uBACA,gEACA,aACA,GACA,eACA,uBACA,QACA,aACA,0BACA,UACA,aACA,GACA,yDClQA,YACA,YACA,iBACA,gBACA,iBACA,qBACA,2BAPA,GAQA,wBACA,gBACA,yBACA,4BACA,GAIA,8CAHA,oBACA,eACA,IAEA,iBACA,aACA,KACA,qBACA,CAEQ,UADR,mBACA,iBAAgC,UAEhC,0EACA,uCAFA,kCAIA,oBACA,QACA,kBACA,YACA,cACA,OACA,oBACA,OACA,eACA,iBACA,iBACA,kBACA,aACA,MACQ,oBAAR,KAAgE,0CAChE,wCAEA,iBACA,QACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCCnDD,YACA,kBACA,qBACA,QACA,2CALA,IAMA,wBACA,sBACA,SACA,kBACA,kCACA,IACA,UACI,SACJ,OAEA,GACA,CACA,OACA,MACI,EACJ,MAEA,EAEA,CACA,wBACA,YACA,IACA,qBACA,CACA,QACC,kCCjCD,4BADA,GAEA,wBACA,mBACA,oBACA,kBACA,yBACA,WACA,EAAG,8BACH,gCACA,EACA,CACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCCdD,YACA,kBACA,sBACA,oBACA,wBACA,mDACA,QACA,mBACA,mBACA,oCACA,+CAXA,GAYA,wBACA,4BACA,0BACA,kCACA,gBACA,iDACA,gDACA,iBAEA,yCACA,iBAEG,MACH,8CACA,iBACG,KACH,8CACA,iBAEA,mBACA,iCACA,qBACA,6DACA,aACA,uBACA,IACA,wCACA,6BACA,EACA,CACA,0BACA,aACA,yBAAmC,aAAa,WAChD,SACA,wBACA,iBACA,mBAEA,MACA,CACA,0BACA,mBACA,iBACA,WACA,wBACA,aACA,SACA,qBACA,aACA,6DAEA,oEACA,YACA,wBACA,QACA,IACA,qBACA,CACA,QACC,IACD,kBACA,sBACA,WACA,yBACA,oBACA,oCCtEA,YACA,eACA,UACA,kCACA,wBACA,KACA,mCACE,oDACF,iBACA,kBACA,6CACA,eACA,oFAbA,IAcA,wBACA,yBACA,6FACA,+CACA,eACA,uBAAkB,QAA4B,OAC9C,SACA,6CAGA,8BACA,UACK,iCACL,mBAEA,eAGA,uBAAG,kGACH,+CACA,eACA,uBAAkB,QAA4B,OAC9C,SACA,6CAGA,8BACA,UACK,iCACL,aAEA,eAGA,uBACA,CACA,4BACA,aACA,aACA,sBACA,uBACA,EACA,iBACA,IACA,iCACA,UAEA,QACA,uBACG,gCACH,iBACA,aACA,2BAAqD,eACrD,eACA,mBACA,aACK,oBACL,UAGA,GACA,QACA,CACA,0BACA,WACA,8BAAoD,eACpD,eACA,mBACA,wBAGA,WACA,mCAIA,aACA,sBACA,yBACA,MACA,kCACA,0BAEA,MAAG,yBACH,iBACA,gBACA,8BAAqD,eACrD,kBACA,wBACA,YACA,yBACA,MAAK,kBACL,aAEA,eAGA,0CAEA,MACA,CACA,sBACA,yBACA,sGACA,UACA,8BACA,yBACA,iBACA,YACA,KAEA,qCADA,UACG,yBACH,+CACA,kBACA,OACA,wBACA,OAEA,sCAAoD,eACpD,eACA,mBACA,UAEA,iDACA,OACA,SAIA,cACA,KACA,CACA,kBACA,yBACA,iBACA,QACA,iBACA,iBAGA,0DACA,0CAGA,WAAG,yBACH,gCACA,WACA,aACA,gBAEA,mDACA,0CAEA,QACA,CACA,kBACA,oBACA,qHACA,wBACA,UACA,UACA,oBACA,aACA,aACA,KACA,mBACA,yBACA,gCACA,eACA,uDACA,mCAGA,QAAG,yBACH,+CACA,cACA,qBACA,mBACA,8BAAqD,eACrD,mBACA,6CAGA,6BACA,cACA,iBACA,CACA,IACA,KAGA,CAMA,MALA,kCACA,kCAGA,WAEA,CACA,kCACA,eACA,iDACA,SACA,oBAEA,+BACA,EACA,kBACA,IACA,iCACA,UAEA,QACA,wBACG,gCACH,iBACA,aACA,2BAAqD,eACrD,kBACA,wBACA,YACA,eACA,IAEA,UACA,CACA,CACA,sCACA,eACA,oBACA,gBACA,wBACA,wBACA,6BAAgD,eAChD,eACA,2DACA,8BAEA,gCAEA,qBACA,QACA,oBACA,+BAEA,+BADA,SAEA,wBACA,QACA,IACA,qBACA,CACA,QACC,IACD,8BACA,qBACA,GAEA,eADA,aAEA,wCACA,yDCzRA,4BADA,GAEA,wBACA,qBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCCCD,YACA,kBACA,gBACA,qBACA,QACA,QAiJA,YACA,gBACA,gBACA,kBACA,oBACA,oBACA,wBACA,kBACA,QACA,yBACA,yBACA,gBACA,0GAnKA,IAOA,wBACA,+BACA,UACA,UACA,8BACA,eACA,oBACA,SACA,YACA,0BACA,GACA,UACA,mBACA,8BACA,UACA,UACA,uCACA,iDAAkD,eAClD,sBACA,+BAEA,mBACA,mBACA,WACA,iCAAgC,eAChC,eACA,SAEA,QACA,+CACA,WAAiB,sBAA2B,MAC5C,kBACA,8CACA,gCACA,KACA,6BAEA,GACA,CACA,oCACA,qCACA,+BACA,yCAEA,eAGA,oBACA,oCAAoC,OAAuB,aAC3D,qBAGA,qCAEA,OACA,qBACA,+BACA,UACA,2BACA,MACA,oBACA,mCACA,eACA,oBACA,SACA,cACA,uBACA,OACA,GACA,CACA,mCACA,+BACA,gCACA,sBACA,cAEA,IACA,2BAIA,KACA,4CACA,oBACA,aACA,eACA,oBACA,SACA,cACA,4CACA,KACA,GACA,CACA,oBACA,aACA,KACA,yBACA,yBACA,uCACA,uBACA,mBACA,+BACA,qCACA,+BACA,yCAEA,eAEA,wBACA,QACA,mBACA,gCAAoC,OAAuB,aAC3D,sBAEA,2CACA,6BACA,UACA,mBACA,yCACA,qCACA,aACA,yBAKA,4CAFA,kDAGA,wCACA,kBACA,yBACA,qBACA,sCACA,yDACA,OACA,8BACA,+CACA,iCACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IAcD,wBACA,gBACA,OACA,4CACA,4CACA,kBACA,oBAEA,iCACA,kDACA,kCACA,4CACA,kBACA,oBAEA,uDACA,aACA,KACA,mBACA,yDACA,UACA,oBACA,OAEA,sBACA,yBACA,oDAAmE,OACnE,IACA,wBACA,QACA,IACA,qBACA,CACA,QACC,kCC5MD,YACA,iBACA,gBACA,uBACA,yBACA,sBACA,kEACA,QACA,2BACA,aACA,oBACA,gDACA,uDAbA,GAcA,wBACA,yBACA,aACA,KACA,mBACA,cACA,gCACA,aACA,uBACA,IACA,8CACA,mCACA,+BACA,+CACA,MACA,wBACA,oCACA,mBAEA,oBACA,uBACA,aACA,WACA,wBACA,QACA,IACA,qBACA,CACA,QACC,kCC5CD,mCADA,GAEA,wBACA,uBACA,CACA,QACA,qBACA,CACA,QACC,IACD,4BACA,aACA,MACA,EACA,GACA,yBACA,wBACA,8BACA,0BAEA,SACA,SACA,kBACA,QACA,kBACA,uBACA,IACA,qBACA,MACA,wBACA,IACA,wBACA,IACA,qBACA,MACA,uBAEA,8BACA,wBACA,IACA,4BACA,aACA,MACA,OACA,MACA,EACA,iCC7CA,mCADA,KAEA,wBACA,4BACA,wBACA,QACA,IACA,qBACA,CACA,QACC,kCCTD,YACA,sBACA,0BACA,0BAJA,IAKA,wBACA,mBACA,yBACA,gCACA,EAAG,8BACH,8DACA,2BACA,sCACA,kDACA,aACA,CACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCClBD,2DADA,IAEA,wBACA,uBACA,CACA,QACA,qBACA,CACA,QACC,IACD,kCACA,OACA,OACA,cACA,WACA,SACA,2BACA,SACA,GAAE,kBACF,WACA,cACA,UACA,4BACA,QACA,qCACA,KAEA,mBACA,kBAEA,kCACA,QACA,cACA,2BACA,2BACA,eACA,KACA,CACA,GACA,UACA,GACA,sBACA,yBACA,iBACA,wBACA,KAAE,yBACF,gCACA,gBACA,SACA,0BAAiB,eAA2B,EAC5C,yBACA,QAEA,OACA,QACA,GACA,wBACA,gCACA,QAAgB,MAAkB,OAClC,kBAEA,WACA,wCChEA,YACA,iBACA,KAA+B,mDAC/B,iBACA,QACA,wBACA,wBAPA,GAQA,wBACA,kCACA,MACA,SACA,wBACA,QACA,IACA,qBACA,CACA,QACC,kCCZD,YACA,MACA,iCACA,qBACA,oCACA,QACA,uBACA,yEARA,KASA,wBACA,6BACA,SACA,wBACA,YACA,MACA,YACA,aACA,qCAEA,WAEA,kCACA,iBAEA,cADA,YAEA,+CACA,mCACA,gBACA,GACA,uCACA,eACA,qCACA,QACA,8BAAuB,EAAQ,KAC/B,qBAEA,QAAG,KACH,GACA,4BACA,yBACA,mCACA,QACA,4BAAkB,EAAS,KAC3B,qBAEA,QACA,GACA,mBACA,WACA,wCACA,mCACA,6BACA,cACA,yBACA,8BACA,gBAAiB,IAAQ,KACzB,MACA,uBAEA,UACA,WACA,sCACA,mCACA,iBACA,yBACA,mCACA,gBAAiB,EAAS,KAC1B,qBAEA,WACA,wCACA,2BACA,eACA,qCACA,kBAAsB,EAAQ,KAC9B,qBAEA,WACA,wCACA,MACA,WACA,iCACA,wBACA,2BACA,YACA,gBACA,eACA,aAGA,iBACA,4BACA,SACA,wDACA,qBACA,YACA,YACA,gBACA,qCAEA,8CACA,MAEA,gCADA,MACI,WAEJ,oCACA,iBACA,QACA,gCACA,aACA,UACA,+BACA,0BACA,mBACA,8BACA,SACA,oCACA,qBACA,eAEA,8BACA,yBACA,gCACA,gBACA,oCACA,mCACA,gBACA,sBACA,eACA,qCACA,QACA,8BAAuB,EAAQ,KAC/B,qBAEA,QAAG,KACH,WACA,yBACA,mCACA,QACA,4BAAkB,EAAS,KAC3B,qBAEA,QACA,GACA,gBACA,uBACA,0CACA,aACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,6BACA,gCACA,QAAgB,MAAiB,OACjC,iBAEA,MACA,wCCnKA,YACA,iBACA,uBACA,qBACA,gCACA,iCACA,QACA,kDARA,IASA,wBACA,8BACA,YACA,qBACA,qBACA,2BACA,yBACA,yBACA,2BACA,qCACA,WACA,2BACA,SACA,kCACA,2BACA,+BACA,IACA,kCACA,qCACA,OACA,KAGA,qBACA,kCACA,0BACA,CACA,QACA,sCACA,WACA,wBACA,wBACA,mBACA,4BACA,IACA,sCACA,iBACA,2BACA,UAAkB,KAAQ,IAC1B,kDAEA,SACA,QACA,2BACA,WACA,wBACA,kBACA,QACA,sBACA,mBACA,sCACA,8DACA,SACA,MACA,UAEA,gDACA,cACA,qCACA,aACA,2DACA,IACA,QACA,6BACA,WACA,4BACA,IACA,yBACA,cACA,OAAiB,oBAA4B,OAC7C,8CAEA,wBACA,mBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,wBACA,OACA,kBACA,aACA,SACA,WACA,SACA,oDCzFA,YACA,MACA,iDACA,kCACA,gBACA,UACA,iCACA,qBACA,cACA,cACA,cACA,cACA,mBACA,mBACA,sBACA,sBACA,gBACA,OACA,wEACA,QACA,uBACA,yBACA,oCACA,qHACA,iCACA,qGA1BA,IA2BA,wBACA,6BACA,kBACA,kBACA,SACA,8CACA,yEACA,kDACA,yEACA,0CACA,6CACA,4FACA,MACA,WAEA,uBAEA,yBAEA,kBACA,6BACA,UACA,eACA,+CACA,sBACA,gDACA,yBACA,UACA,IACA,8BACA,2BACA,gCACA,4DACA,iCACA,IACA,eACA,+BACA,0BACA,IACA,eACA,oBACA,2BACA,2BACA,uCACA,iCACA,iBACA,uBAGA,UACA,2BACA,qBACA,iBACA,QACA,gCACA,IACA,QACA,QACA,qCACA,+BACA,yCACA,KAAG,SACH,gBACA,iBACA,GACI,SACJ,QAAG,SAEH,iBAEA,wDAEA,gBACA,8BACA,qEACA,oEACA,IAEA,gDACA,uEACG,gDACH,gDAEA,gDACA,2EACA,6CAEA,KACA,0BACA,yDACA,oEACA,oEACA,oEACA,0BACA,WACA,2BACA,eACA,WACA,4BACA,mCACA,GACA,qCACA,aACA,UACA,IACA,eACA,UACA,IACA,eACA,oBAEA,eAEA,mBACA,cACA,2CACA,QACA,2BACA,mCACA,GACA,kCACA,MACA,WACA,WACA,mBACA,+EACA,SACA,uCACA,kBACA,4BACA,6BACA,0DACA,QACA,kBACA,qBACA,OACA,UACA,QACA,YACA,aACA,UACA,eACA,cACA,6CACA,qBACA,oBACA,uBAEA,yBACA,uBAEA,SACA,uCACA,4BACA,MACA,oCACA,kBACA,mBACA,KACA,MACA,WACA,UACA,UACA,SACA,cACA,eACA,mBACA,SACA,IACA,CACA,wCACA,uBACA,gBACA,gBACA,UACA,OACA,UACA,oBACA,gBACA,gBACA,gBACA,GACA,0BACA,kGACA,aACA,+DAEA,iBACA,uFACA,0EACI,QACJ,sCACA,mCACA,wMACA,kBACA,gNACA,kBACA,QACA,+BAEA,uCACA,GAEA,CACA,0BACA,oCACA,iBACA,gDACA,yBACA,WACA,4BACA,uBACA,0BACA,GACA,kBACA,MACA,mDACA,yCACA,0CACA,4DACA,kCACA,0BACA,8DACA,oBACA,qBACA,6FACA,iDACA,sCAEA,wFAGA,WACA,sBACA,eACA,WACA,kCACA,aACA,sBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,wCACA,+CACA,yCACA,8DC1RA,YACA,cACA,0BACA,UACA,yCACA,yCANA,GAOA,wBACA,0BACA,8BACA,uBACA,QACA,+BACA,MACA,iBACA,mBACA,UACA,oCACA,mCACA,uBACA,MACA,qBACA,sBACA,CACA,eAAkB,MAAe,OACjC,eAGA,8BAA8B,EAAQ,KACtC,eAGA,KACA,yBACA,0BACA,oDACA,OACA,4BAEA,uBACA,qBACA,UACA,+BACA,2BACA,UACA,sBACA,gCACA,qCACA,2CACA,KACA,4EACA,gBACA,uBACA,MACA,sCACA,MACA,wBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,oECxDA,YACA,iBACA,kBACA,qBACA,QACA,aAsDA,YACA,iBACA,qBACA,oCACA,sBACA,aACA,qGAlEA,IAOA,wBACA,+BACA,yBACA,iBACA,gBACA,uBAA2C,aAAa,WACxD,SACA,WACA,qCACA,wCACA,qBACA,CACA,QAAG,IACH,8GACA,+CACA,yBACA,mBAAmB,aAAoB,MACvC,cACA,sBACA,4CACA,8CACA,YACA,eACA,uDACA,iDACA,4BACA,mDACA,yBACA,UACA,OACA,CAAI,kGACJ,+CACA,eAAqC,eACrC,eACA,SACA,kBAEA,0BAEA,CACA,sBACA,YACA,6CACA,aACA,gBACA,UACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IAQD,wBACA,sBACA,IACA,0DACA,yDACA,2CACA,kBACA,gDACA,YACA,kCACA,gBACA,wBACA,wBACA,UACA,wBACA,KACA,qBACA,wBACA,UACA,wBACA,QACA,IACA,qBACA,CACA,QACC,IACD,+CCrFA,YACA,iBACA,oBACA,wBACA,wBACA,mDACA,QACA,kBACA,iBACA,kKAVA,KAWA,wBACA,qBACA,4BACA,cACA,0DACA,4CACA,SACA,wBACA,YACA,gBACA,YACA,oBACA,gBAEA,eACA,+CACA,uFACA,6CACA,iDACA,oBAAiB,MAA4B,yBAC7C,SACA,iDACA,oEACA,qEACA,SACA,CACA,0CACA,2BACA,QACA,yCACA,aACA,IACA,2BACA,uFACA,uCACA,2DACA,4CACA,SACA,0BACA,+BACA,oCACA,+BACA,MACA,sBACA,sBACA,iBACA,UACA,oCACA,iDACA,SACA,KACA,0CACA,WACA,IACA,UAEA,sCACA,yBACA,eACA,iBACA,sBACA,+BAA+C,4CAAyD,+CAA+C,0CAAyD,+CAA8D,+CAA2D,+CAAiE,2EAC1Y,UACA,kCACA,SAEA,qCACA,iCACA,wCACA,0CACA,0BAEA,MACA,2BACA,WAAiB,QAA2B,mBAC5C,QACA,qBAEA,MACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCC5GD,YACA,SACA,aACA,aACA,mDACA,QACA,UACA,UACA,iDATA,IAUA,wBACA,gBACA,oCACA,GACA,uBACA,0CACA,GACA,0BACA,2BACA,wEACA,GACA,8BACA,iDACA,GACA,oBACA,uCACA,GACA,yBACA,4CACA,GACA,mBACA,sCACA,GACA,qBACA,wCACA,GACA,qBACA,wCACA,GACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,sBACA,oDACA,IACA,4BACA,iDACA,GACA,uBACA,YACA,KACA,gCACA,SACA,MACA,MACA,QACA,QACA,QACA,UACA,QACA,QACA,eACA,uBACA,cACA,GACA,UACA,mCACA,SACA,gBACA,gBACA,YACA,IAGA,aAFA,WACA,QAEA,yBACA,aACA,sBACA,sBAEA,gBACA,8BACA,SACA,MACA,MACA,QACA,QACA,QACA,UACA,qCACA,6BACA,eAGA,OAFA,MACA,MAEA,qCACA,aACA,UACA,wBACA,iCACA,iBACA,WACA,+BACA,SACA,gBACA,iBACA,aACA,UACA,wBACA,KACA,UACA,wBACA,aACA,UACA,UACA,UACA,UACA,UACA,QACA,UACA,UACA,gBACA,KACA,EACA,UACA,0BACA,qBACA,kBACA,YACA,WACA,0BACA,SACA,gBACA,gBACA,cACA,yBACA,wBACA,eACA,yCCvIA,YACA,WACA,+BACA,iBACA,iCACA,4BACA,4FAPA,GAQA,mBACA,wBACA,mCACA,MACA,+BACA,OACA,YACA,yBAAiB,6BAAqC,WACtD,gCACA,WACA,yBACA,SAEA,iCADA,kBAEA,0CACA,SACA,WACA,qBACA,gBACA,wCACA,WACA,kBAGA,wBACA,kCACA,4DACA,2CACA,0CACA,UACA,CACA,oBACA,IACA,UACA,kBACA,6BACA,YACA,eACA,oBACA,kBACA,YACA,uBACA,OACA,kBACA,sDAA2E,mDAE3E,eAAqC,eAErC,wCACA,+CACA,SACA,mBACA,2CACA,gCAAgC,eAChC,eACA,eACA,UACA,WACA,kBACA,kBACA,WAEA,SACA,+BACA,gDACA,gDACA,oBAAgC,eAChC,eACA,2EAEA,mBACA,mBACA,6BACA,gBAAgC,aAAc,WAC9C,SACA,WACA,mDACA,4CACA,GACA,CACA,iCACA,MACA,qBACA,OACA,6BAAyC,EAAQ,SACjD,sBACA,WACA,mBACA,gBACA,WACA,GACA,GACA,UACA,0BACA,yBACA,iBACA,cACA,iBACA,4BACA,uBACA,+CACA,+BACA,qDACA,gBAAG,8BACH,+CACA,UACA,KAA2B,IAAc,QACzC,sBACA,WACA,+BACA,0BACA,KACA,CACA,QACA,CACA,2BACA,gBAAgC,aAAc,WAC9C,SACA,WACA,8BACA,WACA,CACA,sCACA,WACA,OACA,YACA,yDAAmD,EAAQ,SAC3D,gCACA,WACA,SAEA,sCADA,kBAEA,8CACA,SACA,WACA,qBACA,gBACA,4CACA,WACA,qBAGA,wBACA,UACA,2CACA,wEACA,0CAEA,cACA,8BACA,yBACA,WACA,SAAiC,eACjC,eACA,uBAEA,IACA,QAAG,yBACH,iBACA,aACA,SAAiC,eACjC,eACA,4BAEA,IACA,QACA,CACA,qBACA,aACA,MACA,iCACA,eACA,YAAgC,aAAc,WAC9C,SACA,WACA,4BACA,mBACA,OACA,SACA,KACA,mBACA,OACA,SACA,KACA,CACA,CACA,uBACA,aACA,YAAgC,aAAc,WAC9C,SACA,WACA,WACA,4CAEA,kCACA,iCAEA,UACA,CACA,8BACA,qCACA,gCACA,qBAAgC,aAChC,uBACA,WACA,cACA,aAAkB,IAAO,IACzB,QACA,mFAGA,SACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCClOD,YACA,kBACA,oBACA,0CACA,wFALA,IAMA,wBACA,sBACA,MACA,gCACA,eACA,yCACA,kBACA,MACA,iCACA,eACA,YAAgC,aAAc,WAC9C,SACA,WACA,qFACA,MACA,uBACA,aACA,YAAgC,aAAc,WAC9C,SACA,WACA,sEACA,kBACA,2BACA,4BACA,uBACA,mDACA,yBACA,+EAEA,KACA,GACA,sDACA,8CACA,6BAEA,OACA,CACA,CACA,0BACA,YACA,iCACA,cACA,gBACA,eACA,mBACA,wCACA,gCAAgC,eAChC,eACA,SAEA,QACA,oCACA,oCACA,sDACA,EACA,uCACA,YACA,0BACA,wBACA,aACA,iCACA,8BACA,qCACA,YAAgC,aAAc,WAC9C,SACA,WACA,kCACA,iDACA,4BACA,UACA,MAEA,YACA,MAEA,SACA,GACA,CACA,QACA,uBACA,MACA,qBAAiB,qBAA2B,OAC5C,wBACA,aAEA,gBACA,CACA,qBACA,wBACA,UACA,qBACA,OACA,8DAEA,gBACA,SACA,6BACA,wCACA,mDAEA,qBACA,oBACA,qBACA,UACA,qCACA,0BACA,qBAAgC,eAChC,eACA,SACA,mBAEA,eACA,UACA,kCACA,gBAAgC,eAChC,eACA,SAEA,eACA,8BACA,gCACA,gDACA,4BACA,UACA,kBAAgC,aAChC,uBACA,WACA,aAAsB,EAAW,IACjC,mDAGA,wBAAgC,aAChC,uBACA,WACA,aAAsB,EAAW,IACjC,sBACA,WACA,QACA,WACM,aACN,SACA,uBACA,kBACA,GACA,0BAGA,CACA,sBACA,sBACA,MACA,6BACA,eACA,wBACA,IACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCCzKD,YACA,YACA,qBACA,QACA,sEALA,IAMA,wBACA,mBACA,wBACA,MACA,wBACA,QACA,IACA,qBACA,CACA,QACC,IACD,oCACA,2BACA,iBACA,sBACA,2CACA,mBAAgB,MAA+B,yBAC/C,SACA,wBACA,sDACA,wCACA,QACA,YACA,UACA,iCACA,mEAEA,sBADA,UAEA,sCACA,yBACA,2BACA,gCACA,gBACA,cACE,yCACF,kBACA,YACA,kBACA,aACA,SACA,0CACA,QAGA,YACA,UACA,sBACA,wBACA,WACA,qDC1DA,YACA,WACA,uBACA,qBACA,QACA,2BACA,2CAPA,IAQA,wBACA,sBACA,IACA,8DACA,cACA,QACA,wBACA,QACA,IACA,qBACA,CACA,QACC,IACD,yBACA,OACA,iCACA,mCACA,gBACA,SACA,gBACA,gBACA,iBACA,iBAEA,IACA,sBACA,eACA,SACA,KACA,WACA,QACA,sBACA,iBACA,iBACA,EACA,iCC3CA,YACA,MACA,yBACA,mBACA,2BACA,8CACA,cACA,8BACA,2BACA,gCACA,8BACA,gBACA,kBACA,QACA,2BAfA,IAgBA,wBACA,wCACA,IACA,yCACA,8BACA,yBACA,gBACA,0BACA,MAEA,QACA,CAEA,CACA,QACA,uCACA,aACA,wBACA,0CACA,aACA,kBACA,+BACA,aACA,GACA,kCACA,aACA,UACA,wCACA,uBACA,WACA,mBACA,2CACA,OACA,2CACA,YACA,sCACA,yBACA,4BACA,gCACA,gCAEA,uBACA,sCACA,kDACA,iCACA,YACA,kBACA,8BACA,mBAIA,wBACA,4BACA,aACA,gBACA,mBACA,CACA,QACA,oCACA,aACA,YACA,wBACA,QACA,IACA,qBACA,CACA,QACC,IACD,kCACA,OACA,2CClFA,YACA,kBACA,eACA,qBACA,QACA,4DANA,IAOA,wBACA,kBACA,WACA,iCAAgC,eAChC,eACA,SAEA,QACA,qBACA,+BACA,UACA,2BACA,MACA,8BACA,eACA,oBACA,SACA,cACA,uBACA,OACA,GACA,CACA,yBACA,4BACA,4BACA,wBACA,WACA,+BACA,qCACA,oBACA,mCAEA,eAEA,wBACA,QACA,mBACA,gCAAoC,OAAuB,aAC3D,qBAEA,yBACA,mCACA,QACA,qBACA,UACA,4BACA,aAGA,yBAEA,aACA,4BACA,gBAAgC,eAChC,kBACA,yBAEA,SACA,QACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCC1ED,YACA,YACA,uBACA,eACA,mDACA,iBACA,aACA,oBACA,mCATA,GAUA,wBACA,2BACA,aACA,YACA,0BACA,aACA,KACA,mBACA,cACA,gCACA,wCACA,KACA,uBACA,IACA,0CACA,KACA,wBACA,wCACA,aAEA,iBACA,qBACA,iEACA,IACA,wBACA,aACA,IACA,uBACA,6BACA,sBACA,eACA,cACA,EACA,CACA,wBACA,QACA,IACA,qBACA,CACA,QACC,kCC9CD,YACA,iBACA,KACA,mDACA,2BACE,eACF,sDACA,iBACA,UACA,WACA,MAAG,kCACH,iBACA,UACA,2EACA,+EACA,+EACA,+EACA,+EACA,+EACA,+EACA,+EACA,+EACA,SAEA,qDAzBA,IA0BA,wBACA,wBACA,aACA,YACA,qBACA,2MACA,0HACA,KACA,wBACA,2MACA,0HACA,KACA,gBACA,yBACA,iBACA,aAAkB,MAA6B,WAC/C,WACA,OACA,4CACA,UACA,CAAG,8BACH,+CACA,QACA,eACA,CACA,uBACA,iKACA,KACA,uBACA,yBACA,iBACA,aAAkB,MAAoC,WACtD,WACA,OACA,6CACA,WACA,CAAG,8BACH,+CACA,QACA,uBAEA,gBACA,CACA,mCACA,OACA,WAEA,iBACA,qBACA,iKACA,KACA,yBACA,OACA,UAEA,2HACA,2MAGA,WACA,0BACA,iDACA,kJAEA,8BACA,6IAGA,UACA,wBACA,SAGA,6QACA,KACA,qBACA,mBACA,eAAkB,EAAQ,IAC1B,cAAmB,EAAQ,IAC3B,iDAGA,yBACA,UACA,oBACA,WAAkB,EAAQ,IAC1B,cAAmB,EAAQ,IAC3B,SAGA,eACA,mBACA,aACA,aACA,sBACA,uBACA,6CACA,mBACA,uBACA,sCACA,mBACA,uBACA,sCACA,mBACA,KACA,IACA,qBACA,IACA,2BAEA,oCAAkB,EAAQ,IAC1B,cAAmB,EAAQ,IAC3B,8CACA,QAIA,SACA,QACA,iBACA,WAAiB,EAAO,IACxB,cAAkB,EAAO,IACzB,0BAGA,SACA,uBACA,yNACA,KACA,yBACA,uEACA,8FAEA,0EACA,8FAEA,8BACA,GAGA,4CACA,wBACA,QACA,IACA,qBACA,CACA,QACC,IACD,oBACA,mDACA,gCACA,mBAGA,gDAGA,kCAGA,8BAGA,0BAGA,0BAIA,CAAE,iEACF,gCACA,SACA,kBACA,UACA,GACA,oBACA,sBAIA,oCCjNA,YACA,QACA,cACA,qBACA,qBACA,QACA,eACA,0BACA,iDACA,mCAVA,IAWA,wBACA,0BACA,aACA,GACA,qBACA,oCACA,mCACA,QACA,QACA,qBACA,oCACA,mCACA,QACA,QACA,sCACA,yBACA,8DACA,2GACA,KAAG,8BACH,4FACA,cACA,4CACA,KAEA,wCACA,oBACA,aACA,GACA,gBACA,iDAEA,wCACA,gBACA,iDAEA,uCACA,CACA,8BACA,0DACA,OACA,4BACA,aACA,UACA,iCACA,WAAiB,2BAAgC,EACjD,cAAkB,wBAA+B,EACjD,SAGA,kCACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCCjED,kDADA,IAEA,wBACA,iCACA,OACA,OACA,cACA,WACA,YACA,2BACA,SACA,GAAG,kBACH,WACA,cACA,QACA,4BACA,iCACA,QACA,cACA,2BACA,eACA,MACA,GACA,UACA,CACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,wBACA,gCACA,QAAgB,MAAkB,OAClC,kBAEA,WACA,wCCtCA,YACA,6BACA,qBAAgB,EAAO,IACvB,cAAiB,EAAO,IACxB,wBAGA,uCARA,GASA,wBACA,uBACA,aACA,YACA,0BACA,MACA,cACA,mBACA,yBACA,WAAkB,EAAO,IACzB,cAAmB,EAAO,IAC1B,wCAGA,SACA,QAAG,yBACH,iBACA,gCACA,UAAG,yBACH,gCACA,gCACA,UACA,CACA,sBACA,WAAiB,EAAO,IACxB,uBACA,sBACA,0CACA,YACA,aAAmB,IAAO,IAC1B,MACA,0BACA,QAEA,cAEA,CACA,sBACA,qDACA,KACA,2BACA,iCACA,aACA,QACA,qBACA,iGACA,EACA,gBACA,yBACA,iBACA,aAAkB,EAAO,IACzB,cAAmB,IAAO,IAC1B,QACA,4CACA,iBACA,gCACO,wCAIP,mBAAG,8BACH,+CACA,0BACA,cACA,CACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,6BACA,yBACA,mBACA,IACA,YACA,8CC/EA,YACA,gBACA,uBACA,mBACA,mBACA,UACA,kCACA,gCACA,qBACA,EAAE,8BACF,8DACA,QACA,cACA,oCACA,oBACA,6EAhBA,GAiBA,wBACA,mBACA,kCACA,iBACA,eAAsC,eACtC,eACA,sBAEA,iBAAG,sCACH,iBACA,SACA,OACA,KACA,2BACA,gBAEA,eAAkB,MAAgB,OAClC,yCACA,8CAEA,uCACA,aAEA,UACA,CACA,kBACA,kCACA,iBACA,uBACA,YAAsC,eACtC,eACA,sDAEA,YACA,QAAG,iCACH,iBACA,kCACA,QAAkB,MAAgB,OAClC,8GAEA,aACA,wBACA,QACA,CACA,+BACA,iBACA,YACA,+BACA,mBACA,qBAEA,4BADA,YAEA,0BACA,IACA,6BACA,sBACA,eACA,wBACA,QACA,IACA,qBACA,CACA,QACC,kCC5ED,YACA,UACA,cACA,uBACA,iBACA,wBACA,2BACA,qBACA,QACA,kBACA,cACA,yCACA,kHAbA,KAcA,wBACA,6BACA,WACA,2BACA,WACA,GACA,YAAG,SACH,gBACA,OACI,sBACJ,QAAG,SACH,CACA,+BACA,oCACA,iBACA,yBACA,YACA,oCACA,iCACA,qBACA,yCACA,UACA,2BACA,qCACA,kBACA,0BACA,+BACA,kCACA,iBACA,eAAkC,eAClC,eACA,YAEA,qBAAG,oCACH,iBACA,eACA,mBAAkB,MAAiB,WACnC,2CACA,0BAEA,iCAEA,OACA,CACA,CACA,0BACA,MACA,kCACA,4CACA,kCACA,IACA,sCACA,aAAmC,aAAc,WACjD,SACA,0CACA,wBACA,OACA,CACA,wBACA,QACA,IACA,qBACA,CACA,QACC,kCCrFD,YACA,aACA,sBACA,qBACA,QACA,mDANA,IAOA,wBACA,yCACA,IACA,gDAA4C,aAAa,WACzD,SACA,WACA,8DACA,mEACA,YACG,8BACH,gCACA,eAAsC,aACtC,uBACA,WACA,mBAAmB,aAAoB,EACvC,uFAGA,UACA,CACA,uCACA,IACA,gDAA4C,eAAa,WACzD,KACA,kCAA6C,eAC7C,eACA,YAEA,+BACG,8BACH,gCACA,eACA,qBACA,mBAAmB,aAAsB,EACzC,cAAoB,aAAsB,EAC1C,SAGA,mCAAG,8BACH,8DACA,yBACA,cACA,2CACA,OACA,2CACA,eACA,sCACA,uHACA,6EAGA,MACA,CACA,uBACA,MACA,qCACA,kCACA,gBACA,2BACA,IACA,gDAA4C,eAC5C,eACA,YAEG,+CACH,iBACA,eACA,mBAAkB,aAAoB,EACtC,uCAEA,GACA,CACA,yCACA,WAAiB,QAA6B,qBAC9C,WACA,+CAEA,SACA,QACA,+BACA,qFACA,SACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,6CC9FA,YACA,UACA,cACA,sBACA,oBACA,oBACA,oBACA,uBACA,gBACA,gBACA,gBACA,gBACA,8BACA,oBACA,mDACA,WACA,mBACA,WACA,oBACA,yBACA,iCACA,sDACA,sBACA,uBAEA,4BACA,gDA3BA,GA4BA,wBACA,+BACA,eACA,aACA,aACA,aACA,oDACA,aACA,oBACA,+BAEA,0BADA,4BAEA,yBACA,OACA,iBACA,iBACA,iBACA,iBACA,4CACA,+CACA,+CACA,+CACA,MACA,0BACA,mCACA,8CACA,kCACA,qDACA,WACA,mBACA,iBACA,aACA,0BACA,aACA,WACA,0BACA,kBACA,oBACA,EACA,4BACA,yBACA,wCACA,mHACA,IACA,aACA,QACA,sCACA,uEACA,cACA,oFACA,cACA,oFACA,cACA,mFACA,eAEA,kBACA,yCACA,IACA,MACA,2EACA,cACA,6EACA,cACA,4CACA,oEACA,cACA,2CACA,oEACA,eACA,YACA,sBACA,sBAEA,KACA,8BACA,SACA,qCACA,gBACA,yCAIA,sBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,+DCtHA,YACA,aACA,qBACA,QACA,SA6BA,YACA,WACA,qBACA,sBACA,+BACA,UACA,8DACA,QACA,iBACA,mBACA,sEA5CA,GAMA,wBACA,gBACA,yBACA,iBACA,4BACA,EAAG,yBACH,+CACA,WACA,oBACA,wCACA,uBACA,QACA,IACA,uBAEA,GACA,WAEA,MACA,aACA,CACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IAYD,mBACA,wBACA,uBACA,aACA,YACA,mBACA,sEACA,gCACA,WACA,gBACA,mFAEA,uCACA,mBAAG,6CACH,UACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,qDCrEA,YACA,yBACA,0BAHA,IAIA,wBACA,kBACA,yBACA,WACA,EAAG,8BACH,gCACA,2BACA,kCACA,gBACA,CACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCClBD,YACA,UACA,iCACA,qBACA,QACA,qCACA,kCAPA,GAQA,wBACA,uCACA,uBACA,cACA,2CACA,OACA,2CACA,eACA,sCACA,qDACA,WAA0B,aAA0C,qBACpE,6CAEA,kDACA,iCACA,EAEA,CACA,mBACA,CACA,QACA,qCACA,aACA,sBACA,wBACA,QACA,IACA,qBACA,CACA,QACC,4ECnCD,KAKM,eAAc,IAOlB,CAAY,cACV,OAAM,OAAO,OACX,OACA,kBACA,0BAAO,EAEV,MAMD,CAAuB,yBACrB,OACA,+BAAM,GAAS,GAEf,SAAK,GAAI,GAAI,EAAG,EAAI,EAAS,OAAQ,GAAK,EACxC,MAAM,GAAO,EAAO,KAAK,EAAS,GAClC,eAAM,EAAY,EAAO,KAAc,KACvC,eAAM,EAAY,IAClB,aAAS,GAAG,YAAY,EACxB,UAAS,KAAG,YACb,KACF,CAGH,EAAe,oCCxCf,4CADA,IAEA,wBACA,uBACA,CACA,QACA,qBACA,CACA,QACC,IACD,qBACA,6BACA,0EACA,sCACA,+BACA,MACA,UACA,gCACA,oDACA,sCChBA,YACA,sBACA,0BACA,eACA,oCACA,cACA,gBACA,UACA,sEATA,IAUA,wBACA,qBACA,UACA,0BACA,gBACA,QACA,8BACA,cACA,qBACA,oBACA,oBACA,MAGA,4CAFA,6CACA,SAEA,2BACA,CAEA,iBADA,kBAEA,+BACA,sBACA,8BACA,kBACA,gBACA,wBACA,GACA,2BAEA,8BACA,iCACA,8EACA,GACA,kBACA,YACA,8CACA,gBACA,QACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,2BACA,OACA,oBACA,sBACA,qBACA,4BACA,QACA,4BACA,4BACA,eACA,6BACA,4BACA,gBACA,0BACA,4BACA,2CChEA,YACA,eACA,qBACA,QACA,WA+EA,YACA,cACA,0BACA,mBACA,UACA,oCACA,gCACA,QACA,sBACA,UAAE,8BACF,+CACA,QACA,sBACA,gBACA,aACA,gFAnGA,GAMA,wBACA,qBACA,YACA,8BACA,mCACA,SACA,0BACA,0CACA,YACA,iCACA,UACA,IAIA,wBAHA,kBAEA,KAEA,kCACA,YACA,+BAEA,SADA,EAEA,sCACA,cACA,SACA,mBAAiB,MAAgB,OACjC,UAEA,+BACA,MACA,yCACA,eACA,YAAiB,eAAoB,EACrC,wBACA,UAEA,KACA,QACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,sBACA,iBACA,QACA,gBACA,kBACA,SAEA,uBADA,SAEA,wCACA,yBACA,iBACA,WACA,qCACA,+CACA,0BACA,YACA,IACA,CACA,QAAE,yBACF,gCACA,+CACA,+BACA,GACA,2CACA,SACA,0CACA,kBACA,sBACA,UACA,4BACA,OACA,kBACA,iBACA,6BAiBA,mBACA,wBACA,uBACA,sBACA,+DACA,eACA,SACA,kCACA,SACA,2CACA,8DACA,SACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCClHD,YACA,iBACA,mBACA,UACA,4BACA,wCACA,6BACA,oHARA,IASA,wBACA,2BACA,8DACA,2BACA,8BACA,IACA,mCACA,oEACA,mBACA,OAAiB,QAA+B,qBAChD,kCACA,qCAGA,iCACA,QAEA,oDACA,sBACA,wBACA,SACA,wBAEA,gBACA,sCACA,qDACA,SACA,6BACA,aACA,UACA,sCACA,cACA,OAAiB,QAA6B,mBAC9C,iCACA,mBACA,YACA,aAEA,4BACA,gBACA,kCACA,aACA,OACA,iCACA,mEACA,2BACA,iCACA,cACA,OAAiB,QAA6B,mBAC9C,4BACA,mBACA,YACA,aAEA,4BACA,gBACA,mCACA,cACA,OAAiB,QAA6B,mBAC9C,8BACA,mBACA,YACA,aAEA,4BACA,gBACA,kBACA,UACA,MACA,yCACA,cACA,OAAiB,QAA6B,mBAC9C,uBACA,iBACA,sCACA,aAEA,8FACA,kCACA,gBACA,uBACA,SACA,6BACA,2DACA,4DACA,4DACA,4DACA,iEACA,yDACA,8DACA,oEACA,8DACA,UACA,iCACA,mCACA,6EACA,cACA,0DACA,kCACA,mBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCCxHD,YACA,SACA,8BACA,kBACA,UACA,uCACA,uEACA,gCACA,iBACA,mBAAE,qEACF,gCACA,QACA,2BACA,iBACA,gBACA,sDAhBA,IAiBA,wBACA,2BACA,uCACA,SAAiB,EAAS,QAC1B,SACA,cACA,uBACA,sBACA,oDAEA,SACA,CACA,iCACA,WAAiB,MAAoB,WACrC,2BACA,oDACA,KACA,OACA,KACA,oBACA,oBACA,cACA,uBACA,0BACA,oBACA,QACA,4BACA,uBACA,cACA,iDACA,aAAiB,EAAqB,QACtC,OACA,YACA,4BACA,mBAEA,WACA,CACA,sCACA,eACA,aACA,IAAiB,aAA0B,MAC3C,mBACA,4BACA,0CACA,mDAAsD,qBAEtD,kBACA,mCACA,MACA,IAEA,IACA,CACA,QACA,8CACA,MACA,gCACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,sBACA,SACA,uCACA,mCCrFA,YACA,mBACA,oBACA,MA+BA,YACA,sBACA,0BACA,KAgBA,YACA,YACA,qBACA,QACA,qDA1DA,IAKA,wBACA,0BACA,kBACA,gBACA,WACA,iBACA,8BACA,qDACA,4BACA,qBACA,SACA,QACA,SAGA,SAFA,WACA,mBAEA,gCACA,aACA,YACA,iBACA,cACA,4CACA,qBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IAKD,wBACA,mBACA,yBACA,2BACA,EACA,gCACA,gEACA,YACA,wBACA,QACA,IACA,qBACA,CACA,QACC,IAMD,wBACA,qBACA,qCACA,kCACA,kBACA,qBACA,IACA,mBACA,CACA,QACA,8BACA,CACA,QACA,wBACA,QACA,IACA,qBACA,CACA,QACC,IACD,2BACA,6CCjFA,YACA,MACA,0CACA,uBACA,yBACA,mCANA,GAOA,wBACA,qBACA,kCACA,YACA,iBACA,WACA,4BACA,qBACA,qDACA,kBACA,YAEA,aACA,+BACA,sFAKA,6EACA,8CALA,wBACA,MAEA,KAGA,qBACA,yBACA,iBACA,aACA,0BACA,oBACA,4FACA,+EACA,KACA,QACA,CACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,sBACA,YACA,SACA,mBAEA,kBACA,KACA,yBACA,iBACA,IACA,6BACA,OACA,SACA,SACA,SACA,KAEA,YACA,wBACA,EACA,OACA,CACA,UACA,4CACA,WACA,IAAiB,GAAQ,SACzB,kCACA,SACA,GACA,OACA,mCC1EA,YACA,UACA,qBACA,sBACA,4DALA,GAMA,wBACA,sBACA,UACA,YACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,8BACA,cACA,SAA+B,eAC/B,eACA,uBAEA,qBACA,UACA,wBACA,OACA,WACA,4CC1BA,YACA,WACA,gBACA,oCACA,QACA,YACA,qDAPA,KAQA,wBACA,0BACA,aACA,IACA,iBACA,kBACA,MACA,2BACA,aACA,OACA,qBACA,uDACA,GACA,8BACA,gCACA,wDACA,GACA,qBACA,MACA,OACA,oBACA,aACA,KACA,qBACA,sCACA,MACA,wBACA,QACA,IACA,qBACA,CACA,QACC,kCCtCD,YACA,aACA,sBACA,UACA,sCACA,UACA,4BACA,QACA,mEATA,KAUA,wBACA,mBACA,sCAEA,6BADA,IAEA,6BACA,qBACA,kBACA,oBACA,aACA,eACA,QACA,qCACA,MACA,uBACA,uCACA,MACA,sCACA,+CACA,gCACA,qCACA,6BACA,0BACA,8BACA,YAEA,IACA,uBACA,SACA,2EACA,0BACA,4BACA,wBACA,4CACA,oIACA,GACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,kCACA,OACA,kBACA,8BACA,YACA,kDC5DA,YACA,MACA,8BACA,oCACA,gCACA,uBACA,4BACA,6BACA,OACA,sCACA,QACA,iCACA,kCAbA,GAcA,wBACA,mCACA,aACA,qBACA,qCACA,MACA,yBACA,oCACA,aACA,YACA,kBACA,aACA,kBACA,6BACA,aACA,cACA,qCACA,MACA,uBACA,kCACA,MACA,oBACA,wCACA,8DACA,4BACA,sCACA,oCACA,8BACA,KACA,SACA,2CACA,OACA,2CACA,YACA,sCACA,4BACA,yDACA,wBACA,uBACA,uBACA,uBACA,yDACA,yDACA,4BAGA,qBACA,4BACA,SACA,uBAEA,EACA,4BACA,OACA,kCACA,mBACA,aACA,uBACA,iCACA,wBACA,QACA,IACA,qBACA,CACA,QACC,IACD,0CACA,OACA,SAEA,SADA,+BAEA,yCACA,OACA,WACA,uCACA,OACA,SAGA,SAFA,8BACA,0DC3FA,YACA,aACA,qBACA,QACA,sCALA,GAMA,wBACA,gBACA,cACA,OAAiB,QAA2B,mBAC5C,wBACA,gCAEA,0DACA,mBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,mBACA,OACA,kBACA,sCCvBA,YACA,UACA,2BACA,qBACA,4BACA,6BACA,mDACA,QACA,WACA,wBACA,gDAXA,IAYA,wBACA,yBACA,6CAA6D,eAC7D,eACA,qCACA,uDAEA,eACA,iCACA,yDACA,gCACA,gBACA,mBACA,aACA,4BACA,qBACA,mBACA,eACA,iCACA,SACA,eACA,YACA,wDACA,gBACA,SAGA,mBACA,iCACA,0CAA8D,eAC9D,eACA,oBAEA,mEAA6D,aAAc,WAC3E,SACA,WACA,+CACA,+BACA,mBACA,aACA,CACA,CACA,gCACA,aAAqC,aAAc,WACnD,SACA,WACA,aACA,oDAAsD,4BAEtD,GACA,CACA,uBACA,+BAA+C,aAAc,WAC7D,SACA,WACA,sDACA,uCACA,SACA,eACA,CACA,0CACA,SACA,iCACA,mBACA,4BACA,8BACA,8EACA,6CACA,uBACA,aAEA,oBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCC1FD,YACA,UACA,2BACA,8BACA,mDACA,QACA,WACA,+CARA,IASA,wBACA,qCACA,SACA,8CACA,6BACA,qCACA,MACA,CACA,0CACA,0CAA8D,eAC9D,kBACA,UACA,iBACA,+EACA,SACA,eACA,wBAEA,2BAEA,CACA,mBACA,aACA,qCACA,gBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCCtCD,YACA,gBACA,gCACA,eACA,0BACA,iBACA,kCACA,wCACA,2BAEA,IAAE,8BACF,gCACA,uBACA,sBAAE,8BACF,+CACA,4FAA0H,oDAC1H,yCACA,2BACA,4BACA,MACA,wCArBA,IAsBA,wBACA,2BACA,qBACA,aACA,qCACA,MACA,wDACA,sBACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCCXD,YACA,cACA,uBACA,0BACA,4BACA,UACA,gDACA,yBACA,UACA,uCACA,yBACA,wBACA,0BACA,gCACA,uBACA,sBAAE,8BACF,+CACA,QACA,iBACA,mBACA,oBACA,eAEA,MACA,qOAzBA,IA0BA,mBACA,wBACA,kCACA,mBACA,eACA,aACA,QACA,2BACA,sBACA,mCACA,uBACA,gBACA,6BACA,yBACA,gCACA,eACA,wBAAG,yBACH,+CACA,YACA,gBACA,mCACA,0HACA,UACA,GAGA,mCAFA,+CACA,YAEA,CACA,+BACA,uBAAsC,eACtC,eACA,gBAEA,gBACA,0CACA,UACA,0DACA,+BACA,2BAEA,4CADA,WAEA,wBACA,aACA,WACA,gCACA,aACA,iBACA,4BACA,aACA,gBACA,qBACA,+BACA,iBACA,WACA,sDACA,SAAG,oCACH,iBACA,yCACA,SACA,CACA,wBACA,0DACA,oBAAiB,QAA4B,qBAC7C,QACA,2DAEA,SACA,qBACA,MACA,sBACA,0DACA,4DACA,SACA,2BACA,kCACA,qBACA,uBACA,yCACA,GAEA,gDACA,6BACA,cACA,qCACA,gFACA,uDACA,GACA,4BACA,aACA,aACA,8BACA,gBACA,0CACA,QACA,MAAgC,eAChC,eACA,gCAEA,OACA,QACA,6BACA,2FACA,iBACA,cACA,yCACA,iCACA,oEAAiH,8BACjH,mBACA,gCACA,sBACA,uCACA,qBACA,uBACA,yCACA,GAEA,QACA,KACA,QACA,WACA,IAEA,gDACA,iCACA,cACA,uDACA,SACA,6BACA,mBACA,eACA,WACA,qBACG,YACH,gBACA,qCACA,WACA,IACA,sCACA,uBAAsC,aACtC,uBACA,sBACA,0BAAuC,eACvC,eACA,wCAGA,QACA,gBACA,qDACA,iBACA,wBACA,iCACA,wDAAgD,4CAAyD,+CAA+C,0CAAyD,+CAA8D,+CAA2D,+CAAiE,2EAC3Y,UAAG,0CACH,UACA,2BACA,WAAiB,QAA2B,mBAC5C,QACA,qBAEA,MACA,oBACA,2CACA,wCACA,8DAEA,kCAEA,yCACA,YACA,qBACA,qDACA,iBACA,4BACA,MAAG,0CACH,UACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,iCACA,2CACA,wCCpOA,YACA,WACA,qBACA,oBACA,2FALA,IAMA,mBACA,wBACA,yBACA,eACA,kBAAiB,kBAAwB,OACzC,kBACA,SACA,+BAGA,sBACA,iCACA,yBACA,iBACA,kBACA,OACA,0BAAkB,kBAAwB,uBAE1C,SACA,qCAEA,8BAIA,UARA,KAQG,SACH,iHACA,+CACA,QACA,mBACA,mBACA,uBAAI,mGACJ,+CACA,qBAAoD,WACpD,iBACA,uBAEA,CACA,uBACA,aACA,2BACA,oBAAiB,aAA2B,MAC5C,UACA,wBACA,0BACA,iCACA,cACA,CACA,mCACA,aACA,YAAqB,MAAS,IAC9B,qBACA,oBACA,SACA,cACA,mBACA,+BAEA,YAEA,CACA,qBACA,yBACA,iBACA,eAAiC,eACjC,eACA,YAEA,YAAG,8BACH,gCACA,eAAiC,eACjC,eACA,YAEA,YACA,CACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCChGD,YACA,UACA,qBACA,oCACA,QACA,WACA,2BAPA,GAQA,wBACA,mCACA,4DACA,aACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCChBD,YACA,gBACA,kBACA,qBACA,uBACA,4BACA,eACA,0BACA,gCACA,qBACA,YACA,eACA,cAAE,8BACF,+CACA,qBACA,YACA,cACA,eACA,MACA,uBApBA,GAqBA,wBACA,oBACA,4BACA,MACA,iCACA,MACA,mBACA,sBACA,aACA,IACA,uBACA,IACA,oCACA,yBACA,gCACA,+BACA,EACA,CACA,2BACA,aACA,YACA,qBACA,4BACA,MACA,yBACA,OACA,qCACA,MACA,gCACA,aACA,iBACA,wBACA,QACA,IACA,qBACA,CACA,QACC,IACD,WACA,yCC5DA,4BADA,GAEA,wBACA,uBACA,CACA,QACA,qBACA,CACA,QACC,kCCGD,YACA,aACA,qBACA,4DACA,wDACA,SAeA,YACA,eACA,qBACA,QACA,WAaA,YACA,gBACA,qBACA,QACA,+GA1CA,IAOA,wBACA,mBACA,UACA,UACA,wCACA,OACA,aACA,wBACA,QACA,IACA,qBACA,CACA,QACC,IAMD,wBACA,sBACA,IACA,mEACA,GACA,wBACA,QACA,IACA,qBACA,CACA,QACC,IAMD,wBACA,iBACA,eACA,gBAAgC,aAAa,WAC7C,SACA,WACA,sBACA,UACA,CACA,qBACA,WAAiB,MAAgB,WACjC,sBACA,sBACA,mBACA,eACA,aACA,CACA,kBACA,yBACA,gCACA,YACA,wBACA,eACA,UAAG,yBACH,+CACA,eACA,YACA,CACA,wBACA,CACA,QACA,qBACA,CACA,QACC,IACD,mBACA,0DCjFA,YACA,iBACA,gBACA,iBACA,8EALA,KAMA,wBACA,qBACA,+BACA,+BACA,UACA,UACA,OACA,SACA,0CACA,GACA,IACA,IACA,GACA,CACA,wBACA,sDACA,yEACA,YACA,uBACA,MACA,kBACA,YACA,sBACA,+CAEA,aADA,IAEA,uBACA,kFACA,SACA,iBACA,oCAEA,YADA,IAEA,0BACA,MACA,WACA,kBAAiB,MAAgB,YACjC,SACA,+BACA,QACA,WACI,WACJ,gCACA,MACA,MACA,CACA,CACA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCChED,YACA,WACA,iBACA,mDACA,QACA,YACA,YACA,qCARA,GASA,mBACA,wBACA,sBACA,mDAEA,OADA,IAEA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCCpBD,YACA,WACA,kBACA,iBACA,oCACA,QACA,cACA,2CACA,qCATA,GAUA,mBACA,wBACA,0BACA,sBACA,2BACA,KACA,uBACA,aACA,qDAGA,6CACA,cAFA,IAGA,wBACA,CACA,QACA,qBACA,CACA,QACC,kCCvBD,YACA,gBACA,UACA,8CACA,iBACA,QACA,QAAE,8BACF,gCACA,QACA,cACA,uBACA,sEAZA,GAaA,wBACA,mBACA,iDACA,yCACA,4CACA,OACA,IACA,+BACA,MACA,kCACA,MACA,uBACA,wBACA,QACA,IACA,qBACA,CACA,QACC,IACD,wBACA,yBACA,iBACA,yCACA,YAAE,yBACF,gCACA,yCACA,cACA,GACA,qBACA,yBACA,iBACA,YACA,cAAE,yBACF,iEACA,gCACA,eAAiC,eACjC,eACA,SAEA,cACA,QAAG,+DACH,gCACA,YACA,KAEA,eADA,aACG,8DACH,gCACA,GAMA,mBALA,OAEA,eAEA,WAEA,CAAE,8BACF,iGACA,+CACA,eAAiC,eACjC,eACA,SAEA,gBACA,QAAG,8FACH,+CACA,GAEA,eADA,aAEA,CACA,iCCrFA,YACA,gBACA,kCAHA,GAIA,wBACA,sBACA,aACA,MACA,qBACA,aACA,MACA,wBACA,QACA,IACA,qBACA,CACA,QACC,oCCnBoB,KAInB,OAAgB,YAEd,SAED,QARuB,gBCA1B,UAAqC,4pJCKrC,KAKM,eAAqB,IAOzB,CAAY,cACV,OAAM,OAAO,OACX,OACA,yBACA,iCAAO,EAEV,MAMD,CAAuB,yBACrB,UAEA,4BAIA,CAJI,GAAS,cAIP,GAAS,GAEf,SAAK,GAAI,GAAI,EAAG,EAAI,EAAS,OAAQ,GAAK,EACxC,MAAM,GAAO,EAAO,KAAK,EAAS,GAClC,eAAM,EAAY,EAAO,KAAc,KACvC,eAAM,EAAgB,IACtB,oBAAS,GAAG,YAAY,EACxB,UAAS,KAAG,YACb,KACF,EAGH,EAAe,mBChDf,UAAqC,4zICKrC,KAKM,eAAmB,IAOvB,CAAY,cACV,OAAM,OAAO,OACX,OACA,uBACA,+BAAO,EAEV,MAMD,CAAuB,yBACrB,UAEA,4BAIA,CAJI,GAAS,cAIP,GAAS,GAEf,SAAK,GAAI,GAAI,EAAG,EAAI,EAAS,OAAQ,GAAK,EACxC,MAAM,GAAO,EAAO,KAAK,EAAS,GAClC,eAAM,EAAY,EAAO,KAAc,KACvC,eAAM,EAAW,IACjB,kBAAS,GAAG,YAAY,EACxB,UAAS,KAAG,YACb,KACF,EAGH,EAAe,mBChDf,UAAqC","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ole\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ole\"] = factory();\n\telse\n\t\troot[\"ole\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","import Double from '../../../../java/lang/Double';\nimport extend from '../../../../extend';\nexport default function MathUtil() {}\nextend(MathUtil.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn MathUtil;\n\t}\n});\nMathUtil.log10 = function (x) {\n\tvar ln = Math.log(x);\n\tif (Double.isInfinite(ln)) return ln;\n\tif (Double.isNaN(ln)) return ln;\n\treturn ln / MathUtil.LOG_10;\n};\nMathUtil.min = function (v1, v2, v3, v4) {\n\tvar min = v1;\n\tif (v2 < min) min = v2;\n\tif (v3 < min) min = v3;\n\tif (v4 < min) min = v4;\n\treturn min;\n};\nMathUtil.clamp = function () {\n\tif (typeof arguments[2] === \"number\" && (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\")) {\n\t\tlet x = arguments[0], min = arguments[1], max = arguments[2];\n\t\tif (x < min) return min;\n\t\tif (x > max) return max;\n\t\treturn x;\n\t} else if (Number.isInteger(arguments[2]) && (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1]))) {\n\t\tlet x = arguments[0], min = arguments[1], max = arguments[2];\n\t\tif (x < min) return min;\n\t\tif (x > max) return max;\n\t\treturn x;\n\t}\n};\nMathUtil.wrap = function (index, max) {\n\tif (index < 0) {\n\t\treturn max - -index % max;\n\t}\n\treturn index % max;\n};\nMathUtil.max = function () {\n\tif (arguments.length === 3) {\n\t\tlet v1 = arguments[0], v2 = arguments[1], v3 = arguments[2];\n\t\tvar max = v1;\n\t\tif (v2 > max) max = v2;\n\t\tif (v3 > max) max = v3;\n\t\treturn max;\n\t} else if (arguments.length === 4) {\n\t\tlet v1 = arguments[0], v2 = arguments[1], v3 = arguments[2], v4 = arguments[3];\n\t\tvar max = v1;\n\t\tif (v2 > max) max = v2;\n\t\tif (v3 > max) max = v3;\n\t\tif (v4 > max) max = v4;\n\t\treturn max;\n\t}\n};\nMathUtil.average = function (x1, x2) {\n\treturn (x1 + x2) / 2.0;\n};\nMathUtil.LOG_10 = Math.log(10);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/math/MathUtil.js\n// module id = 66\n// module chunks = 0","import extend from '../../../../../extend';\nexport default function BufferParameters() {\n\tthis._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;\n\tthis._endCapStyle = BufferParameters.CAP_ROUND;\n\tthis._joinStyle = BufferParameters.JOIN_ROUND;\n\tthis._mitreLimit = BufferParameters.DEFAULT_MITRE_LIMIT;\n\tthis._isSingleSided = false;\n\tthis._simplifyFactor = BufferParameters.DEFAULT_SIMPLIFY_FACTOR;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet quadrantSegments = arguments[0];\n\t\tthis.setQuadrantSegments(quadrantSegments);\n\t} else if (arguments.length === 2) {\n\t\tlet quadrantSegments = arguments[0], endCapStyle = arguments[1];\n\t\tthis.setQuadrantSegments(quadrantSegments);\n\t\tthis.setEndCapStyle(endCapStyle);\n\t} else if (arguments.length === 4) {\n\t\tlet quadrantSegments = arguments[0], endCapStyle = arguments[1], joinStyle = arguments[2], mitreLimit = arguments[3];\n\t\tthis.setQuadrantSegments(quadrantSegments);\n\t\tthis.setEndCapStyle(endCapStyle);\n\t\tthis.setJoinStyle(joinStyle);\n\t\tthis.setMitreLimit(mitreLimit);\n\t}\n}\nextend(BufferParameters.prototype, {\n\tgetEndCapStyle: function () {\n\t\treturn this._endCapStyle;\n\t},\n\tisSingleSided: function () {\n\t\treturn this._isSingleSided;\n\t},\n\tsetQuadrantSegments: function (quadSegs) {\n\t\tthis._quadrantSegments = quadSegs;\n\t\tif (this._quadrantSegments === 0) this._joinStyle = BufferParameters.JOIN_BEVEL;\n\t\tif (this._quadrantSegments < 0) {\n\t\t\tthis._joinStyle = BufferParameters.JOIN_MITRE;\n\t\t\tthis._mitreLimit = Math.abs(this._quadrantSegments);\n\t\t}\n\t\tif (quadSegs <= 0) {\n\t\t\tthis._quadrantSegments = 1;\n\t\t}\n\t\tif (this._joinStyle !== BufferParameters.JOIN_ROUND) {\n\t\t\tthis._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;\n\t\t}\n\t},\n\tgetJoinStyle: function () {\n\t\treturn this._joinStyle;\n\t},\n\tsetJoinStyle: function (joinStyle) {\n\t\tthis._joinStyle = joinStyle;\n\t},\n\tsetSimplifyFactor: function (simplifyFactor) {\n\t\tthis._simplifyFactor = simplifyFactor < 0 ? 0 : simplifyFactor;\n\t},\n\tgetSimplifyFactor: function () {\n\t\treturn this._simplifyFactor;\n\t},\n\tgetQuadrantSegments: function () {\n\t\treturn this._quadrantSegments;\n\t},\n\tsetEndCapStyle: function (endCapStyle) {\n\t\tthis._endCapStyle = endCapStyle;\n\t},\n\tgetMitreLimit: function () {\n\t\treturn this._mitreLimit;\n\t},\n\tsetMitreLimit: function (mitreLimit) {\n\t\tthis._mitreLimit = mitreLimit;\n\t},\n\tsetSingleSided: function (isSingleSided) {\n\t\tthis._isSingleSided = isSingleSided;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn BufferParameters;\n\t}\n});\nBufferParameters.bufferDistanceError = function (quadSegs) {\n\tvar alpha = Math.PI / 2.0 / quadSegs;\n\treturn 1 - Math.cos(alpha / 2.0);\n};\nBufferParameters.CAP_ROUND = 1;\nBufferParameters.CAP_FLAT = 2;\nBufferParameters.CAP_SQUARE = 3;\nBufferParameters.JOIN_ROUND = 1;\nBufferParameters.JOIN_MITRE = 2;\nBufferParameters.JOIN_BEVEL = 3;\nBufferParameters.DEFAULT_QUADRANT_SEGMENTS = 8;\nBufferParameters.DEFAULT_MITRE_LIMIT = 5.0;\nBufferParameters.DEFAULT_SIMPLIFY_FACTOR = 0.01;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/operation/buffer/BufferParameters.js\n// module id = 57\n// module chunks = 0","import NotRepresentableException from './NotRepresentableException';\nimport Coordinate from '../geom/Coordinate';\nimport extend from '../../../../extend';\nimport Orientation from './Orientation';\nimport CGAlgorithmsDD from './CGAlgorithmsDD';\nimport System from '../../../../java/lang/System';\nimport HCoordinate from './HCoordinate';\nimport Envelope from '../geom/Envelope';\nimport inherits from '../../../../inherits';\nimport Distance from './Distance';\nimport LineIntersector from './LineIntersector';\nexport default function RobustLineIntersector() {\n\tLineIntersector.apply(this);\n}\ninherits(RobustLineIntersector, LineIntersector);\nextend(RobustLineIntersector.prototype, {\n\tisInSegmentEnvelopes: function (intPt) {\n\t\tvar env0 = new Envelope(this._inputLines[0][0], this._inputLines[0][1]);\n\t\tvar env1 = new Envelope(this._inputLines[1][0], this._inputLines[1][1]);\n\t\treturn env0.contains(intPt) && env1.contains(intPt);\n\t},\n\tcomputeIntersection: function () {\n\t\tif (arguments.length === 3) {\n\t\t\tlet p = arguments[0], p1 = arguments[1], p2 = arguments[2];\n\t\t\tthis._isProper = false;\n\t\t\tif (Envelope.intersects(p1, p2, p)) {\n\t\t\t\tif (Orientation.index(p1, p2, p) === 0 && Orientation.index(p2, p1, p) === 0) {\n\t\t\t\t\tthis._isProper = true;\n\t\t\t\t\tif (p.equals(p1) || p.equals(p2)) {\n\t\t\t\t\t\tthis._isProper = false;\n\t\t\t\t\t}\n\t\t\t\t\tthis._result = LineIntersector.POINT_INTERSECTION;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._result = LineIntersector.NO_INTERSECTION;\n\t\t} else return LineIntersector.prototype.computeIntersection.apply(this, arguments);\n\t},\n\tnormalizeToMinimum: function (n1, n2, n3, n4, normPt) {\n\t\tnormPt.x = this.smallestInAbsValue(n1.x, n2.x, n3.x, n4.x);\n\t\tnormPt.y = this.smallestInAbsValue(n1.y, n2.y, n3.y, n4.y);\n\t\tn1.x -= normPt.x;\n\t\tn1.y -= normPt.y;\n\t\tn2.x -= normPt.x;\n\t\tn2.y -= normPt.y;\n\t\tn3.x -= normPt.x;\n\t\tn3.y -= normPt.y;\n\t\tn4.x -= normPt.x;\n\t\tn4.y -= normPt.y;\n\t},\n\tsafeHCoordinateIntersection: function (p1, p2, q1, q2) {\n\t\tvar intPt = null;\n\t\ttry {\n\t\t\tintPt = HCoordinate.intersection(p1, p2, q1, q2);\n\t\t} catch (e) {\n\t\t\tif (e instanceof NotRepresentableException) {\n\t\t\t\tintPt = RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2);\n\t\t\t} else throw e;\n\t\t} finally {}\n\t\treturn intPt;\n\t},\n\tintersection: function (p1, p2, q1, q2) {\n\t\tvar intPt = this.intersectionWithNormalization(p1, p2, q1, q2);\n\t\tif (!this.isInSegmentEnvelopes(intPt)) {\n\t\t\tintPt = new Coordinate(RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2));\n\t\t}\n\t\tif (this._precisionModel !== null) {\n\t\t\tthis._precisionModel.makePrecise(intPt);\n\t\t}\n\t\treturn intPt;\n\t},\n\tsmallestInAbsValue: function (x1, x2, x3, x4) {\n\t\tvar x = x1;\n\t\tvar xabs = Math.abs(x);\n\t\tif (Math.abs(x2) < xabs) {\n\t\t\tx = x2;\n\t\t\txabs = Math.abs(x2);\n\t\t}\n\t\tif (Math.abs(x3) < xabs) {\n\t\t\tx = x3;\n\t\t\txabs = Math.abs(x3);\n\t\t}\n\t\tif (Math.abs(x4) < xabs) {\n\t\t\tx = x4;\n\t\t}\n\t\treturn x;\n\t},\n\tcheckDD: function (p1, p2, q1, q2, intPt) {\n\t\tvar intPtDD = CGAlgorithmsDD.intersection(p1, p2, q1, q2);\n\t\tvar isIn = this.isInSegmentEnvelopes(intPtDD);\n\t\tSystem.out.println(\"DD in env = \" + isIn + \"  --------------------- \" + intPtDD);\n\t\tif (intPt.distance(intPtDD) > 0.0001) {\n\t\t\tSystem.out.println(\"Distance = \" + intPt.distance(intPtDD));\n\t\t}\n\t},\n\tintersectionWithNormalization: function (p1, p2, q1, q2) {\n\t\tvar n1 = new Coordinate(p1);\n\t\tvar n2 = new Coordinate(p2);\n\t\tvar n3 = new Coordinate(q1);\n\t\tvar n4 = new Coordinate(q2);\n\t\tvar normPt = new Coordinate();\n\t\tthis.normalizeToEnvCentre(n1, n2, n3, n4, normPt);\n\t\tvar intPt = this.safeHCoordinateIntersection(n1, n2, n3, n4);\n\t\tintPt.x += normPt.x;\n\t\tintPt.y += normPt.y;\n\t\treturn intPt;\n\t},\n\tcomputeCollinearIntersection: function (p1, p2, q1, q2) {\n\t\tvar p1q1p2 = Envelope.intersects(p1, p2, q1);\n\t\tvar p1q2p2 = Envelope.intersects(p1, p2, q2);\n\t\tvar q1p1q2 = Envelope.intersects(q1, q2, p1);\n\t\tvar q1p2q2 = Envelope.intersects(q1, q2, p2);\n\t\tif (p1q1p2 && p1q2p2) {\n\t\t\tthis._intPt[0] = q1;\n\t\t\tthis._intPt[1] = q2;\n\t\t\treturn LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (q1p1q2 && q1p2q2) {\n\t\t\tthis._intPt[0] = p1;\n\t\t\tthis._intPt[1] = p2;\n\t\t\treturn LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (p1q1p2 && q1p1q2) {\n\t\t\tthis._intPt[0] = q1;\n\t\t\tthis._intPt[1] = p1;\n\t\t\treturn q1.equals(p1) && !p1q2p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (p1q1p2 && q1p2q2) {\n\t\t\tthis._intPt[0] = q1;\n\t\t\tthis._intPt[1] = p2;\n\t\t\treturn q1.equals(p2) && !p1q2p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (p1q2p2 && q1p1q2) {\n\t\t\tthis._intPt[0] = q2;\n\t\t\tthis._intPt[1] = p1;\n\t\t\treturn q2.equals(p1) && !p1q1p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (p1q2p2 && q1p2q2) {\n\t\t\tthis._intPt[0] = q2;\n\t\t\tthis._intPt[1] = p2;\n\t\t\treturn q2.equals(p2) && !p1q1p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\treturn LineIntersector.NO_INTERSECTION;\n\t},\n\tnormalizeToEnvCentre: function (n00, n01, n10, n11, normPt) {\n\t\tvar minX0 = n00.x < n01.x ? n00.x : n01.x;\n\t\tvar minY0 = n00.y < n01.y ? n00.y : n01.y;\n\t\tvar maxX0 = n00.x > n01.x ? n00.x : n01.x;\n\t\tvar maxY0 = n00.y > n01.y ? n00.y : n01.y;\n\t\tvar minX1 = n10.x < n11.x ? n10.x : n11.x;\n\t\tvar minY1 = n10.y < n11.y ? n10.y : n11.y;\n\t\tvar maxX1 = n10.x > n11.x ? n10.x : n11.x;\n\t\tvar maxY1 = n10.y > n11.y ? n10.y : n11.y;\n\t\tvar intMinX = minX0 > minX1 ? minX0 : minX1;\n\t\tvar intMaxX = maxX0 < maxX1 ? maxX0 : maxX1;\n\t\tvar intMinY = minY0 > minY1 ? minY0 : minY1;\n\t\tvar intMaxY = maxY0 < maxY1 ? maxY0 : maxY1;\n\t\tvar intMidX = (intMinX + intMaxX) / 2.0;\n\t\tvar intMidY = (intMinY + intMaxY) / 2.0;\n\t\tnormPt.x = intMidX;\n\t\tnormPt.y = intMidY;\n\t\tn00.x -= normPt.x;\n\t\tn00.y -= normPt.y;\n\t\tn01.x -= normPt.x;\n\t\tn01.y -= normPt.y;\n\t\tn10.x -= normPt.x;\n\t\tn10.y -= normPt.y;\n\t\tn11.x -= normPt.x;\n\t\tn11.y -= normPt.y;\n\t},\n\tcomputeIntersect: function (p1, p2, q1, q2) {\n\t\tthis._isProper = false;\n\t\tif (!Envelope.intersects(p1, p2, q1, q2)) return LineIntersector.NO_INTERSECTION;\n\t\tvar Pq1 = Orientation.index(p1, p2, q1);\n\t\tvar Pq2 = Orientation.index(p1, p2, q2);\n\t\tif (Pq1 > 0 && Pq2 > 0 || Pq1 < 0 && Pq2 < 0) {\n\t\t\treturn LineIntersector.NO_INTERSECTION;\n\t\t}\n\t\tvar Qp1 = Orientation.index(q1, q2, p1);\n\t\tvar Qp2 = Orientation.index(q1, q2, p2);\n\t\tif (Qp1 > 0 && Qp2 > 0 || Qp1 < 0 && Qp2 < 0) {\n\t\t\treturn LineIntersector.NO_INTERSECTION;\n\t\t}\n\t\tvar collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0;\n\t\tif (collinear) {\n\t\t\treturn this.computeCollinearIntersection(p1, p2, q1, q2);\n\t\t}\n\t\tif (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {\n\t\t\tthis._isProper = false;\n\t\t\tif (p1.equals2D(q1) || p1.equals2D(q2)) {\n\t\t\t\tthis._intPt[0] = p1;\n\t\t\t} else if (p2.equals2D(q1) || p2.equals2D(q2)) {\n\t\t\t\tthis._intPt[0] = p2;\n\t\t\t} else if (Pq1 === 0) {\n\t\t\t\tthis._intPt[0] = new Coordinate(q1);\n\t\t\t} else if (Pq2 === 0) {\n\t\t\t\tthis._intPt[0] = new Coordinate(q2);\n\t\t\t} else if (Qp1 === 0) {\n\t\t\t\tthis._intPt[0] = new Coordinate(p1);\n\t\t\t} else if (Qp2 === 0) {\n\t\t\t\tthis._intPt[0] = new Coordinate(p2);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._isProper = true;\n\t\t\tthis._intPt[0] = this.intersection(p1, p2, q1, q2);\n\t\t}\n\t\treturn LineIntersector.POINT_INTERSECTION;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn RobustLineIntersector;\n\t}\n});\nRobustLineIntersector.nearestEndpoint = function (p1, p2, q1, q2) {\n\tvar nearestPt = p1;\n\tvar minDist = Distance.pointToSegment(p1, q1, q2);\n\tvar dist = Distance.pointToSegment(p2, q1, q2);\n\tif (dist < minDist) {\n\t\tminDist = dist;\n\t\tnearestPt = p2;\n\t}\n\tdist = Distance.pointToSegment(q1, p1, p2);\n\tif (dist < minDist) {\n\t\tminDist = dist;\n\t\tnearestPt = q1;\n\t}\n\tdist = Distance.pointToSegment(q2, p1, p2);\n\tif (dist < minDist) {\n\t\tminDist = dist;\n\t\tnearestPt = q2;\n\t}\n\treturn nearestPt;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/algorithm/RobustLineIntersector.js\n// module id = 24\n// module chunks = 0","import Long from './Long';\n\nexport default function Double () {}\n\nDouble.isNaN = n => Number.isNaN(n)\nDouble.isInfinite = n => !Number.isFinite(n)\nDouble.MAX_VALUE = Number.MAX_VALUE\n\nif (typeof Float64Array == 'function' &&\n\t  typeof Int32Array == 'function') {\n\t// Simple and fast conversion between double and long bits\n\t// using TypedArrays and ArrayViewBuffers.\n\t(function() {\n\t\tvar EXP_BIT_MASK = 0x7ff00000;\n\t\tvar SIGNIF_BIT_MASK = 0xFFFFF;\n\t\tvar f64buf = new Float64Array(1);\n\t\tvar i32buf = new Int32Array(f64buf.buffer);\n\t\tDouble.doubleToLongBits = function (value) {\n\t\t\tf64buf[0] = value;\n\t\t\tvar low = i32buf[0] | 0;\n\t\t\tvar high = i32buf[1] | 0;\n\t\t\t// Check for NaN based on values of bit fields, maximum\n\t\t\t// exponent and nonzero significand.\n\t\t\tif (((high & EXP_BIT_MASK) === EXP_BIT_MASK) &&\n\t\t\t\t((high & SIGNIF_BIT_MASK) !== 0) &&\n\t\t\t\t(low !== 0)) {\n\t\t\t\tlow = 0 | 0;\n\t\t\t\thigh = 0x7ff80000 | 0;\n\t\t\t}\n\t\t\treturn new Long(high, low);\n\t\t};\n\t\tDouble.longBitsToDouble = function (bits) {\n\t\t\ti32buf[0] = bits.low;\n\t\t\ti32buf[1] = bits.high;\n\t\t\treturn f64buf[0];\n\t\t};\n\t})();\n} else {\n\t// More complex and slower fallback implementation using \n\t// math and the divide-by-two and multiply-by-two algorithms.\n\t(function() {\n\t\tvar BIAS = 1023;\n\t\tvar log2 = Math.log2;\n\t\tvar floor = Math.floor;\n\t\tvar pow = Math.pow;\n\t\tvar MAX_REL_BITS_INTEGER = (function () {\n\t\t\tfor (var i = 53; i > 0; i--) {\n\t\t\t\tvar bits = pow(2, i) - 1;\n\t\t\t\tif (floor(log2(bits)) + 1 === i) {\n\t\t\t\t\treturn bits;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t})();\n\t\tDouble.doubleToLongBits = function (value) {\n\t\t\tvar x, y, f, bits, skip;\n\t\t\tvar sign, exp, high, low;\n\t\n\t\t\t// Get the sign bit and absolute value.\n\t\t\tif (value < 0 || 1 / value === Number.NEGATIVE_INFINITY) {\n\t\t\t\tsign = (1 << 31);\n\t\t\t\tvalue = (-value);\n\t\t\t} else {\n\t\t\t\tsign = 0;\n\t\t\t}\n\t\n\t\t\t// Handle some special values.\n\t\t\tif (value === 0) {\n\t\t\t\t// Handle zeros (+/-0).\n\t\t\t\tlow = 0 | 0;\n\t\t\t\thigh = sign; // exponent: 00..00, significand: 00..00\n\t\t\t\treturn new Long(high, low);\n\t\t\t}\n\t\n\t\t\tif (value === Infinity) {\n\t\t\t\t// Handle infinity (only positive values for value possible).\n\t\t\t\tlow = 0 | 0;\n\t\t\t\thigh = sign | 0x7ff00000; // exponent: 11..11, significand: 00..00\n\t\t\t\treturn new Long(high, low);\n\t\t\t}\n\t\n\t\t\tif (value !== value) {\n\t\t\t\t// Handle NaNs (boiled down to only one distinct NaN).\n\t\t\t\tlow = 0 | 0;\n\t\t\t\thigh = 0x7ff80000; // exponent: 11..11, significand: 10..00\n\t\t\t\treturn new Long(high, low);\n\t\t\t}\n\t\n\t\t\t// Preinitialize variables, that are not neccessarily set by\n\t\t\t// the algorithm.\n\t\t\tbits = 0;\n\t\t\tlow = 0 | 0;\n\t\n\t\t\t// Get the (always positive) integer part of value.\n\t\t\tx = floor(value);\n\t\n\t\t\t// Process the integer part if it's greater than 1. Zero requires\n\t\t\t// no bits at all, 1 represents the implicit (hidden) leading bit,\n\t\t\t// which must not be written as well.\n\t\t\tif (x > 1) {\n\t\t\t\t// If we can reliably determine the number of bits required for\n\t\t\t\t// the integer part,\n\t\t\t\tif (x <= MAX_REL_BITS_INTEGER) {\n\t\t\t\t\t// get the number of bits required to represent it minus 1\n\t\t\t\t\tbits = floor(log2(x)) /* + 1 - 1*/ ;\n\t\t\t\t\t// and simply copy/shift the integer bits into low and high.\n\t\t\t\t\t// That's much faster than the divide-by-two algorithm (saves\n\t\t\t\t\t// up to ~60%).\n\t\t\t\t\t// We always need to mask out the most significant bit, which\n\t\t\t\t\t// is the implicit (aka hidden) bit.\n\t\t\t\t\tif (bits <= 20) {\n\t\t\t\t\t\t// The simple case in which the integer fits into the\n\t\t\t\t\t\t// lower 20 bits of the high word is worth to be handled\n\t\t\t\t\t\t// separately (saves ~25%).\n\t\t\t\t\t\tlow = 0 | 0;\n\t\t\t\t\t\thigh = (x << (20 - bits)) & 0xfffff;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Here, the integer part is split into low and high.\n\t\t\t\t\t\t// Since its value may require more than 32 bits, we\n\t\t\t\t\t\t// cannot use bitwise operators (which implicitly cast\n\t\t\t\t\t\t// to Int32), but use arithmetic operators % and / to\n\t\t\t\t\t\t// get low and high parts. The uppper 20 bits go to high,\n\t\t\t\t\t\t// the remaining bits (in f) to low.\n\t\t\t\t\t\tf = bits - 20;\n\t\t\t\t\t\t// Like (1 << f) but safe with even more than 32 bits.\n\t\t\t\t\t\ty = pow(2, f);\n\t\t\t\t\t\tlow = (x % y) << (32 - f);\n\t\t\t\t\t\thigh = (x / y) & 0xfffff;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// For greater values, we must use the much slower divide-by-two\n\t\t\t\t\t// algorithm. Bits are generated from right to left, that is from\n\t\t\t\t\t// least to most significant bit. For each bit, we left-shift both\n\t\t\t\t\t// low and high by one and carry bit #0 from high to #31 in low.\n\t\t\t\t\t// The next bit is then copied into bit #19 in high, the leftmost\n\t\t\t\t\t// bit of the double's significand.\n\t\n\t\t\t\t\t// Preserve x for later user, so work with f.\n\t\t\t\t\tf = x;\n\t\t\t\t\tlow = 0 | 0;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\ty = f / 2;\n\t\t\t\t\t\tf = floor(y);\n\t\t\t\t\t\tif (f === 0) {\n\t\t\t\t\t\t\t// We just found the most signigicant (1-)bit, which\n\t\t\t\t\t\t\t// is the implicit bit and so, not stored in the double\n\t\t\t\t\t\t\t// value. So, it's time to leave the loop.\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Count this bit, shift low and carry bit #0 from high.\n\t\t\t\t\t\tbits++;\n\t\t\t\t\t\tlow >>>= 1;\n\t\t\t\t\t\tlow |= (high & 0x1) << 31;\n\t\t\t\t\t\t// Shift high.\n\t\t\t\t\t\thigh >>>= 1;\n\t\t\t\t\t\tif (y !== f) {\n\t\t\t\t\t\t\t// Copy the new bit into bit #19 in high (only required if 1).\n\t\t\t\t\t\t\thigh |= 0x80000;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Bias the exponent.\n\t\t\texp = bits + BIAS;\n\t\n\t\t\t// If the integer part is zero, we've not yet seen the implicit\n\t\t\t// leading bit. Variable skip is later used while processing the \n\t\t\t// fractional part (if any).\n\t\t\tskip = (x === 0);\n\t\n\t\t\t// Get fraction only into x.\n\t\t\tx = value - x;\n\t\n\t\t\t// If some significand bits are still left to be filled and\n\t\t\t// the fractional part is not zero, convert the fraction using\n\t\t\t// the multiply-by-2 algorithm.\n\t\t\tif (bits < 52 && x !== 0) {\n\t\n\t\t\t\t// Initialize 'buffer' f, into which newly created bits get\n\t\t\t\t// shifted from right to left.\n\t\t\t\tf = 0;\n\t\n\t\t\t\twhile (true) {\n\t\t\t\t\ty = x * 2;\n\t\t\t\t\tif (y >= 1) {\n\t\t\t\t\t\t// This is a new 1-bit. Add and count this bit, if not\n\t\t\t\t\t\t// prohibited by skip.\n\t\t\t\t\t\tx = y - 1;\n\t\t\t\t\t\tif (!skip) {\n\t\t\t\t\t\t\tf <<= 1;\n\t\t\t\t\t\t\tf |= 1;\n\t\t\t\t\t\t\tbits++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Otherwise, decrement the exponent and unset\n\t\t\t\t\t\t\t// skip, so that all following bits get written.\n\t\t\t\t\t\t\texp--;\n\t\t\t\t\t\t\tskip = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// This is a new 0-bit. Add and count this bit, if not\n\t\t\t\t\t\t// prohibited by skip.\n\t\t\t\t\t\tx = y;\n\t\t\t\t\t\tif (!skip) {\n\t\t\t\t\t\t\tf <<= 1;\n\t\t\t\t\t\t\tbits++;\n\t\t\t\t\t\t} else if (--exp === 0) {\n\t\t\t\t\t\t\t// Otherwise we've just decremented the exponent. If the\n\t\t\t\t\t\t\t// biased exponent is zero now (-1023), we process a\n\t\t\t\t\t\t\t// subnormal number, which has no impled leading 1-bit.\n\t\t\t\t\t\t\t// So, count this 0-bit and unset skip to write out\n\t\t\t\t\t\t\t// all the following bits.\n\t\t\t\t\t\t\tbits++;\n\t\t\t\t\t\t\tskip = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (bits === 20) {\n\t\t\t\t\t\t// When 20 bits have been created in total, we're done with\n\t\t\t\t\t\t// the high word. Copy the bits from 'buffer' f into high\n\t\t\t\t\t\t// and reset 'buffer' f. Following bits will end up in the\n\t\t\t\t\t\t// low word.\n\t\t\t\t\t\thigh |= f;\n\t\t\t\t\t\tf = 0;\n\t\t\t\t\t} else if (bits === 52) {\n\t\t\t\t\t\t// When 52 bits have been created in total, we're done with\n\t\t\t\t\t\t// low word as well. Copy the bits from 'buffer' f into low\n\t\t\t\t\t\t// and exit the loop.\n\t\t\t\t\t\tlow |= f;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (y === 1) {\n\t\t\t\t\t\t// When y is exactly 1, there is no remainder and the process\n\t\t\t\t\t\t// is complete (the number is finite). Copy the bits from\n\t\t\t\t\t\t// 'buffer' f into either low or high and exit the loop.\n\t\t\t\t\t\tif (bits < 20) {\n\t\t\t\t\t\t\thigh |= (f << (20 - bits));\n\t\t\t\t\t\t} else if (bits < 52) {\n\t\t\t\t\t\t\tlow |= (f << (52 - bits));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Copy/shift the exponent and sign bits into the high word.\n\t\t\thigh |= (exp << 20);\n\t\t\thigh |= sign;\n\t\n\t\t\treturn new Long(high, low);\n\t\t};\n\t\tDouble.longBitsToDouble = function (bits) {\n\t\t\tvar x, sign, exp, fract;\n\t\t\tvar high = bits.high;\n\t\t\tvar low = bits.low;\n\t\n\t\t\t// Extract the sign.\n\t\t\tsign = (high & (1 << 31)) ? -1 : 1;\n\t\n\t\t\t// Extract the unbiased exponent.\n\t\t\texp = ((high & 0x7ff00000) >> 20) - BIAS;\n\t\n\t\t\t// Calculate the fraction from left to right. Start\n\t\t\t// off with the 20 lower bits from the high word.\n\t\t\tfract = 0;\n\t\t\tx = (1 << 19);\n\t\t\tfor (var i = 1; i <= 20; i++) {\n\t\t\t\tif (high & x) {\n\t\t\t\t\tfract += pow(2, -i);\n\t\t\t\t}\n\t\t\t\tx >>>= 1;\n\t\t\t}\n\t\t\t// Continue with all 32 bits from the low word.\n\t\t\tx = (1 << 31);\n\t\t\tfor (var i = 21; i <= 52; i++) {\n\t\t\t\tif (low & x) {\n\t\t\t\t\tfract += pow(2, -i);\n\t\t\t\t}\n\t\t\t\tx >>>= 1;\n\t\t\t}\n\t\n\t\t\t// Handle special values.\n\t\t\t// Check for zero and subnormal values.\n\t\t\tif (exp === -BIAS) {\n\t\t\t\tif (fract === 0) {\n\t\t\t\t\t// +/-1.0 * 0.0 => +/-0.0\n\t\t\t\t\treturn sign * 0;\n\t\t\t\t}\n\t\t\t\texp = -1022;\n\t\t\t}\n\t\t\t// Check for +/-Infinity or NaN.\n\t\t\telse if (exp === BIAS + 1) {\n\t\t\t\tif (fract === 0) {\n\t\t\t\t\t// +/-1.0 / 0.0 => +/-Infinity\n\t\t\t\t\treturn sign / 0;\n\t\t\t\t}\n\t\t\t\treturn NaN;\n\t\t\t}\n\t\t\t// Nothing special? Seems to be a normal number.\n\t\t\telse {\n\t\t\t\t// Add the implicit leading bit (1*2^0).\n\t\t\t\tfract += 1;\n\t\t\t}\n\t\n\t\t\treturn sign * fract * pow(2, exp);\n\t\t};\n\t})();\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/lang/Double.js\n// module id = 12\n// module chunks = 0"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 111);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8dcccae87944a17eb73e","export default function (target, source) {\n  for (let key in source) {\n    if (source.hasOwnProperty(key)) target[key] = source[key]\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/extend.js\n// module id = 0\n// module chunks = 0","import Collection from './Collection'\nimport IndexOutOfBoundsException from './IndexOutOfBoundsException'\nimport Iterator from './Iterator'\nimport List from './List'\nimport NoSuchElementException from './NoSuchElementException'\nimport OperationNotSupported from './OperationNotSupported'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/ArrayList.html\n *\n * @extends List\n * @private\n */\nexport default function ArrayList () {\n  /**\n   * @type {Array}\n   * @private\n  */\n  this.array_ = [];\n\n  if (arguments[0] instanceof Collection) {\n    this.addAll(arguments[0]);\n  }\n};\nArrayList.prototype = Object.create(List.prototype)\nArrayList.prototype.constructor = ArrayList;\n\nArrayList.prototype.ensureCapacity = function () {}\nArrayList.prototype.interfaces_ = function () { return [List, Collection] }\n\n/**\n * @override\n */\nArrayList.prototype.add = function(e) {\n  if (arguments.length === 1) {\n    this.array_.push(e)\n  } else {\n    this.array_.splice(arguments[0], 0, arguments[1])\n  }\n  return true\n};\n\nArrayList.prototype.clear = function() {\n  this.array_ = []\n}\n\n/**\n * @override\n */\nArrayList.prototype.addAll = function(c) {\n  for (var i = c.iterator(); i.hasNext();) {\n    this.add(i.next());\n  }\n  return true;\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.set = function(index, element) {\n  var oldElement = this.array_[index];\n  this.array_[index] = element;\n  return oldElement;\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.iterator = function() {\n  return new Iterator_(this);\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.get = function(index) {\n  if (index < 0 || index >= this.size()) {\n    throw new IndexOutOfBoundsException();\n  }\n\n  return this.array_[index];\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.isEmpty = function() {\n  return this.array_.length === 0;\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.size = function() {\n  return this.array_.length;\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.toArray = function() {\n  var array = [];\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    array.push(this.array_[i]);\n  }\n\n  return array;\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.remove = function(o) {\n  var found = false;\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    if (this.array_[i] === o) {\n      this.array_.splice(i, 1);\n      found = true;\n      break;\n    }\n  }\n\n  return found;\n};\n\n\n\n/**\n * @extends {Iterator}\n * @param {ArrayList} arrayList\n * @constructor\n * @private\n */\nvar Iterator_ = function(arrayList) {\n  /**\n   * @type {ArrayList}\n   * @private\n  */\n  this.arrayList_ = arrayList;\n  /**\n   * @type {number}\n   * @private\n  */\n  this.position_ = 0;\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.next = function() {\n  if (this.position_ === this.arrayList_.size()) {\n    throw new NoSuchElementException();\n  }\n  return this.arrayList_.get(this.position_++);\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.hasNext = function() {\n  if (this.position_ < this.arrayList_.size()) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n/**\n * TODO: should be in ListIterator\n * @override\n */\nIterator_.prototype.set = function(element) {\n  return this.arrayList_.set(this.position_ - 1, element);\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.remove = function() {\n  this.arrayList_.remove(this.arrayList_.get(this.position_));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/util/ArrayList.js\n// module id = 1\n// module chunks = 0","import NumberUtil from '../util/NumberUtil';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport Double from '../../../../java/lang/Double';\nimport extend from '../../../../extend';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Cloneable from '../../../../java/lang/Cloneable';\nimport Comparator from '../../../../java/util/Comparator';\nimport Serializable from '../../../../java/io/Serializable';\nimport Assert from '../util/Assert';\nexport default function Coordinate() {\n\tthis.x = null;\n\tthis.y = null;\n\tthis.z = null;\n\tif (arguments.length === 0) {\n\t\tCoordinate.call(this, 0.0, 0.0);\n\t} else if (arguments.length === 1) {\n\t\tlet c = arguments[0];\n\t\tCoordinate.call(this, c.x, c.y, c.z);\n\t} else if (arguments.length === 2) {\n\t\tlet x = arguments[0], y = arguments[1];\n\t\tCoordinate.call(this, x, y, Coordinate.NULL_ORDINATE);\n\t} else if (arguments.length === 3) {\n\t\tlet x = arguments[0], y = arguments[1], z = arguments[2];\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t}\n}\nextend(Coordinate.prototype, {\n\tsetOrdinate: function (ordinateIndex, value) {\n\t\tswitch (ordinateIndex) {\n\t\t\tcase Coordinate.X:\n\t\t\t\tthis.x = value;\n\t\t\t\tbreak;\n\t\t\tcase Coordinate.Y:\n\t\t\t\tthis.y = value;\n\t\t\t\tbreak;\n\t\t\tcase Coordinate.Z:\n\t\t\t\tthis.z = value;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid ordinate index: \" + ordinateIndex);\n\t\t}\n\t},\n\tequals2D: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet other = arguments[0];\n\t\t\tif (this.x !== other.x) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this.y !== other.y) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet c = arguments[0], tolerance = arguments[1];\n\t\t\tif (!NumberUtil.equalsWithTolerance(this.x, c.x, tolerance)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!NumberUtil.equalsWithTolerance(this.y, c.y, tolerance)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t},\n\tgetOrdinate: function (ordinateIndex) {\n\t\tswitch (ordinateIndex) {\n\t\t\tcase Coordinate.X:\n\t\t\t\treturn this.x;\n\t\t\tcase Coordinate.Y:\n\t\t\t\treturn this.y;\n\t\t\tcase Coordinate.Z:\n\t\t\t\treturn this.z;\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Invalid ordinate index: \" + ordinateIndex);\n\t},\n\tequals3D: function (other) {\n\t\treturn this.x === other.x && this.y === other.y && (this.z === other.z || Double.isNaN(this.z) && Double.isNaN(other.z));\n\t},\n\tequals: function (other) {\n\t\tif (!(other instanceof Coordinate)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.equals2D(other);\n\t},\n\tequalInZ: function (c, tolerance) {\n\t\treturn NumberUtil.equalsWithTolerance(this.z, c.z, tolerance);\n\t},\n\tcompareTo: function (o) {\n\t\tvar other = o;\n\t\tif (this.x < other.x) return -1;\n\t\tif (this.x > other.x) return 1;\n\t\tif (this.y < other.y) return -1;\n\t\tif (this.y > other.y) return 1;\n\t\treturn 0;\n\t},\n\tclone: function () {\n\t\ttry {\n\t\t\tvar coord = null;\n\t\t\treturn coord;\n\t\t} catch (e) {\n\t\t\tif (e instanceof CloneNotSupportedException) {\n\t\t\t\tAssert.shouldNeverReachHere(\"this shouldn't happen because this class is Cloneable\");\n\t\t\t\treturn null;\n\t\t\t} else throw e;\n\t\t} finally {}\n\t},\n\tcopy: function () {\n\t\treturn new Coordinate(this);\n\t},\n\ttoString: function () {\n\t\treturn \"(\" + this.x + \", \" + this.y + \", \" + this.z + \")\";\n\t},\n\tdistance3D: function (c) {\n\t\tvar dx = this.x - c.x;\n\t\tvar dy = this.y - c.y;\n\t\tvar dz = this.z - c.z;\n\t\treturn Math.sqrt(dx * dx + dy * dy + dz * dz);\n\t},\n\tdistance: function (c) {\n\t\tvar dx = this.x - c.x;\n\t\tvar dy = this.y - c.y;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t},\n\thashCode: function () {\n\t\tvar result = 17;\n\t\tresult = 37 * result + Coordinate.hashCode(this.x);\n\t\tresult = 37 * result + Coordinate.hashCode(this.y);\n\t\treturn result;\n\t},\n\tsetCoordinate: function (other) {\n\t\tthis.x = other.x;\n\t\tthis.y = other.y;\n\t\tthis.z = other.z;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparable, Cloneable, Serializable];\n\t},\n\tgetClass: function () {\n\t\treturn Coordinate;\n\t}\n});\nCoordinate.hashCode = function () {\n\tif (arguments.length === 1 && typeof arguments[0] === \"number\") {\n\t\tlet x = arguments[0];\n\t\tvar f = Double.doubleToLongBits(x);\n\t\treturn Math.trunc(f ^ f >>> 32);\n\t}\n};\nfunction DimensionalComparator() {\n\tthis._dimensionsToTest = 2;\n\tif (arguments.length === 0) {\n\t\tDimensionalComparator.call(this, 2);\n\t} else if (arguments.length === 1) {\n\t\tlet dimensionsToTest = arguments[0];\n\t\tif (dimensionsToTest !== 2 && dimensionsToTest !== 3) throw new IllegalArgumentException(\"only 2 or 3 dimensions may be specified\");\n\t\tthis._dimensionsToTest = dimensionsToTest;\n\t}\n}\nextend(DimensionalComparator.prototype, {\n\tcompare: function (o1, o2) {\n\t\tvar c1 = o1;\n\t\tvar c2 = o2;\n\t\tvar compX = DimensionalComparator.compare(c1.x, c2.x);\n\t\tif (compX !== 0) return compX;\n\t\tvar compY = DimensionalComparator.compare(c1.y, c2.y);\n\t\tif (compY !== 0) return compY;\n\t\tif (this._dimensionsToTest <= 2) return 0;\n\t\tvar compZ = DimensionalComparator.compare(c1.z, c2.z);\n\t\treturn compZ;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparator];\n\t},\n\tgetClass: function () {\n\t\treturn DimensionalComparator;\n\t}\n});\nDimensionalComparator.compare = function (a, b) {\n\tif (a < b) return -1;\n\tif (a > b) return 1;\n\tif (Double.isNaN(a)) {\n\t\tif (Double.isNaN(b)) return 0;\n\t\treturn -1;\n\t}\n\tif (Double.isNaN(b)) return 1;\n\treturn 0;\n};\nCoordinate.DimensionalComparator = DimensionalComparator;\nCoordinate.serialVersionUID = 6683108902428366910;\nCoordinate.NULL_ORDINATE = Double.NaN;\nCoordinate.X = 0;\nCoordinate.Y = 1;\nCoordinate.Z = 2;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/Coordinate.js\n// module id = 2\n// module chunks = 0","export default function (c, p) {\n  c.prototype = Object.create(p.prototype)\n  c.prototype.constructor = c\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/inherits.js\n// module id = 3\n// module chunks = 0","import extend from '../../../../extend';\nimport AssertionFailedException from './AssertionFailedException';\nexport default function Assert() {}\nextend(Assert.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Assert;\n\t}\n});\nAssert.shouldNeverReachHere = function () {\n\tif (arguments.length === 0) {\n\t\tAssert.shouldNeverReachHere(null);\n\t} else if (arguments.length === 1) {\n\t\tlet message = arguments[0];\n\t\tthrow new AssertionFailedException(\"Should never reach here\" + (message !== null ? \": \" + message : \"\"));\n\t}\n};\nAssert.isTrue = function () {\n\tif (arguments.length === 1) {\n\t\tlet assertion = arguments[0];\n\t\tAssert.isTrue(assertion, null);\n\t} else if (arguments.length === 2) {\n\t\tlet assertion = arguments[0], message = arguments[1];\n\t\tif (!assertion) {\n\t\t\tif (message === null) {\n\t\t\t\tthrow new AssertionFailedException();\n\t\t\t} else {\n\t\t\t\tthrow new AssertionFailedException(message);\n\t\t\t}\n\t\t}\n\t}\n};\nAssert.equals = function () {\n\tif (arguments.length === 2) {\n\t\tlet expectedValue = arguments[0], actualValue = arguments[1];\n\t\tAssert.equals(expectedValue, actualValue, null);\n\t} else if (arguments.length === 3) {\n\t\tlet expectedValue = arguments[0], actualValue = arguments[1], message = arguments[2];\n\t\tif (!actualValue.equals(expectedValue)) {\n\t\t\tthrow new AssertionFailedException(\"Expected \" + expectedValue + \" but encountered \" + actualValue + (message !== null ? \": \" + message : \"\"));\n\t\t}\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/util/Assert.js\n// module id = 4\n// module chunks = 0","export default function (o, i) {\n  return o.interfaces_ && o.interfaces_().indexOf(i) > -1\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/hasInterface.js\n// module id = 5\n// module chunks = 0","export default function IllegalArgumentException () {}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/lang/IllegalArgumentException.js\n// module id = 6\n// module chunks = 0","import IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../extend';\nexport default function Location() {}\nextend(Location.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Location;\n\t}\n});\nLocation.toLocationSymbol = function (locationValue) {\n\tswitch (locationValue) {\n\t\tcase Location.EXTERIOR:\n\t\t\treturn 'e';\n\t\tcase Location.BOUNDARY:\n\t\t\treturn 'b';\n\t\tcase Location.INTERIOR:\n\t\t\treturn 'i';\n\t\tcase Location.NONE:\n\t\t\treturn '-';\n\t}\n\tthrow new IllegalArgumentException(\"Unknown location value: \" + locationValue);\n};\nLocation.INTERIOR = 0;\nLocation.BOUNDARY = 1;\nLocation.EXTERIOR = 2;\nLocation.NONE = -1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/Location.js\n// module id = 7\n// module chunks = 0","import extend from '../../../../extend';\nexport default function Position() {}\nextend(Position.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Position;\n\t}\n});\nPosition.opposite = function (position) {\n\tif (position === Position.LEFT) return Position.RIGHT;\n\tif (position === Position.RIGHT) return Position.LEFT;\n\treturn position;\n};\nPosition.ON = 0;\nPosition.LEFT = 1;\nPosition.RIGHT = 2;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geomgraph/Position.js\n// module id = 8\n// module chunks = 0","export default function Comparable () {}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/lang/Comparable.js\n// module id = 9\n// module chunks = 0","export default function Serializable () {}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/io/Serializable.js\n// module id = 10\n// module chunks = 0","import IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../extend';\nimport CGAlgorithmsDD from './CGAlgorithmsDD';\nexport default function Orientation() {}\nextend(Orientation.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Orientation;\n\t}\n});\nOrientation.index = function (p1, p2, q) {\n\treturn CGAlgorithmsDD.orientationIndex(p1, p2, q);\n};\nOrientation.isCCW = function (ring) {\n\tvar nPts = ring.length - 1;\n\tif (nPts < 3) throw new IllegalArgumentException(\"Ring has fewer than 4 points, so orientation cannot be determined\");\n\tvar hiPt = ring[0];\n\tvar hiIndex = 0;\n\tfor (var i = 1; i <= nPts; i++) {\n\t\tvar p = ring[i];\n\t\tif (p.y > hiPt.y) {\n\t\t\thiPt = p;\n\t\t\thiIndex = i;\n\t\t}\n\t}\n\tvar iPrev = hiIndex;\n\tdo {\n\t\tiPrev = iPrev - 1;\n\t\tif (iPrev < 0) iPrev = nPts;\n\t} while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex);\n\tvar iNext = hiIndex;\n\tdo {\n\t\tiNext = (iNext + 1) % nPts;\n\t} while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex);\n\tvar prev = ring[iPrev];\n\tvar next = ring[iNext];\n\tif (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) return false;\n\tvar disc = Orientation.index(prev, hiPt, next);\n\tvar isCCW = null;\n\tif (disc === 0) {\n\t\tisCCW = prev.x > next.x;\n\t} else {\n\t\tisCCW = disc > 0;\n\t}\n\treturn isCCW;\n};\nOrientation.CLOCKWISE = -1;\nOrientation.RIGHT = Orientation.CLOCKWISE;\nOrientation.COUNTERCLOCKWISE = 1;\nOrientation.LEFT = Orientation.COUNTERCLOCKWISE;\nOrientation.COLLINEAR = 0;\nOrientation.STRAIGHT = Orientation.COLLINEAR;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/algorithm/Orientation.js\n// module id = 11\n// module chunks = 0","import Coordinate from './Coordinate';\nimport extend from '../../../../extend';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Serializable from '../../../../java/io/Serializable';\nexport default function Envelope() {\n\tthis._minx = null;\n\tthis._maxx = null;\n\tthis._miny = null;\n\tthis._maxy = null;\n\tif (arguments.length === 0) {\n\t\tthis.init();\n\t} else if (arguments.length === 1) {\n\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\tlet p = arguments[0];\n\t\t\tthis.init(p.x, p.x, p.y, p.y);\n\t\t} else if (arguments[0] instanceof Envelope) {\n\t\t\tlet env = arguments[0];\n\t\t\tthis.init(env);\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tlet p1 = arguments[0], p2 = arguments[1];\n\t\tthis.init(p1.x, p2.x, p1.y, p2.y);\n\t} else if (arguments.length === 4) {\n\t\tlet x1 = arguments[0], x2 = arguments[1], y1 = arguments[2], y2 = arguments[3];\n\t\tthis.init(x1, x2, y1, y2);\n\t}\n}\nextend(Envelope.prototype, {\n\tgetArea: function () {\n\t\treturn this.getWidth() * this.getHeight();\n\t},\n\tequals: function (other) {\n\t\tif (!(other instanceof Envelope)) {\n\t\t\treturn false;\n\t\t}\n\t\tvar otherEnvelope = other;\n\t\tif (this.isNull()) {\n\t\t\treturn otherEnvelope.isNull();\n\t\t}\n\t\treturn this._maxx === otherEnvelope.getMaxX() && this._maxy === otherEnvelope.getMaxY() && this._minx === otherEnvelope.getMinX() && this._miny === otherEnvelope.getMinY();\n\t},\n\tintersection: function (env) {\n\t\tif (this.isNull() || env.isNull() || !this.intersects(env)) return new Envelope();\n\t\tvar intMinX = this._minx > env._minx ? this._minx : env._minx;\n\t\tvar intMinY = this._miny > env._miny ? this._miny : env._miny;\n\t\tvar intMaxX = this._maxx < env._maxx ? this._maxx : env._maxx;\n\t\tvar intMaxY = this._maxy < env._maxy ? this._maxy : env._maxy;\n\t\treturn new Envelope(intMinX, intMaxX, intMinY, intMaxY);\n\t},\n\tisNull: function () {\n\t\treturn this._maxx < this._minx;\n\t},\n\tgetMaxX: function () {\n\t\treturn this._maxx;\n\t},\n\tcovers: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet p = arguments[0];\n\t\t\t\treturn this.covers(p.x, p.y);\n\t\t\t} else if (arguments[0] instanceof Envelope) {\n\t\t\t\tlet other = arguments[0];\n\t\t\t\tif (this.isNull() || other.isNull()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn other.getMinX() >= this._minx && other.getMaxX() <= this._maxx && other.getMinY() >= this._miny && other.getMaxY() <= this._maxy;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet x = arguments[0], y = arguments[1];\n\t\t\tif (this.isNull()) return false;\n\t\t\treturn x >= this._minx && x <= this._maxx && y >= this._miny && y <= this._maxy;\n\t\t}\n\t},\n\tintersects: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Envelope) {\n\t\t\t\tlet other = arguments[0];\n\t\t\t\tif (this.isNull() || other.isNull()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn !(other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny);\n\t\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet p = arguments[0];\n\t\t\t\treturn this.intersects(p.x, p.y);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tif (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n\t\t\t\tlet a = arguments[0], b = arguments[1];\n\t\t\t\tif (this.isNull()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tvar envminx = a.x < b.x ? a.x : b.x;\n\t\t\t\tif (envminx > this._maxx) return false;\n\t\t\t\tvar envmaxx = a.x > b.x ? a.x : b.x;\n\t\t\t\tif (envmaxx < this._minx) return false;\n\t\t\t\tvar envminy = a.y < b.y ? a.y : b.y;\n\t\t\t\tif (envminy > this._maxy) return false;\n\t\t\t\tvar envmaxy = a.y > b.y ? a.y : b.y;\n\t\t\t\tif (envmaxy < this._miny) return false;\n\t\t\t\treturn true;\n\t\t\t} else if (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n\t\t\t\tlet x = arguments[0], y = arguments[1];\n\t\t\t\tif (this.isNull()) return false;\n\t\t\t\treturn !(x > this._maxx || x < this._minx || y > this._maxy || y < this._miny);\n\t\t\t}\n\t\t}\n\t},\n\tgetMinY: function () {\n\t\treturn this._miny;\n\t},\n\tgetMinX: function () {\n\t\treturn this._minx;\n\t},\n\texpandToInclude: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet p = arguments[0];\n\t\t\t\tthis.expandToInclude(p.x, p.y);\n\t\t\t} else if (arguments[0] instanceof Envelope) {\n\t\t\t\tlet other = arguments[0];\n\t\t\t\tif (other.isNull()) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (this.isNull()) {\n\t\t\t\t\tthis._minx = other.getMinX();\n\t\t\t\t\tthis._maxx = other.getMaxX();\n\t\t\t\t\tthis._miny = other.getMinY();\n\t\t\t\t\tthis._maxy = other.getMaxY();\n\t\t\t\t} else {\n\t\t\t\t\tif (other._minx < this._minx) {\n\t\t\t\t\t\tthis._minx = other._minx;\n\t\t\t\t\t}\n\t\t\t\t\tif (other._maxx > this._maxx) {\n\t\t\t\t\t\tthis._maxx = other._maxx;\n\t\t\t\t\t}\n\t\t\t\t\tif (other._miny < this._miny) {\n\t\t\t\t\t\tthis._miny = other._miny;\n\t\t\t\t\t}\n\t\t\t\t\tif (other._maxy > this._maxy) {\n\t\t\t\t\t\tthis._maxy = other._maxy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet x = arguments[0], y = arguments[1];\n\t\t\tif (this.isNull()) {\n\t\t\t\tthis._minx = x;\n\t\t\t\tthis._maxx = x;\n\t\t\t\tthis._miny = y;\n\t\t\t\tthis._maxy = y;\n\t\t\t} else {\n\t\t\t\tif (x < this._minx) {\n\t\t\t\t\tthis._minx = x;\n\t\t\t\t}\n\t\t\t\tif (x > this._maxx) {\n\t\t\t\t\tthis._maxx = x;\n\t\t\t\t}\n\t\t\t\tif (y < this._miny) {\n\t\t\t\t\tthis._miny = y;\n\t\t\t\t}\n\t\t\t\tif (y > this._maxy) {\n\t\t\t\t\tthis._maxy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tminExtent: function () {\n\t\tif (this.isNull()) return 0.0;\n\t\tvar w = this.getWidth();\n\t\tvar h = this.getHeight();\n\t\tif (w < h) return w;\n\t\treturn h;\n\t},\n\tgetWidth: function () {\n\t\tif (this.isNull()) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this._maxx - this._minx;\n\t},\n\tcompareTo: function (o) {\n\t\tvar env = o;\n\t\tif (this.isNull()) {\n\t\t\tif (env.isNull()) return 0;\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tif (env.isNull()) return 1;\n\t\t}\n\t\tif (this._minx < env._minx) return -1;\n\t\tif (this._minx > env._minx) return 1;\n\t\tif (this._miny < env._miny) return -1;\n\t\tif (this._miny > env._miny) return 1;\n\t\tif (this._maxx < env._maxx) return -1;\n\t\tif (this._maxx > env._maxx) return 1;\n\t\tif (this._maxy < env._maxy) return -1;\n\t\tif (this._maxy > env._maxy) return 1;\n\t\treturn 0;\n\t},\n\ttranslate: function (transX, transY) {\n\t\tif (this.isNull()) {\n\t\t\treturn null;\n\t\t}\n\t\tthis.init(this.getMinX() + transX, this.getMaxX() + transX, this.getMinY() + transY, this.getMaxY() + transY);\n\t},\n\ttoString: function () {\n\t\treturn \"Env[\" + this._minx + \" : \" + this._maxx + \", \" + this._miny + \" : \" + this._maxy + \"]\";\n\t},\n\tsetToNull: function () {\n\t\tthis._minx = 0;\n\t\tthis._maxx = -1;\n\t\tthis._miny = 0;\n\t\tthis._maxy = -1;\n\t},\n\tgetHeight: function () {\n\t\tif (this.isNull()) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this._maxy - this._miny;\n\t},\n\tmaxExtent: function () {\n\t\tif (this.isNull()) return 0.0;\n\t\tvar w = this.getWidth();\n\t\tvar h = this.getHeight();\n\t\tif (w > h) return w;\n\t\treturn h;\n\t},\n\texpandBy: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet distance = arguments[0];\n\t\t\tthis.expandBy(distance, distance);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet deltaX = arguments[0], deltaY = arguments[1];\n\t\t\tif (this.isNull()) return null;\n\t\t\tthis._minx -= deltaX;\n\t\t\tthis._maxx += deltaX;\n\t\t\tthis._miny -= deltaY;\n\t\t\tthis._maxy += deltaY;\n\t\t\tif (this._minx > this._maxx || this._miny > this._maxy) this.setToNull();\n\t\t}\n\t},\n\tcontains: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Envelope) {\n\t\t\t\tlet other = arguments[0];\n\t\t\t\treturn this.covers(other);\n\t\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet p = arguments[0];\n\t\t\t\treturn this.covers(p);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet x = arguments[0], y = arguments[1];\n\t\t\treturn this.covers(x, y);\n\t\t}\n\t},\n\tcentre: function () {\n\t\tif (this.isNull()) return null;\n\t\treturn new Coordinate((this.getMinX() + this.getMaxX()) / 2.0, (this.getMinY() + this.getMaxY()) / 2.0);\n\t},\n\tinit: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tthis.setToNull();\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet p = arguments[0];\n\t\t\t\tthis.init(p.x, p.x, p.y, p.y);\n\t\t\t} else if (arguments[0] instanceof Envelope) {\n\t\t\t\tlet env = arguments[0];\n\t\t\t\tthis._minx = env._minx;\n\t\t\t\tthis._maxx = env._maxx;\n\t\t\t\tthis._miny = env._miny;\n\t\t\t\tthis._maxy = env._maxy;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet p1 = arguments[0], p2 = arguments[1];\n\t\t\tthis.init(p1.x, p2.x, p1.y, p2.y);\n\t\t} else if (arguments.length === 4) {\n\t\t\tlet x1 = arguments[0], x2 = arguments[1], y1 = arguments[2], y2 = arguments[3];\n\t\t\tif (x1 < x2) {\n\t\t\t\tthis._minx = x1;\n\t\t\t\tthis._maxx = x2;\n\t\t\t} else {\n\t\t\t\tthis._minx = x2;\n\t\t\t\tthis._maxx = x1;\n\t\t\t}\n\t\t\tif (y1 < y2) {\n\t\t\t\tthis._miny = y1;\n\t\t\t\tthis._maxy = y2;\n\t\t\t} else {\n\t\t\t\tthis._miny = y2;\n\t\t\t\tthis._maxy = y1;\n\t\t\t}\n\t\t}\n\t},\n\tgetMaxY: function () {\n\t\treturn this._maxy;\n\t},\n\tdistance: function (env) {\n\t\tif (this.intersects(env)) return 0;\n\t\tvar dx = 0.0;\n\t\tif (this._maxx < env._minx) dx = env._minx - this._maxx; else if (this._minx > env._maxx) dx = this._minx - env._maxx;\n\t\tvar dy = 0.0;\n\t\tif (this._maxy < env._miny) dy = env._miny - this._maxy; else if (this._miny > env._maxy) dy = this._miny - env._maxy;\n\t\tif (dx === 0.0) return dy;\n\t\tif (dy === 0.0) return dx;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t},\n\thashCode: function () {\n\t\tvar result = 17;\n\t\tresult = 37 * result + Coordinate.hashCode(this._minx);\n\t\tresult = 37 * result + Coordinate.hashCode(this._maxx);\n\t\tresult = 37 * result + Coordinate.hashCode(this._miny);\n\t\tresult = 37 * result + Coordinate.hashCode(this._maxy);\n\t\treturn result;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparable, Serializable];\n\t},\n\tgetClass: function () {\n\t\treturn Envelope;\n\t}\n});\nEnvelope.intersects = function () {\n\tif (arguments.length === 3) {\n\t\tlet p1 = arguments[0], p2 = arguments[1], q = arguments[2];\n\t\tif (q.x >= (p1.x < p2.x ? p1.x : p2.x) && q.x <= (p1.x > p2.x ? p1.x : p2.x) && (q.y >= (p1.y < p2.y ? p1.y : p2.y) && q.y <= (p1.y > p2.y ? p1.y : p2.y))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t} else if (arguments.length === 4) {\n\t\tlet p1 = arguments[0], p2 = arguments[1], q1 = arguments[2], q2 = arguments[3];\n\t\tvar minq = Math.min(q1.x, q2.x);\n\t\tvar maxq = Math.max(q1.x, q2.x);\n\t\tvar minp = Math.min(p1.x, p2.x);\n\t\tvar maxp = Math.max(p1.x, p2.x);\n\t\tif (minp > maxq) return false;\n\t\tif (maxp < minq) return false;\n\t\tminq = Math.min(q1.y, q2.y);\n\t\tmaxq = Math.max(q1.y, q2.y);\n\t\tminp = Math.min(p1.y, p2.y);\n\t\tmaxp = Math.max(p1.y, p2.y);\n\t\tif (minp > maxq) return false;\n\t\tif (maxp < minq) return false;\n\t\treturn true;\n\t}\n};\nEnvelope.serialVersionUID = 5873921885273102420;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/Envelope.js\n// module id = 13\n// module chunks = 0","import IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../extend';\nimport GeometryComponentFilter from './GeometryComponentFilter';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Cloneable from '../../../../java/lang/Cloneable';\nimport Serializable from '../../../../java/io/Serializable';\nimport Envelope from './Envelope';\nimport Assert from '../util/Assert';\nexport default function Geometry() {\n\tthis._envelope = null;\n\tthis._factory = null;\n\tthis._SRID = null;\n\tthis._userData = null;\n\tlet factory = arguments[0];\n\tthis._factory = factory;\n\tthis._SRID = factory.getSRID();\n}\nextend(Geometry.prototype, {\n\tisGeometryCollection: function () {\n\t\treturn this.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION;\n\t},\n\tgetFactory: function () {\n\t\treturn this._factory;\n\t},\n\tgetGeometryN: function (n) {\n\t\treturn this;\n\t},\n\tgetArea: function () {\n\t\treturn 0.0;\n\t},\n\tisRectangle: function () {\n\t\treturn false;\n\t},\n\tequals: function () {\n\t\tif (arguments[0] instanceof Geometry) {\n\t\t\tlet g = arguments[0];\n\t\t\tif (g === null) return false;\n\t\t\treturn this.equalsTopo(g);\n\t\t} else if (arguments[0] instanceof Object) {\n\t\t\tlet o = arguments[0];\n\t\t\tif (!(o instanceof Geometry)) return false;\n\t\t\tvar g = o;\n\t\t\treturn this.equalsExact(g);\n\t\t}\n\t},\n\tequalsExact: function (other) {\n\t\treturn this === other || this.equalsExact(other, 0);\n\t},\n\tgeometryChanged: function () {\n\t\tthis.apply(Geometry.geometryChangedFilter);\n\t},\n\tgeometryChangedAction: function () {\n\t\tthis._envelope = null;\n\t},\n\tequalsNorm: function (g) {\n\t\tif (g === null) return false;\n\t\treturn this.norm().equalsExact(g.norm());\n\t},\n\tgetLength: function () {\n\t\treturn 0.0;\n\t},\n\tgetNumGeometries: function () {\n\t\treturn 1;\n\t},\n\tcompareTo: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet o = arguments[0];\n\t\t\tvar other = o;\n\t\t\tif (this.getTypeCode() !== other.getTypeCode()) {\n\t\t\t\treturn this.getTypeCode() - other.getTypeCode();\n\t\t\t}\n\t\t\tif (this.isEmpty() && other.isEmpty()) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (other.isEmpty()) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn this.compareToSameClass(o);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet o = arguments[0], comp = arguments[1];\n\t\t\tvar other = o;\n\t\t\tif (this.getTypeCode() !== other.getTypeCode()) {\n\t\t\t\treturn this.getTypeCode() - other.getTypeCode();\n\t\t\t}\n\t\t\tif (this.isEmpty() && other.isEmpty()) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (other.isEmpty()) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn this.compareToSameClass(o, comp);\n\t\t}\n\t},\n\tgetUserData: function () {\n\t\treturn this._userData;\n\t},\n\tgetSRID: function () {\n\t\treturn this._SRID;\n\t},\n\tgetEnvelope: function () {\n\t\treturn this.getFactory().toGeometry(this.getEnvelopeInternal());\n\t},\n\tcheckNotGeometryCollection: function (g) {\n\t\tif (g.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION) {\n\t\t\tthrow new IllegalArgumentException(\"This method does not support GeometryCollection arguments\");\n\t\t}\n\t},\n\tequal: function (a, b, tolerance) {\n\t\tif (tolerance === 0) {\n\t\t\treturn a.equals(b);\n\t\t}\n\t\treturn a.distance(b) <= tolerance;\n\t},\n\tnorm: function () {\n\t\tvar copy = this.copy();\n\t\tcopy.normalize();\n\t\treturn copy;\n\t},\n\tgetPrecisionModel: function () {\n\t\treturn this._factory.getPrecisionModel();\n\t},\n\tgetEnvelopeInternal: function () {\n\t\tif (this._envelope === null) {\n\t\t\tthis._envelope = this.computeEnvelopeInternal();\n\t\t}\n\t\treturn new Envelope(this._envelope);\n\t},\n\tsetSRID: function (SRID) {\n\t\tthis._SRID = SRID;\n\t},\n\tsetUserData: function (userData) {\n\t\tthis._userData = userData;\n\t},\n\tcompare: function (a, b) {\n\t\tvar i = a.iterator();\n\t\tvar j = b.iterator();\n\t\twhile (i.hasNext() && j.hasNext()) {\n\t\t\tvar aElement = i.next();\n\t\t\tvar bElement = j.next();\n\t\t\tvar comparison = aElement.compareTo(bElement);\n\t\t\tif (comparison !== 0) {\n\t\t\t\treturn comparison;\n\t\t\t}\n\t\t}\n\t\tif (i.hasNext()) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (j.hasNext()) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t},\n\thashCode: function () {\n\t\treturn this.getEnvelopeInternal().hashCode();\n\t},\n\tisGeometryCollectionOrDerived: function () {\n\t\tif (this.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION || this.getTypeCode() === Geometry.TYPECODE_MULTIPOINT || this.getTypeCode() === Geometry.TYPECODE_MULTILINESTRING || this.getTypeCode() === Geometry.TYPECODE_MULTIPOLYGON) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Cloneable, Comparable, Serializable];\n\t},\n\tgetClass: function () {\n\t\treturn Geometry;\n\t}\n});\nGeometry.hasNonEmptyElements = function (geometries) {\n\tfor (var i = 0; i < geometries.length; i++) {\n\t\tif (!geometries[i].isEmpty()) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n};\nGeometry.hasNullElements = function (array) {\n\tfor (var i = 0; i < array.length; i++) {\n\t\tif (array[i] === null) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n};\nGeometry.serialVersionUID = 8763622679187376702;\nGeometry.TYPECODE_POINT = 0;\nGeometry.TYPECODE_MULTIPOINT = 1;\nGeometry.TYPECODE_LINESTRING = 2;\nGeometry.TYPECODE_LINEARRING = 3;\nGeometry.TYPECODE_MULTILINESTRING = 4;\nGeometry.TYPECODE_POLYGON = 5;\nGeometry.TYPECODE_MULTIPOLYGON = 6;\nGeometry.TYPECODE_GEOMETRYCOLLECTION = 7;\nGeometry.TYPENAME_POINT = \"Point\";\nGeometry.TYPENAME_MULTIPOINT = \"MultiPoint\";\nGeometry.TYPENAME_LINESTRING = \"LineString\";\nGeometry.TYPENAME_LINEARRING = \"LinearRing\";\nGeometry.TYPENAME_MULTILINESTRING = \"MultiLineString\";\nGeometry.TYPENAME_POLYGON = \"Polygon\";\nGeometry.TYPENAME_MULTIPOLYGON = \"MultiPolygon\";\nGeometry.TYPENAME_GEOMETRYCOLLECTION = \"GeometryCollection\";\nGeometry.geometryChangedFilter = {\n\tinterfaces_: function () {\n\t\treturn [GeometryComponentFilter];\n\t},\n\tfilter: function (geom) {\n\t\tgeom.geometryChangedAction();\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/Geometry.js\n// module id = 14\n// module chunks = 0","import TreeSet from '../../../../java/util/TreeSet';\nimport Geometry from './Geometry';\nimport Arrays from '../../../../java/util/Arrays';\nimport CoordinateFilter from './CoordinateFilter';\nimport hasInterface from '../../../../hasInterface';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../extend';\nimport GeometryComponentFilter from './GeometryComponentFilter';\nimport Dimension from './Dimension';\nimport GeometryFilter from './GeometryFilter';\nimport CoordinateSequenceFilter from './CoordinateSequenceFilter';\nimport Envelope from './Envelope';\nimport Assert from '../util/Assert';\nimport inherits from '../../../../inherits';\nexport default function GeometryCollection() {\n\tthis._geometries = null;\n\tlet geometries = arguments[0], factory = arguments[1];\n\tGeometry.call(this, factory);\n\tif (geometries === null) {\n\t\tgeometries = [];\n\t}\n\tif (Geometry.hasNullElements(geometries)) {\n\t\tthrow new IllegalArgumentException(\"geometries must not contain null elements\");\n\t}\n\tthis._geometries = geometries;\n}\ninherits(GeometryCollection, Geometry);\nextend(GeometryCollection.prototype, {\n\tcomputeEnvelopeInternal: function () {\n\t\tvar envelope = new Envelope();\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tenvelope.expandToInclude(this._geometries[i].getEnvelopeInternal());\n\t\t}\n\t\treturn envelope;\n\t},\n\tgetGeometryN: function (n) {\n\t\treturn this._geometries[n];\n\t},\n\tgetCoordinates: function () {\n\t\tvar coordinates = new Array(this.getNumPoints()).fill(null);\n\t\tvar k = -1;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tvar childCoordinates = this._geometries[i].getCoordinates();\n\t\t\tfor (var j = 0; j < childCoordinates.length; j++) {\n\t\t\t\tk++;\n\t\t\t\tcoordinates[k] = childCoordinates[j];\n\t\t\t}\n\t\t}\n\t\treturn coordinates;\n\t},\n\tgetArea: function () {\n\t\tvar area = 0.0;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tarea += this._geometries[i].getArea();\n\t\t}\n\t\treturn area;\n\t},\n\tequalsExact: function () {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry)) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar otherCollection = other;\n\t\t\tif (this._geometries.length !== otherCollection._geometries.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\t\tif (!this._geometries[i].equalsExact(otherCollection._geometries[i], tolerance)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else return Geometry.prototype.equalsExact.apply(this, arguments);\n\t},\n\tnormalize: function () {\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tthis._geometries[i].normalize();\n\t\t}\n\t\tArrays.sort(this._geometries);\n\t},\n\tgetCoordinate: function () {\n\t\tif (this.isEmpty()) return null;\n\t\treturn this._geometries[0].getCoordinate();\n\t},\n\tgetBoundaryDimension: function () {\n\t\tvar dimension = Dimension.FALSE;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tdimension = Math.max(dimension, this._geometries[i].getBoundaryDimension());\n\t\t}\n\t\treturn dimension;\n\t},\n\tgetTypeCode: function () {\n\t\treturn Geometry.TYPECODE_GEOMETRYCOLLECTION;\n\t},\n\tgetDimension: function () {\n\t\tvar dimension = Dimension.FALSE;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tdimension = Math.max(dimension, this._geometries[i].getDimension());\n\t\t}\n\t\treturn dimension;\n\t},\n\tgetLength: function () {\n\t\tvar sum = 0.0;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tsum += this._geometries[i].getLength();\n\t\t}\n\t\treturn sum;\n\t},\n\tgetNumPoints: function () {\n\t\tvar numPoints = 0;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tnumPoints += this._geometries[i].getNumPoints();\n\t\t}\n\t\treturn numPoints;\n\t},\n\tgetNumGeometries: function () {\n\t\treturn this._geometries.length;\n\t},\n\treverse: function () {\n\t\tvar n = this._geometries.length;\n\t\tvar revGeoms = new Array(n).fill(null);\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\trevGeoms[i] = this._geometries[i].reverse();\n\t\t}\n\t\treturn this.getFactory().createGeometryCollection(revGeoms);\n\t},\n\tcompareToSameClass: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet o = arguments[0];\n\t\t\tvar theseElements = new TreeSet(Arrays.asList(this._geometries));\n\t\t\tvar otherElements = new TreeSet(Arrays.asList(o._geometries));\n\t\t\treturn this.compare(theseElements, otherElements);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet o = arguments[0], comp = arguments[1];\n\t\t\tvar gc = o;\n\t\t\tvar n1 = this.getNumGeometries();\n\t\t\tvar n2 = gc.getNumGeometries();\n\t\t\tvar i = 0;\n\t\t\twhile (i < n1 && i < n2) {\n\t\t\t\tvar thisGeom = this.getGeometryN(i);\n\t\t\t\tvar otherGeom = gc.getGeometryN(i);\n\t\t\t\tvar holeComp = thisGeom.compareToSameClass(otherGeom, comp);\n\t\t\t\tif (holeComp !== 0) return holeComp;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i < n1) return 1;\n\t\t\tif (i < n2) return -1;\n\t\t\treturn 0;\n\t\t}\n\t},\n\tapply: function () {\n\t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\t\tthis._geometries[i].apply(filter);\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tif (this._geometries.length === 0) return null;\n\t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\t\tthis._geometries[i].apply(filter);\n\t\t\t\tif (filter.isDone()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n\t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\t\tthis._geometries[i].apply(filter);\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\t\tthis._geometries[i].apply(filter);\n\t\t\t}\n\t\t}\n\t},\n\tgetBoundary: function () {\n\t\tthis.checkNotGeometryCollection(this);\n\t\tAssert.shouldNeverReachHere();\n\t\treturn null;\n\t},\n\tgetGeometryType: function () {\n\t\treturn Geometry.TYPENAME_GEOMETRYCOLLECTION;\n\t},\n\tcopy: function () {\n\t\tvar geometries = new Array(this._geometries.length).fill(null);\n\t\tfor (var i = 0; i < geometries.length; i++) {\n\t\t\tgeometries[i] = this._geometries[i].copy();\n\t\t}\n\t\treturn new GeometryCollection(geometries, this._factory);\n\t},\n\tisEmpty: function () {\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tif (!this._geometries[i].isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn GeometryCollection;\n\t}\n});\nGeometryCollection.serialVersionUID = -5694727726395021467;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/GeometryCollection.js\n// module id = 15\n// module chunks = 0","import Geometry from './Geometry';\nimport CoordinateFilter from './CoordinateFilter';\nimport hasInterface from '../../../../hasInterface';\nimport BoundaryOp from '../operation/BoundaryOp';\nimport Length from '../algorithm/Length';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../extend';\nimport Lineal from './Lineal';\nimport CoordinateSequences from './CoordinateSequences';\nimport GeometryComponentFilter from './GeometryComponentFilter';\nimport Dimension from './Dimension';\nimport GeometryFilter from './GeometryFilter';\nimport CoordinateSequenceFilter from './CoordinateSequenceFilter';\nimport Envelope from './Envelope';\nimport inherits from '../../../../inherits';\nexport default function LineString() {\n\tthis._points = null;\n\tlet points = arguments[0], factory = arguments[1];\n\tGeometry.call(this, factory);\n\tthis.init(points);\n}\ninherits(LineString, Geometry);\nextend(LineString.prototype, {\n\tcomputeEnvelopeInternal: function () {\n\t\tif (this.isEmpty()) {\n\t\t\treturn new Envelope();\n\t\t}\n\t\treturn this._points.expandEnvelope(new Envelope());\n\t},\n\tisRing: function () {\n\t\treturn this.isClosed() && this.isSimple();\n\t},\n\tgetCoordinates: function () {\n\t\treturn this._points.toCoordinateArray();\n\t},\n\tequalsExact: function () {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry)) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar otherLineString = other;\n\t\t\tif (this._points.size() !== otherLineString._points.size()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (var i = 0; i < this._points.size(); i++) {\n\t\t\t\tif (!this.equal(this._points.getCoordinate(i), otherLineString._points.getCoordinate(i), tolerance)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else return Geometry.prototype.equalsExact.apply(this, arguments);\n\t},\n\tnormalize: function () {\n\t\tfor (var i = 0; i < Math.trunc(this._points.size() / 2); i++) {\n\t\t\tvar j = this._points.size() - 1 - i;\n\t\t\tif (!this._points.getCoordinate(i).equals(this._points.getCoordinate(j))) {\n\t\t\t\tif (this._points.getCoordinate(i).compareTo(this._points.getCoordinate(j)) > 0) {\n\t\t\t\t\tvar copy = this._points.copy();\n\t\t\t\t\tCoordinateSequences.reverse(copy);\n\t\t\t\t\tthis._points = copy;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t},\n\tgetCoordinate: function () {\n\t\tif (this.isEmpty()) return null;\n\t\treturn this._points.getCoordinate(0);\n\t},\n\tgetBoundaryDimension: function () {\n\t\tif (this.isClosed()) {\n\t\t\treturn Dimension.FALSE;\n\t\t}\n\t\treturn 0;\n\t},\n\tisClosed: function () {\n\t\tif (this.isEmpty()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));\n\t},\n\tgetEndPoint: function () {\n\t\tif (this.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.getPointN(this.getNumPoints() - 1);\n\t},\n\tgetTypeCode: function () {\n\t\treturn Geometry.TYPECODE_LINESTRING;\n\t},\n\tgetDimension: function () {\n\t\treturn 1;\n\t},\n\tgetLength: function () {\n\t\treturn Length.ofLine(this._points);\n\t},\n\tgetNumPoints: function () {\n\t\treturn this._points.size();\n\t},\n\treverse: function () {\n\t\tvar seq = this._points.copy();\n\t\tCoordinateSequences.reverse(seq);\n\t\tvar revLine = this.getFactory().createLineString(seq);\n\t\treturn revLine;\n\t},\n\tcompareToSameClass: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet o = arguments[0];\n\t\t\tvar line = o;\n\t\t\tvar i = 0;\n\t\t\tvar j = 0;\n\t\t\twhile (i < this._points.size() && j < line._points.size()) {\n\t\t\t\tvar comparison = this._points.getCoordinate(i).compareTo(line._points.getCoordinate(j));\n\t\t\t\tif (comparison !== 0) {\n\t\t\t\t\treturn comparison;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif (i < this._points.size()) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (j < line._points.size()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet o = arguments[0], comp = arguments[1];\n\t\t\tvar line = o;\n\t\t\treturn comp.compare(this._points, line._points);\n\t\t}\n\t},\n\tapply: function () {\n\t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfor (var i = 0; i < this._points.size(); i++) {\n\t\t\t\tfilter.filter(this._points.getCoordinate(i));\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tif (this._points.size() === 0) return null;\n\t\t\tfor (var i = 0; i < this._points.size(); i++) {\n\t\t\t\tfilter.filter(this._points, i);\n\t\t\t\tif (filter.isDone()) break;\n\t\t\t}\n\t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n\t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t}\n\t},\n\tgetBoundary: function () {\n\t\treturn new BoundaryOp(this).getBoundary();\n\t},\n\tisEquivalentClass: function (other) {\n\t\treturn other instanceof LineString;\n\t},\n\tgetCoordinateN: function (n) {\n\t\treturn this._points.getCoordinate(n);\n\t},\n\tgetGeometryType: function () {\n\t\treturn Geometry.TYPENAME_LINESTRING;\n\t},\n\tcopy: function () {\n\t\treturn new LineString(this._points.copy(), this._factory);\n\t},\n\tgetCoordinateSequence: function () {\n\t\treturn this._points;\n\t},\n\tisEmpty: function () {\n\t\treturn this._points.size() === 0;\n\t},\n\tinit: function (points) {\n\t\tif (points === null) {\n\t\t\tpoints = this.getFactory().getCoordinateSequenceFactory().create([]);\n\t\t}\n\t\tif (points.size() === 1) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid number of points in LineString (found \" + points.size() + \" - must be 0 or >= 2)\");\n\t\t}\n\t\tthis._points = points;\n\t},\n\tisCoordinate: function (pt) {\n\t\tfor (var i = 0; i < this._points.size(); i++) {\n\t\t\tif (this._points.getCoordinate(i).equals(pt)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetStartPoint: function () {\n\t\tif (this.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.getPointN(0);\n\t},\n\tgetPointN: function (n) {\n\t\treturn this.getFactory().createPoint(this._points.getCoordinate(n));\n\t},\n\tinterfaces_: function () {\n\t\treturn [Lineal];\n\t},\n\tgetClass: function () {\n\t\treturn LineString;\n\t}\n});\nLineString.serialVersionUID = 3110669828065365560;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/LineString.js\n// module id = 16\n// module chunks = 0","export default function System () { }\n\nSystem.arraycopy = (src, srcPos, dest, destPos, len) => {\n  let c = 0\n  for (let i = srcPos; i < srcPos + len; i++) {\n    dest[destPos + c] = src[i]\n    c++\n  }\n}\n\nSystem.getProperty = (name) => {\n  return {\n    'line.separator': '\\n'\n  }[name]\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/lang/System.js\n// module id = 17\n// module chunks = 0","import StringBuffer from '../../../../java/lang/StringBuffer';\nimport Location from '../geom/Location';\nimport Position from './Position';\nimport extend from '../../../../extend';\nimport TopologyLocation from './TopologyLocation';\nexport default function Label() {\n\tthis.elt = new Array(2).fill(null);\n\tif (arguments.length === 1) {\n\t\tif (Number.isInteger(arguments[0])) {\n\t\t\tlet onLoc = arguments[0];\n\t\t\tthis.elt[0] = new TopologyLocation(onLoc);\n\t\t\tthis.elt[1] = new TopologyLocation(onLoc);\n\t\t} else if (arguments[0] instanceof Label) {\n\t\t\tlet lbl = arguments[0];\n\t\t\tthis.elt[0] = new TopologyLocation(lbl.elt[0]);\n\t\t\tthis.elt[1] = new TopologyLocation(lbl.elt[1]);\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tlet geomIndex = arguments[0], onLoc = arguments[1];\n\t\tthis.elt[0] = new TopologyLocation(Location.NONE);\n\t\tthis.elt[1] = new TopologyLocation(Location.NONE);\n\t\tthis.elt[geomIndex].setLocation(onLoc);\n\t} else if (arguments.length === 3) {\n\t\tlet onLoc = arguments[0], leftLoc = arguments[1], rightLoc = arguments[2];\n\t\tthis.elt[0] = new TopologyLocation(onLoc, leftLoc, rightLoc);\n\t\tthis.elt[1] = new TopologyLocation(onLoc, leftLoc, rightLoc);\n\t} else if (arguments.length === 4) {\n\t\tlet geomIndex = arguments[0], onLoc = arguments[1], leftLoc = arguments[2], rightLoc = arguments[3];\n\t\tthis.elt[0] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);\n\t\tthis.elt[1] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);\n\t\tthis.elt[geomIndex].setLocations(onLoc, leftLoc, rightLoc);\n\t}\n}\nextend(Label.prototype, {\n\tgetGeometryCount: function () {\n\t\tvar count = 0;\n\t\tif (!this.elt[0].isNull()) count++;\n\t\tif (!this.elt[1].isNull()) count++;\n\t\treturn count;\n\t},\n\tsetAllLocations: function (geomIndex, location) {\n\t\tthis.elt[geomIndex].setAllLocations(location);\n\t},\n\tisNull: function (geomIndex) {\n\t\treturn this.elt[geomIndex].isNull();\n\t},\n\tsetAllLocationsIfNull: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet location = arguments[0];\n\t\t\tthis.setAllLocationsIfNull(0, location);\n\t\t\tthis.setAllLocationsIfNull(1, location);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet geomIndex = arguments[0], location = arguments[1];\n\t\t\tthis.elt[geomIndex].setAllLocationsIfNull(location);\n\t\t}\n\t},\n\tisLine: function (geomIndex) {\n\t\treturn this.elt[geomIndex].isLine();\n\t},\n\tmerge: function (lbl) {\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (this.elt[i] === null && lbl.elt[i] !== null) {\n\t\t\t\tthis.elt[i] = new TopologyLocation(lbl.elt[i]);\n\t\t\t} else {\n\t\t\t\tthis.elt[i].merge(lbl.elt[i]);\n\t\t\t}\n\t\t}\n\t},\n\tflip: function () {\n\t\tthis.elt[0].flip();\n\t\tthis.elt[1].flip();\n\t},\n\tgetLocation: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet geomIndex = arguments[0];\n\t\t\treturn this.elt[geomIndex].get(Position.ON);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet geomIndex = arguments[0], posIndex = arguments[1];\n\t\t\treturn this.elt[geomIndex].get(posIndex);\n\t\t}\n\t},\n\ttoString: function () {\n\t\tvar buf = new StringBuffer();\n\t\tif (this.elt[0] !== null) {\n\t\t\tbuf.append(\"A:\");\n\t\t\tbuf.append(this.elt[0].toString());\n\t\t}\n\t\tif (this.elt[1] !== null) {\n\t\t\tbuf.append(\" B:\");\n\t\t\tbuf.append(this.elt[1].toString());\n\t\t}\n\t\treturn buf.toString();\n\t},\n\tisArea: function () {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.elt[0].isArea() || this.elt[1].isArea();\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet geomIndex = arguments[0];\n\t\t\treturn this.elt[geomIndex].isArea();\n\t\t}\n\t},\n\tisAnyNull: function (geomIndex) {\n\t\treturn this.elt[geomIndex].isAnyNull();\n\t},\n\tsetLocation: function () {\n\t\tif (arguments.length === 2) {\n\t\t\tlet geomIndex = arguments[0], location = arguments[1];\n\t\t\tthis.elt[geomIndex].setLocation(Position.ON, location);\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet geomIndex = arguments[0], posIndex = arguments[1], location = arguments[2];\n\t\t\tthis.elt[geomIndex].setLocation(posIndex, location);\n\t\t}\n\t},\n\tisEqualOnSide: function (lbl, side) {\n\t\treturn this.elt[0].isEqualOnSide(lbl.elt[0], side) && this.elt[1].isEqualOnSide(lbl.elt[1], side);\n\t},\n\tallPositionsEqual: function (geomIndex, loc) {\n\t\treturn this.elt[geomIndex].allPositionsEqual(loc);\n\t},\n\ttoLine: function (geomIndex) {\n\t\tif (this.elt[geomIndex].isArea()) this.elt[geomIndex] = new TopologyLocation(this.elt[geomIndex].location[0]);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Label;\n\t}\n});\nLabel.toLineLabel = function (label) {\n\tvar lineLabel = new Label(Location.NONE);\n\tfor (var i = 0; i < 2; i++) {\n\t\tlineLabel.setLocation(i, label.getLocation(i));\n\t}\n\treturn lineLabel;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geomgraph/Label.js\n// module id = 18\n// module chunks = 0","/**\n * OLE control base class.\n * @extends ol.control.Control\n * @alias ole.Control\n */\nclass Control extends ol.control.Control {\n  /**\n   * @inheritdoc\n   * @param {Object} options Control options.\n   * @param {string} options.className Name of the control's HTML class.\n   * @param {string} options.title Title of the control toolbar button.\n   * @param {Image} options.image Control toolbar image.\n   * @param {ol.source.Vector} [options.source] Vector source holding\n   *   edit features. If undefined, options.features must be passed.\n   * @param {ol.Collection<ol.Feature>} [options.features] Collection of\n   *   edit features. If undefined, options.source must be set.\n   * @param {boolean} [standalone] Boolean indicating whether the Control\n   *   can be  activated together with other controls, like ole.Draw.\n   */\n  constructor(options) {\n    const button = document.createElement('button');\n    button.className = `ole-control ${options.className}`;\n\n    super({\n      element: button,\n    });\n\n    /**\n     * Html class name of the control button\n     * @type {string}\n     * @private\n     */\n    this.className = options.className;\n\n    /**\n     * Control title.\n     * @type {string}\n     * @private\n     */\n    this.title = options.title;\n\n    const img = document.createElement('img');\n    img.src = options.image;\n\n    button.appendChild(img);\n    button.title = this.title;\n\n    /**\n     * Source with edit features.\n     * @type {ol.source.Vector}\n     * @private\n     */\n    this.source =\n      options.source ||\n      new ol.source.Vector({\n        features: options.features,\n      });\n\n    /**\n     * ole.Editor instance.\n     * @type {ole.Editor}\n     * @private\n     */\n    this.editor = null;\n\n    button.addEventListener('click', this.onClick.bind(this));\n\n    /**\n     * @type {Boolean}\n     * @private\n     */\n    this.standalone = true;\n  }\n\n  /**\n   * Returns the control's element.\n   * @returns {Element} the control element.\n   */\n  getElement() {\n    return this.element;\n  }\n\n  /**\n   * Click handler for the control element.\n   * @private\n   */\n  onClick() {\n    if (this.active) {\n      this.deactivate();\n    } else {\n      this.activate();\n    }\n  }\n\n  /**\n   * Sets the map of the control.\n   * @protected\n   * @param {ol.Map} map The map object.\n   */\n  setMap(map) {\n    this.map = map;\n    super.setMap(this.map);\n  }\n\n  /**\n   * Introduce the control to it's editor.\n   * @param {ole.Editor} editor OLE Editor.\n   * @protected\n   */\n  setEditor(editor) {\n    this.editor = editor;\n  }\n\n  /**\n   * Activate the control\n   */\n  activate() {\n    this.active = true;\n    this.element.className += ' active';\n    this.editor.activeStateChange(this);\n    this.openDialog();\n  }\n\n  /**\n   * Dectivate the control\n   */\n  deactivate() {\n    this.active = false;\n    this.element.classList.remove('active');\n    this.editor.activeStateChange(this);\n    this.closeDialog();\n  }\n\n  /**\n   * Returns the active state of the control.\n   * @returns {Boolean} Active state.\n   */\n  getActive() {\n    return this.active;\n  }\n\n  openDialog() {\n    if (this.dialogTemplate) {\n      this.dialogDiv = document.createElement('div');\n\n      this.dialogDiv.innerHTML = `\n        <div class=\"ole-dialog\">\n          ${this.dialogTemplate}\n        </div>\n      `;\n\n      this.map.getTargetElement().appendChild(this.dialogDiv);\n    }\n  }\n\n\n  /**\n   * Closes the control dialog.\n   * @private\n   */\n  closeDialog() {\n    if (this.dialogDiv) {\n      this.map.getTargetElement().removeChild(this.dialogDiv);\n    }\n  }\n}\n\nexport default Control;\n\n\n\n// WEBPACK FOOTER //\n// ./src/control/control.js","import extend from '../../../../extend';\nimport Cloneable from '../../../../java/lang/Cloneable';\nexport default function CoordinateSequence() {}\nextend(CoordinateSequence.prototype, {\n\tsetOrdinate: function (index, ordinateIndex, value) {},\n\tsize: function () {},\n\tgetOrdinate: function (index, ordinateIndex) {},\n\tgetCoordinate: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet i = arguments[0];\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet index = arguments[0], coord = arguments[1];\n\t\t}\n\t},\n\tgetCoordinateCopy: function (i) {},\n\tgetDimension: function () {},\n\tgetX: function (index) {},\n\texpandEnvelope: function (env) {},\n\tcopy: function () {},\n\tgetY: function (index) {},\n\ttoCoordinateArray: function () {},\n\tinterfaces_: function () {\n\t\treturn [Cloneable];\n\t},\n\tgetClass: function () {\n\t\treturn CoordinateSequence;\n\t}\n});\nCoordinateSequence.X = 0;\nCoordinateSequence.Y = 1;\nCoordinateSequence.Z = 2;\nCoordinateSequence.M = 3;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/CoordinateSequence.js\n// module id = 20\n// module chunks = 0","import Iterator from './Iterator'\n\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Collection.html\n *\n * @constructor\n * @private\n */\nexport default function Collection() {};\n\n/**\n * Ensures that this collection contains the specified element (optional\n * operation).\n * @param {Object} e\n * @return {boolean}\n */\nCollection.prototype.add = function() {};\n\n\n/**\n * Appends all of the elements in the specified collection to the end of this\n * list, in the order that they are returned by the specified collection's\n * iterator (optional operation).\n * @param {javascript.util.Collection} c\n * @return {boolean}\n */\nCollection.prototype.addAll = function() {};\n\n\n/**\n * Returns true if this collection contains no elements.\n * @return {boolean}\n */\nCollection.prototype.isEmpty = function() {};\n\n\n/**\n * Returns an iterator over the elements in this collection.\n * @return {javascript.util.Iterator}\n */\nCollection.prototype.iterator = function() {};\n\n\n/**\n * Returns an iterator over the elements in this collection.\n * @return {number}\n */\nCollection.prototype.size = function() {};\n\n\n/**\n * Returns an array containing all of the elements in this collection.\n * @return {Array}\n */\nCollection.prototype.toArray = function() {};\n\n\n/**\n * Removes a single instance of the specified element from this collection if it\n * is present. (optional)\n * @param {Object} e\n * @return {boolean}\n */\nCollection.prototype.remove = function() {};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/util/Collection.js\n// module id = 21\n// module chunks = 0","import CoordinateSequenceFactory from './CoordinateSequenceFactory';\nimport LineString from './LineString';\nimport Geometry from './Geometry';\nimport hasInterface from '../../../../hasInterface';\nimport Coordinate from './Coordinate';\nimport Point from './Point';\nimport Polygon from './Polygon';\nimport MultiPoint from './MultiPoint';\nimport GeometryEditor from './util/GeometryEditor';\nimport LinearRing from './LinearRing';\nimport extend from '../../../../extend';\nimport CoordinateArraySequenceFactory from './impl/CoordinateArraySequenceFactory';\nimport MultiPolygon from './MultiPolygon';\nimport CoordinateSequences from './CoordinateSequences';\nimport CoordinateSequence from './CoordinateSequence';\nimport GeometryCollection from './GeometryCollection';\nimport PrecisionModel from './PrecisionModel';\nimport Serializable from '../../../../java/io/Serializable';\nimport Assert from '../util/Assert';\nimport MultiLineString from './MultiLineString';\nexport default function GeometryFactory() {\n\tthis._precisionModel = null;\n\tthis._coordinateSequenceFactory = null;\n\tthis._SRID = null;\n\tif (arguments.length === 0) {\n\t\tGeometryFactory.call(this, new PrecisionModel(), 0);\n\t} else if (arguments.length === 1) {\n\t\tif (hasInterface(arguments[0], CoordinateSequenceFactory)) {\n\t\t\tlet coordinateSequenceFactory = arguments[0];\n\t\t\tGeometryFactory.call(this, new PrecisionModel(), 0, coordinateSequenceFactory);\n\t\t} else if (arguments[0] instanceof PrecisionModel) {\n\t\t\tlet precisionModel = arguments[0];\n\t\t\tGeometryFactory.call(this, precisionModel, 0, GeometryFactory.getDefaultCoordinateSequenceFactory());\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tlet precisionModel = arguments[0], SRID = arguments[1];\n\t\tGeometryFactory.call(this, precisionModel, SRID, GeometryFactory.getDefaultCoordinateSequenceFactory());\n\t} else if (arguments.length === 3) {\n\t\tlet precisionModel = arguments[0], SRID = arguments[1], coordinateSequenceFactory = arguments[2];\n\t\tthis._precisionModel = precisionModel;\n\t\tthis._coordinateSequenceFactory = coordinateSequenceFactory;\n\t\tthis._SRID = SRID;\n\t}\n}\nextend(GeometryFactory.prototype, {\n\ttoGeometry: function (envelope) {\n\t\tif (envelope.isNull()) {\n\t\t\treturn this.createPoint();\n\t\t}\n\t\tif (envelope.getMinX() === envelope.getMaxX() && envelope.getMinY() === envelope.getMaxY()) {\n\t\t\treturn this.createPoint(new Coordinate(envelope.getMinX(), envelope.getMinY()));\n\t\t}\n\t\tif (envelope.getMinX() === envelope.getMaxX() || envelope.getMinY() === envelope.getMaxY()) {\n\t\t\treturn this.createLineString([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY())]);\n\t\t}\n\t\treturn this.createPolygon(this.createLinearRing([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMinY())]), null);\n\t},\n\tcreateLineString: function () {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.createLineString(this.getCoordinateSequenceFactory().create([]));\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn this.createLineString(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn new LineString(coordinates, this);\n\t\t\t}\n\t\t}\n\t},\n\tcreateMultiLineString: function () {\n\t\tif (arguments.length === 0) {\n\t\t\treturn new MultiLineString(null, this);\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet lineStrings = arguments[0];\n\t\t\treturn new MultiLineString(lineStrings, this);\n\t\t}\n\t},\n\tbuildGeometry: function (geomList) {\n\t\tvar geomClass = null;\n\t\tvar isHeterogeneous = false;\n\t\tvar hasGeometryCollection = false;\n\t\tfor (var i = geomList.iterator(); i.hasNext(); ) {\n\t\t\tvar geom = i.next();\n\t\t\tvar partClass = geom.getClass();\n\t\t\tif (geomClass === null) {\n\t\t\t\tgeomClass = partClass;\n\t\t\t}\n\t\t\tif (partClass !== geomClass) {\n\t\t\t\tisHeterogeneous = true;\n\t\t\t}\n\t\t\tif (geom instanceof GeometryCollection) hasGeometryCollection = true;\n\t\t}\n\t\tif (geomClass === null) {\n\t\t\treturn this.createGeometryCollection();\n\t\t}\n\t\tif (isHeterogeneous || hasGeometryCollection) {\n\t\t\treturn this.createGeometryCollection(GeometryFactory.toGeometryArray(geomList));\n\t\t}\n\t\tvar geom0 = geomList.iterator().next();\n\t\tvar isCollection = geomList.size() > 1;\n\t\tif (isCollection) {\n\t\t\tif (geom0 instanceof Polygon) {\n\t\t\t\treturn this.createMultiPolygon(GeometryFactory.toPolygonArray(geomList));\n\t\t\t} else if (geom0 instanceof LineString) {\n\t\t\t\treturn this.createMultiLineString(GeometryFactory.toLineStringArray(geomList));\n\t\t\t} else if (geom0 instanceof Point) {\n\t\t\t\treturn this.createMultiPoint(GeometryFactory.toPointArray(geomList));\n\t\t\t}\n\t\t\tAssert.shouldNeverReachHere(\"Unhandled class: \" + geom0.getClass().getName());\n\t\t}\n\t\treturn geom0;\n\t},\n\tcreateMultiPointFromCoords: function (coordinates) {\n\t\treturn this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n\t},\n\tcreatePoint: function () {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.createPoint(this.getCoordinateSequenceFactory().create([]));\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet coordinate = arguments[0];\n\t\t\t\treturn this.createPoint(coordinate !== null ? this.getCoordinateSequenceFactory().create([coordinate]) : null);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn new Point(coordinates, this);\n\t\t\t}\n\t\t}\n\t},\n\tgetCoordinateSequenceFactory: function () {\n\t\treturn this._coordinateSequenceFactory;\n\t},\n\tcreatePolygon: function () {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.createPolygon(null, null);\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet shell = arguments[0];\n\t\t\t\treturn this.createPolygon(this.createLinearRing(shell));\n\t\t\t} else if (arguments[0] instanceof Array) {\n\t\t\t\tlet shell = arguments[0];\n\t\t\t\treturn this.createPolygon(this.createLinearRing(shell));\n\t\t\t} else if (arguments[0] instanceof LinearRing) {\n\t\t\t\tlet shell = arguments[0];\n\t\t\t\treturn this.createPolygon(shell, null);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet shell = arguments[0], holes = arguments[1];\n\t\t\treturn new Polygon(shell, holes, this);\n\t\t}\n\t},\n\tgetSRID: function () {\n\t\treturn this._SRID;\n\t},\n\tcreateGeometryCollection: function () {\n\t\tif (arguments.length === 0) {\n\t\t\treturn new GeometryCollection(null, this);\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet geometries = arguments[0];\n\t\t\treturn new GeometryCollection(geometries, this);\n\t\t}\n\t},\n\tcreateGeometry: function (g) {\n\t\tvar editor = new GeometryEditor(this);\n\t\treturn editor.edit(g, {\n\t\t\tedit: function () {\n\t\t\t\tif (arguments.length === 2 && (arguments[1] instanceof Geometry && hasInterface(arguments[0], CoordinateSequence))) {\n\t\t\t\t\tlet coordSeq = arguments[0], geometry = arguments[1];\n\t\t\t\t\treturn this._coordinateSequenceFactory.create(coordSeq);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n\tgetPrecisionModel: function () {\n\t\treturn this._precisionModel;\n\t},\n\tcreateLinearRing: function () {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.createLinearRing(this.getCoordinateSequenceFactory().create([]));\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn this.createLinearRing(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn new LinearRing(coordinates, this);\n\t\t\t}\n\t\t}\n\t},\n\tcreateMultiPolygon: function () {\n\t\tif (arguments.length === 0) {\n\t\t\treturn new MultiPolygon(null, this);\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet polygons = arguments[0];\n\t\t\treturn new MultiPolygon(polygons, this);\n\t\t}\n\t},\n\tcreateMultiPoint: function () {\n\t\tif (arguments.length === 0) {\n\t\t\treturn new MultiPoint(null, this);\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tlet point = arguments[0];\n\t\t\t\treturn new MultiPoint(point, this);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\tif (coordinates === null) {\n\t\t\t\t\treturn this.createMultiPoint(new Array(0).fill(null));\n\t\t\t\t}\n\t\t\t\tvar points = new Array(coordinates.size()).fill(null);\n\t\t\t\tfor (var i = 0; i < coordinates.size(); i++) {\n\t\t\t\t\tvar ptSeq = this.getCoordinateSequenceFactory().create(1, coordinates.getDimension());\n\t\t\t\t\tCoordinateSequences.copy(coordinates, i, ptSeq, 0, 1);\n\t\t\t\t\tpoints[i] = this.createPoint(ptSeq);\n\t\t\t\t}\n\t\t\t\treturn this.createMultiPoint(points);\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [Serializable];\n\t},\n\tgetClass: function () {\n\t\treturn GeometryFactory;\n\t}\n});\nGeometryFactory.toMultiPolygonArray = function (multiPolygons) {\n\tvar multiPolygonArray = new Array(multiPolygons.size()).fill(null);\n\treturn multiPolygons.toArray(multiPolygonArray);\n};\nGeometryFactory.toGeometryArray = function (geometries) {\n\tif (geometries === null) return null;\n\tvar geometryArray = new Array(geometries.size()).fill(null);\n\treturn geometries.toArray(geometryArray);\n};\nGeometryFactory.getDefaultCoordinateSequenceFactory = function () {\n\treturn CoordinateArraySequenceFactory.instance();\n};\nGeometryFactory.toMultiLineStringArray = function (multiLineStrings) {\n\tvar multiLineStringArray = new Array(multiLineStrings.size()).fill(null);\n\treturn multiLineStrings.toArray(multiLineStringArray);\n};\nGeometryFactory.toLineStringArray = function (lineStrings) {\n\tvar lineStringArray = new Array(lineStrings.size()).fill(null);\n\treturn lineStrings.toArray(lineStringArray);\n};\nGeometryFactory.toMultiPointArray = function (multiPoints) {\n\tvar multiPointArray = new Array(multiPoints.size()).fill(null);\n\treturn multiPoints.toArray(multiPointArray);\n};\nGeometryFactory.toLinearRingArray = function (linearRings) {\n\tvar linearRingArray = new Array(linearRings.size()).fill(null);\n\treturn linearRings.toArray(linearRingArray);\n};\nGeometryFactory.toPointArray = function (points) {\n\tvar pointArray = new Array(points.size()).fill(null);\n\treturn points.toArray(pointArray);\n};\nGeometryFactory.toPolygonArray = function (polygons) {\n\tvar polygonArray = new Array(polygons.size()).fill(null);\n\treturn polygons.toArray(polygonArray);\n};\nGeometryFactory.createPointFromInternalCoord = function (coord, exemplar) {\n\texemplar.getPrecisionModel().makePrecise(coord);\n\treturn exemplar.getFactory().createPoint(coord);\n};\nGeometryFactory.serialVersionUID = -6820524753094095635;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/GeometryFactory.js\n// module id = 22\n// module chunks = 0","import Coordinate from './Coordinate';\nimport extend from '../../../../extend';\nimport RuntimeException from '../../../../java/lang/RuntimeException';\nimport inherits from '../../../../inherits';\nexport default function TopologyException() {\n\tthis.pt = null;\n\tif (arguments.length === 1) {\n\t\tlet msg = arguments[0];\n\t\tRuntimeException.call(this, msg);\n\t} else if (arguments.length === 2) {\n\t\tlet msg = arguments[0], pt = arguments[1];\n\t\tRuntimeException.call(this, TopologyException.msgWithCoord(msg, pt));\n\t\tthis.name = 'TopologyException';\n\t\tthis.pt = new Coordinate(pt);\n\t}\n}\ninherits(TopologyException, RuntimeException);\nextend(TopologyException.prototype, {\n\tgetCoordinate: function () {\n\t\treturn this.pt;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn TopologyException;\n\t}\n});\nTopologyException.msgWithCoord = function (msg, pt) {\n\tif (pt !== null) return msg + \" [ \" + pt + \" ]\";\n\treturn msg;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/TopologyException.js\n// module id = 23\n// module chunks = 0","import CoordinateList from './CoordinateList';\nimport Coordinate from './Coordinate';\nimport extend from '../../../../extend';\nimport MathUtil from '../math/MathUtil';\nimport System from '../../../../java/lang/System';\nimport Comparator from '../../../../java/util/Comparator';\nimport Envelope from './Envelope';\nexport default function CoordinateArrays() {}\nextend(CoordinateArrays.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn CoordinateArrays;\n\t}\n});\nCoordinateArrays.isRing = function (pts) {\n\tif (pts.length < 4) return false;\n\tif (!pts[0].equals2D(pts[pts.length - 1])) return false;\n\treturn true;\n};\nCoordinateArrays.ptNotInList = function (testPts, pts) {\n\tfor (var i = 0; i < testPts.length; i++) {\n\t\tvar testPt = testPts[i];\n\t\tif (CoordinateArrays.indexOf(testPt, pts) < 0) return testPt;\n\t}\n\treturn null;\n};\nCoordinateArrays.scroll = function (coordinates, firstCoordinate) {\n\tvar i = CoordinateArrays.indexOf(firstCoordinate, coordinates);\n\tif (i < 0) return null;\n\tvar newCoordinates = new Array(coordinates.length).fill(null);\n\tSystem.arraycopy(coordinates, i, newCoordinates, 0, coordinates.length - i);\n\tSystem.arraycopy(coordinates, 0, newCoordinates, coordinates.length - i, i);\n\tSystem.arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length);\n};\nCoordinateArrays.equals = function () {\n\tif (arguments.length === 2) {\n\t\tlet coord1 = arguments[0], coord2 = arguments[1];\n\t\tif (coord1 === coord2) return true;\n\t\tif (coord1 === null || coord2 === null) return false;\n\t\tif (coord1.length !== coord2.length) return false;\n\t\tfor (var i = 0; i < coord1.length; i++) {\n\t\t\tif (!coord1[i].equals(coord2[i])) return false;\n\t\t}\n\t\treturn true;\n\t} else if (arguments.length === 3) {\n\t\tlet coord1 = arguments[0], coord2 = arguments[1], coordinateComparator = arguments[2];\n\t\tif (coord1 === coord2) return true;\n\t\tif (coord1 === null || coord2 === null) return false;\n\t\tif (coord1.length !== coord2.length) return false;\n\t\tfor (var i = 0; i < coord1.length; i++) {\n\t\t\tif (coordinateComparator.compare(coord1[i], coord2[i]) !== 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n};\nCoordinateArrays.intersection = function (coordinates, env) {\n\tvar coordList = new CoordinateList();\n\tfor (var i = 0; i < coordinates.length; i++) {\n\t\tif (env.intersects(coordinates[i])) coordList.add(coordinates[i], true);\n\t}\n\treturn coordList.toCoordinateArray();\n};\nCoordinateArrays.hasRepeatedPoints = function (coord) {\n\tfor (var i = 1; i < coord.length; i++) {\n\t\tif (coord[i - 1].equals(coord[i])) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n};\nCoordinateArrays.removeRepeatedPoints = function (coord) {\n\tif (!CoordinateArrays.hasRepeatedPoints(coord)) return coord;\n\tvar coordList = new CoordinateList(coord, false);\n\treturn coordList.toCoordinateArray();\n};\nCoordinateArrays.reverse = function (coord) {\n\tvar last = coord.length - 1;\n\tvar mid = Math.trunc(last / 2);\n\tfor (var i = 0; i <= mid; i++) {\n\t\tvar tmp = coord[i];\n\t\tcoord[i] = coord[last - i];\n\t\tcoord[last - i] = tmp;\n\t}\n};\nCoordinateArrays.removeNull = function (coord) {\n\tvar nonNull = 0;\n\tfor (var i = 0; i < coord.length; i++) {\n\t\tif (coord[i] !== null) nonNull++;\n\t}\n\tvar newCoord = new Array(nonNull).fill(null);\n\tif (nonNull === 0) return newCoord;\n\tvar j = 0;\n\tfor (var i = 0; i < coord.length; i++) {\n\t\tif (coord[i] !== null) newCoord[j++] = coord[i];\n\t}\n\treturn newCoord;\n};\nCoordinateArrays.copyDeep = function () {\n\tif (arguments.length === 1) {\n\t\tlet coordinates = arguments[0];\n\t\tvar copy = new Array(coordinates.length).fill(null);\n\t\tfor (var i = 0; i < coordinates.length; i++) {\n\t\t\tcopy[i] = new Coordinate(coordinates[i]);\n\t\t}\n\t\treturn copy;\n\t} else if (arguments.length === 5) {\n\t\tlet src = arguments[0], srcStart = arguments[1], dest = arguments[2], destStart = arguments[3], length = arguments[4];\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tdest[destStart + i] = new Coordinate(src[srcStart + i]);\n\t\t}\n\t}\n};\nCoordinateArrays.isEqualReversed = function (pts1, pts2) {\n\tfor (var i = 0; i < pts1.length; i++) {\n\t\tvar p1 = pts1[i];\n\t\tvar p2 = pts2[pts1.length - i - 1];\n\t\tif (p1.compareTo(p2) !== 0) return false;\n\t}\n\treturn true;\n};\nCoordinateArrays.envelope = function (coordinates) {\n\tvar env = new Envelope();\n\tfor (var i = 0; i < coordinates.length; i++) {\n\t\tenv.expandToInclude(coordinates[i]);\n\t}\n\treturn env;\n};\nCoordinateArrays.toCoordinateArray = function (coordList) {\n\treturn coordList.toArray(CoordinateArrays.coordArrayType);\n};\nCoordinateArrays.atLeastNCoordinatesOrNothing = function (n, c) {\n\treturn c.length >= n ? c : [];\n};\nCoordinateArrays.indexOf = function (coordinate, coordinates) {\n\tfor (var i = 0; i < coordinates.length; i++) {\n\t\tif (coordinate.equals(coordinates[i])) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\nCoordinateArrays.increasingDirection = function (pts) {\n\tfor (var i = 0; i < Math.trunc(pts.length / 2); i++) {\n\t\tvar j = pts.length - 1 - i;\n\t\tvar comp = pts[i].compareTo(pts[j]);\n\t\tif (comp !== 0) return comp;\n\t}\n\treturn 1;\n};\nCoordinateArrays.compare = function (pts1, pts2) {\n\tvar i = 0;\n\twhile (i < pts1.length && i < pts2.length) {\n\t\tvar compare = pts1[i].compareTo(pts2[i]);\n\t\tif (compare !== 0) return compare;\n\t\ti++;\n\t}\n\tif (i < pts2.length) return -1;\n\tif (i < pts1.length) return 1;\n\treturn 0;\n};\nCoordinateArrays.minCoordinate = function (coordinates) {\n\tvar minCoord = null;\n\tfor (var i = 0; i < coordinates.length; i++) {\n\t\tif (minCoord === null || minCoord.compareTo(coordinates[i]) > 0) {\n\t\t\tminCoord = coordinates[i];\n\t\t}\n\t}\n\treturn minCoord;\n};\nCoordinateArrays.extract = function (pts, start, end) {\n\tstart = MathUtil.clamp(start, 0, pts.length);\n\tend = MathUtil.clamp(end, -1, pts.length);\n\tvar npts = end - start + 1;\n\tif (end < 0) npts = 0;\n\tif (start >= pts.length) npts = 0;\n\tif (end < start) npts = 0;\n\tvar extractPts = new Array(npts).fill(null);\n\tif (npts === 0) return extractPts;\n\tvar iPts = 0;\n\tfor (var i = start; i <= end; i++) {\n\t\textractPts[iPts++] = pts[i];\n\t}\n\treturn extractPts;\n};\nfunction ForwardComparator() {}\nextend(ForwardComparator.prototype, {\n\tcompare: function (o1, o2) {\n\t\tvar pts1 = o1;\n\t\tvar pts2 = o2;\n\t\treturn CoordinateArrays.compare(pts1, pts2);\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparator];\n\t},\n\tgetClass: function () {\n\t\treturn ForwardComparator;\n\t}\n});\nfunction BidirectionalComparator() {}\nextend(BidirectionalComparator.prototype, {\n\tcompare: function (o1, o2) {\n\t\tvar pts1 = o1;\n\t\tvar pts2 = o2;\n\t\tif (pts1.length < pts2.length) return -1;\n\t\tif (pts1.length > pts2.length) return 1;\n\t\tif (pts1.length === 0) return 0;\n\t\tvar forwardComp = CoordinateArrays.compare(pts1, pts2);\n\t\tvar isEqualRev = CoordinateArrays.isEqualReversed(pts1, pts2);\n\t\tif (isEqualRev) return 0;\n\t\treturn forwardComp;\n\t},\n\tOLDcompare: function (o1, o2) {\n\t\tvar pts1 = o1;\n\t\tvar pts2 = o2;\n\t\tif (pts1.length < pts2.length) return -1;\n\t\tif (pts1.length > pts2.length) return 1;\n\t\tif (pts1.length === 0) return 0;\n\t\tvar dir1 = CoordinateArrays.increasingDirection(pts1);\n\t\tvar dir2 = CoordinateArrays.increasingDirection(pts2);\n\t\tvar i1 = dir1 > 0 ? 0 : pts1.length - 1;\n\t\tvar i2 = dir2 > 0 ? 0 : pts1.length - 1;\n\t\tfor (var i = 0; i < pts1.length; i++) {\n\t\t\tvar comparePt = pts1[i1].compareTo(pts2[i2]);\n\t\t\tif (comparePt !== 0) return comparePt;\n\t\t\ti1 += dir1;\n\t\t\ti2 += dir2;\n\t\t}\n\t\treturn 0;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparator];\n\t},\n\tgetClass: function () {\n\t\treturn BidirectionalComparator;\n\t}\n});\nCoordinateArrays.ForwardComparator = ForwardComparator;\nCoordinateArrays.BidirectionalComparator = BidirectionalComparator;\nCoordinateArrays.coordArrayType = new Array(0).fill(null);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/CoordinateArrays.js\n// module id = 25\n// module chunks = 0","import Geometry from './Geometry';\nimport BoundaryOp from '../operation/BoundaryOp';\nimport extend from '../../../../extend';\nimport Lineal from './Lineal';\nimport GeometryCollection from './GeometryCollection';\nimport Dimension from './Dimension';\nimport inherits from '../../../../inherits';\nexport default function MultiLineString() {\n\tlet lineStrings = arguments[0], factory = arguments[1];\n\tGeometryCollection.call(this, lineStrings, factory);\n}\ninherits(MultiLineString, GeometryCollection);\nextend(MultiLineString.prototype, {\n\tequalsExact: function () {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry)) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn GeometryCollection.prototype.equalsExact.call(this, other, tolerance);\n\t\t} else return GeometryCollection.prototype.equalsExact.apply(this, arguments);\n\t},\n\tgetBoundaryDimension: function () {\n\t\tif (this.isClosed()) {\n\t\t\treturn Dimension.FALSE;\n\t\t}\n\t\treturn 0;\n\t},\n\tisClosed: function () {\n\t\tif (this.isEmpty()) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tif (!this._geometries[i].isClosed()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\tgetTypeCode: function () {\n\t\treturn Geometry.TYPECODE_MULTILINESTRING;\n\t},\n\tgetDimension: function () {\n\t\treturn 1;\n\t},\n\treverse: function () {\n\t\tvar nLines = this._geometries.length;\n\t\tvar revLines = new Array(nLines).fill(null);\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\trevLines[nLines - 1 - i] = this._geometries[i].reverse();\n\t\t}\n\t\treturn this.getFactory().createMultiLineString(revLines);\n\t},\n\tgetBoundary: function () {\n\t\treturn new BoundaryOp(this).getBoundary();\n\t},\n\tgetGeometryType: function () {\n\t\treturn Geometry.TYPENAME_MULTILINESTRING;\n\t},\n\tcopy: function () {\n\t\tvar lineStrings = new Array(this._geometries.length).fill(null);\n\t\tfor (var i = 0; i < lineStrings.length; i++) {\n\t\t\tlineStrings[i] = this._geometries[i].copy();\n\t\t}\n\t\treturn new MultiLineString(lineStrings, this._factory);\n\t},\n\tinterfaces_: function () {\n\t\treturn [Lineal];\n\t},\n\tgetClass: function () {\n\t\treturn MultiLineString;\n\t}\n});\nMultiLineString.serialVersionUID = 8166665132445433741;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/MultiLineString.js\n// module id = 26\n// module chunks = 0","import IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../extend';\nimport Character from '../../../../java/lang/Character';\nexport default function Dimension() {}\nextend(Dimension.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Dimension;\n\t}\n});\nDimension.toDimensionSymbol = function (dimensionValue) {\n\tswitch (dimensionValue) {\n\t\tcase Dimension.FALSE:\n\t\t\treturn Dimension.SYM_FALSE;\n\t\tcase Dimension.TRUE:\n\t\t\treturn Dimension.SYM_TRUE;\n\t\tcase Dimension.DONTCARE:\n\t\t\treturn Dimension.SYM_DONTCARE;\n\t\tcase Dimension.P:\n\t\t\treturn Dimension.SYM_P;\n\t\tcase Dimension.L:\n\t\t\treturn Dimension.SYM_L;\n\t\tcase Dimension.A:\n\t\t\treturn Dimension.SYM_A;\n\t}\n\tthrow new IllegalArgumentException(\"Unknown dimension value: \" + dimensionValue);\n};\nDimension.toDimensionValue = function (dimensionSymbol) {\n\tswitch (Character.toUpperCase(dimensionSymbol)) {\n\t\tcase Dimension.SYM_FALSE:\n\t\t\treturn Dimension.FALSE;\n\t\tcase Dimension.SYM_TRUE:\n\t\t\treturn Dimension.TRUE;\n\t\tcase Dimension.SYM_DONTCARE:\n\t\t\treturn Dimension.DONTCARE;\n\t\tcase Dimension.SYM_P:\n\t\t\treturn Dimension.P;\n\t\tcase Dimension.SYM_L:\n\t\t\treturn Dimension.L;\n\t\tcase Dimension.SYM_A:\n\t\t\treturn Dimension.A;\n\t}\n\tthrow new IllegalArgumentException(\"Unknown dimension symbol: \" + dimensionSymbol);\n};\nDimension.P = 0;\nDimension.L = 1;\nDimension.A = 2;\nDimension.FALSE = -1;\nDimension.TRUE = -2;\nDimension.DONTCARE = -3;\nDimension.SYM_FALSE = 'F';\nDimension.SYM_TRUE = 'T';\nDimension.SYM_DONTCARE = '*';\nDimension.SYM_P = '0';\nDimension.SYM_L = '1';\nDimension.SYM_A = '2';\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/Dimension.js\n// module id = 27\n// module chunks = 0","import Area from '../algorithm/Area';\nimport Geometry from './Geometry';\nimport Arrays from '../../../../java/util/Arrays';\nimport CoordinateFilter from './CoordinateFilter';\nimport hasInterface from '../../../../hasInterface';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../extend';\nimport Orientation from '../algorithm/Orientation';\nimport System from '../../../../java/lang/System';\nimport GeometryComponentFilter from './GeometryComponentFilter';\nimport CoordinateArrays from './CoordinateArrays';\nimport Polygonal from './Polygonal';\nimport GeometryFilter from './GeometryFilter';\nimport CoordinateSequenceFilter from './CoordinateSequenceFilter';\nimport inherits from '../../../../inherits';\nexport default function Polygon() {\n\tthis._shell = null;\n\tthis._holes = null;\n\tlet shell = arguments[0], holes = arguments[1], factory = arguments[2];\n\tGeometry.call(this, factory);\n\tif (shell === null) {\n\t\tshell = this.getFactory().createLinearRing();\n\t}\n\tif (holes === null) {\n\t\tholes = [];\n\t}\n\tif (Geometry.hasNullElements(holes)) {\n\t\tthrow new IllegalArgumentException(\"holes must not contain null elements\");\n\t}\n\tif (shell.isEmpty() && Geometry.hasNonEmptyElements(holes)) {\n\t\tthrow new IllegalArgumentException(\"shell is empty but holes are not\");\n\t}\n\tthis._shell = shell;\n\tthis._holes = holes;\n}\ninherits(Polygon, Geometry);\nextend(Polygon.prototype, {\n\tcomputeEnvelopeInternal: function () {\n\t\treturn this._shell.getEnvelopeInternal();\n\t},\n\tgetCoordinates: function () {\n\t\tif (this.isEmpty()) {\n\t\t\treturn [];\n\t\t}\n\t\tvar coordinates = new Array(this.getNumPoints()).fill(null);\n\t\tvar k = -1;\n\t\tvar shellCoordinates = this._shell.getCoordinates();\n\t\tfor (var x = 0; x < shellCoordinates.length; x++) {\n\t\t\tk++;\n\t\t\tcoordinates[k] = shellCoordinates[x];\n\t\t}\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tvar childCoordinates = this._holes[i].getCoordinates();\n\t\t\tfor (var j = 0; j < childCoordinates.length; j++) {\n\t\t\t\tk++;\n\t\t\t\tcoordinates[k] = childCoordinates[j];\n\t\t\t}\n\t\t}\n\t\treturn coordinates;\n\t},\n\tgetArea: function () {\n\t\tvar area = 0.0;\n\t\tarea += Area.ofRing(this._shell.getCoordinateSequence());\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tarea -= Area.ofRing(this._holes[i].getCoordinateSequence());\n\t\t}\n\t\treturn area;\n\t},\n\tisRectangle: function () {\n\t\tif (this.getNumInteriorRing() !== 0) return false;\n\t\tif (this._shell === null) return false;\n\t\tif (this._shell.getNumPoints() !== 5) return false;\n\t\tvar seq = this._shell.getCoordinateSequence();\n\t\tvar env = this.getEnvelopeInternal();\n\t\tfor (var i = 0; i < 5; i++) {\n\t\t\tvar x = seq.getX(i);\n\t\t\tif (!(x === env.getMinX() || x === env.getMaxX())) return false;\n\t\t\tvar y = seq.getY(i);\n\t\t\tif (!(y === env.getMinY() || y === env.getMaxY())) return false;\n\t\t}\n\t\tvar prevX = seq.getX(0);\n\t\tvar prevY = seq.getY(0);\n\t\tfor (var i = 1; i <= 4; i++) {\n\t\t\tvar x = seq.getX(i);\n\t\t\tvar y = seq.getY(i);\n\t\t\tvar xChanged = x !== prevX;\n\t\t\tvar yChanged = y !== prevY;\n\t\t\tif (xChanged === yChanged) return false;\n\t\t\tprevX = x;\n\t\t\tprevY = y;\n\t\t}\n\t\treturn true;\n\t},\n\tequalsExact: function () {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry)) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar otherPolygon = other;\n\t\t\tvar thisShell = this._shell;\n\t\t\tvar otherPolygonShell = otherPolygon._shell;\n\t\t\tif (!thisShell.equalsExact(otherPolygonShell, tolerance)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this._holes.length !== otherPolygon._holes.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\t\tif (!this._holes[i].equalsExact(otherPolygon._holes[i], tolerance)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else return Geometry.prototype.equalsExact.apply(this, arguments);\n\t},\n\tnormalize: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tthis.normalize(this._shell, true);\n\t\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\t\tthis.normalize(this._holes[i], false);\n\t\t\t}\n\t\t\tArrays.sort(this._holes);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet ring = arguments[0], clockwise = arguments[1];\n\t\t\tif (ring.isEmpty()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar uniqueCoordinates = new Array(ring.getCoordinates().length - 1).fill(null);\n\t\t\tSystem.arraycopy(ring.getCoordinates(), 0, uniqueCoordinates, 0, uniqueCoordinates.length);\n\t\t\tvar minCoordinate = CoordinateArrays.minCoordinate(ring.getCoordinates());\n\t\t\tCoordinateArrays.scroll(uniqueCoordinates, minCoordinate);\n\t\t\tSystem.arraycopy(uniqueCoordinates, 0, ring.getCoordinates(), 0, uniqueCoordinates.length);\n\t\t\tring.getCoordinates()[uniqueCoordinates.length] = uniqueCoordinates[0];\n\t\t\tif (Orientation.isCCW(ring.getCoordinates()) === clockwise) {\n\t\t\t\tCoordinateArrays.reverse(ring.getCoordinates());\n\t\t\t}\n\t\t}\n\t},\n\tgetCoordinate: function () {\n\t\treturn this._shell.getCoordinate();\n\t},\n\tgetNumInteriorRing: function () {\n\t\treturn this._holes.length;\n\t},\n\tgetBoundaryDimension: function () {\n\t\treturn 1;\n\t},\n\tgetTypeCode: function () {\n\t\treturn Geometry.TYPECODE_POLYGON;\n\t},\n\tgetDimension: function () {\n\t\treturn 2;\n\t},\n\tgetLength: function () {\n\t\tvar len = 0.0;\n\t\tlen += this._shell.getLength();\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tlen += this._holes[i].getLength();\n\t\t}\n\t\treturn len;\n\t},\n\tgetNumPoints: function () {\n\t\tvar numPoints = this._shell.getNumPoints();\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tnumPoints += this._holes[i].getNumPoints();\n\t\t}\n\t\treturn numPoints;\n\t},\n\treverse: function () {\n\t\tvar poly = this.copy();\n\t\tpoly._shell = this._shell.copy().reverse();\n\t\tpoly._holes = new Array(this._holes.length).fill(null);\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tpoly._holes[i] = this._holes[i].copy().reverse();\n\t\t}\n\t\treturn poly;\n\t},\n\tconvexHull: function () {\n\t\treturn this.getExteriorRing().convexHull();\n\t},\n\tcompareToSameClass: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet o = arguments[0];\n\t\t\tvar thisShell = this._shell;\n\t\t\tvar otherShell = o._shell;\n\t\t\treturn thisShell.compareToSameClass(otherShell);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet o = arguments[0], comp = arguments[1];\n\t\t\tvar poly = o;\n\t\t\tvar thisShell = this._shell;\n\t\t\tvar otherShell = poly._shell;\n\t\t\tvar shellComp = thisShell.compareToSameClass(otherShell, comp);\n\t\t\tif (shellComp !== 0) return shellComp;\n\t\t\tvar nHole1 = this.getNumInteriorRing();\n\t\t\tvar nHole2 = poly.getNumInteriorRing();\n\t\t\tvar i = 0;\n\t\t\twhile (i < nHole1 && i < nHole2) {\n\t\t\t\tvar thisHole = this.getInteriorRingN(i);\n\t\t\t\tvar otherHole = poly.getInteriorRingN(i);\n\t\t\t\tvar holeComp = thisHole.compareToSameClass(otherHole, comp);\n\t\t\t\tif (holeComp !== 0) return holeComp;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i < nHole1) return 1;\n\t\t\tif (i < nHole2) return -1;\n\t\t\treturn 0;\n\t\t}\n\t},\n\tapply: function () {\n\t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tthis._shell.apply(filter);\n\t\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\t\tthis._holes[i].apply(filter);\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tthis._shell.apply(filter);\n\t\t\tif (!filter.isDone()) {\n\t\t\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\t\t\tthis._holes[i].apply(filter);\n\t\t\t\t\tif (filter.isDone()) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n\t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t\tthis._shell.apply(filter);\n\t\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\t\tthis._holes[i].apply(filter);\n\t\t\t}\n\t\t}\n\t},\n\tgetBoundary: function () {\n\t\tif (this.isEmpty()) {\n\t\t\treturn this.getFactory().createMultiLineString();\n\t\t}\n\t\tvar rings = new Array(this._holes.length + 1).fill(null);\n\t\trings[0] = this._shell;\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\trings[i + 1] = this._holes[i];\n\t\t}\n\t\tif (rings.length <= 1) return this.getFactory().createLinearRing(rings[0].getCoordinateSequence());\n\t\treturn this.getFactory().createMultiLineString(rings);\n\t},\n\tgetGeometryType: function () {\n\t\treturn Geometry.TYPENAME_POLYGON;\n\t},\n\tcopy: function () {\n\t\tvar shellCopy = this._shell.copy();\n\t\tvar holeCopies = new Array(this._holes.length).fill(null);\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tholeCopies[i] = this._holes[i].copy();\n\t\t}\n\t\treturn new Polygon(shellCopy, holeCopies, this._factory);\n\t},\n\tgetExteriorRing: function () {\n\t\treturn this._shell;\n\t},\n\tisEmpty: function () {\n\t\treturn this._shell.isEmpty();\n\t},\n\tgetInteriorRingN: function (n) {\n\t\treturn this._holes[n];\n\t},\n\tinterfaces_: function () {\n\t\treturn [Polygonal];\n\t},\n\tgetClass: function () {\n\t\treturn Polygon;\n\t}\n});\nPolygon.serialVersionUID = -3494792200821764533;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/Polygon.js\n// module id = 28\n// module chunks = 0","import LineString from './LineString';\nimport Geometry from './Geometry';\nimport hasInterface from '../../../../hasInterface';\nimport GeometryFactory from './GeometryFactory';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../extend';\nimport CoordinateSequences from './CoordinateSequences';\nimport CoordinateSequence from './CoordinateSequence';\nimport Dimension from './Dimension';\nimport inherits from '../../../../inherits';\nexport default function LinearRing() {\n\tif (arguments[0] instanceof Array && arguments[1] instanceof GeometryFactory) {\n\t\tlet points = arguments[0], factory = arguments[1];\n\t\tLinearRing.call(this, factory.getCoordinateSequenceFactory().create(points), factory);\n\t} else if (hasInterface(arguments[0], CoordinateSequence) && arguments[1] instanceof GeometryFactory) {\n\t\tlet points = arguments[0], factory = arguments[1];\n\t\tLineString.call(this, points, factory);\n\t\tthis.validateConstruction();\n\t}\n}\ninherits(LinearRing, LineString);\nextend(LinearRing.prototype, {\n\tgetBoundaryDimension: function () {\n\t\treturn Dimension.FALSE;\n\t},\n\tisClosed: function () {\n\t\tif (this.isEmpty()) {\n\t\t\treturn true;\n\t\t}\n\t\treturn LineString.prototype.isClosed.call(this);\n\t},\n\tgetTypeCode: function () {\n\t\treturn Geometry.TYPECODE_LINEARRING;\n\t},\n\treverse: function () {\n\t\tvar seq = this._points.copy();\n\t\tCoordinateSequences.reverse(seq);\n\t\tvar rev = this.getFactory().createLinearRing(seq);\n\t\treturn rev;\n\t},\n\tvalidateConstruction: function () {\n\t\tif (!this.isEmpty() && !LineString.prototype.isClosed.call(this)) {\n\t\t\tthrow new IllegalArgumentException(\"Points of LinearRing do not form a closed linestring\");\n\t\t}\n\t\tif (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < LinearRing.MINIMUM_VALID_SIZE) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid number of points in LinearRing (found \" + this.getCoordinateSequence().size() + \" - must be 0 or >= 4)\");\n\t\t}\n\t},\n\tgetGeometryType: function () {\n\t\treturn Geometry.TYPENAME_LINEARRING;\n\t},\n\tcopy: function () {\n\t\treturn new LinearRing(this._points.copy(), this._factory);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn LinearRing;\n\t}\n});\nLinearRing.MINIMUM_VALID_SIZE = 4;\nLinearRing.serialVersionUID = -4261142084085851829;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/LinearRing.js\n// module id = 29\n// module chunks = 0","import PointLocator from '../../algorithm/PointLocator';\nimport Location from '../../geom/Location';\nimport EdgeNodingValidator from '../../geomgraph/EdgeNodingValidator';\nimport GeometryCollectionMapper from '../../geom/util/GeometryCollectionMapper';\nimport PolygonBuilder from './PolygonBuilder';\nimport Position from '../../geomgraph/Position';\nimport IllegalArgumentException from '../../../../../java/lang/IllegalArgumentException';\nimport LineBuilder from './LineBuilder';\nimport PointBuilder from './PointBuilder';\nimport SnapIfNeededOverlayOp from './snap/SnapIfNeededOverlayOp';\nimport extend from '../../../../../extend';\nimport Label from '../../geomgraph/Label';\nimport OverlayNodeFactory from './OverlayNodeFactory';\nimport GeometryGraphOperation from '../GeometryGraphOperation';\nimport EdgeList from '../../geomgraph/EdgeList';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Assert from '../../util/Assert';\nimport inherits from '../../../../../inherits';\nimport PlanarGraph from '../../geomgraph/PlanarGraph';\nexport default function OverlayOp() {\n\tthis._ptLocator = new PointLocator();\n\tthis._geomFact = null;\n\tthis._resultGeom = null;\n\tthis._graph = null;\n\tthis._edgeList = new EdgeList();\n\tthis._resultPolyList = new ArrayList();\n\tthis._resultLineList = new ArrayList();\n\tthis._resultPointList = new ArrayList();\n\tlet g0 = arguments[0], g1 = arguments[1];\n\tGeometryGraphOperation.call(this, g0, g1);\n\tthis._graph = new PlanarGraph(new OverlayNodeFactory());\n\tthis._geomFact = g0.getFactory();\n}\ninherits(OverlayOp, GeometryGraphOperation);\nextend(OverlayOp.prototype, {\n\tinsertUniqueEdge: function (e) {\n\t\tvar existingEdge = this._edgeList.findEqualEdge(e);\n\t\tif (existingEdge !== null) {\n\t\t\tvar existingLabel = existingEdge.getLabel();\n\t\t\tvar labelToMerge = e.getLabel();\n\t\t\tif (!existingEdge.isPointwiseEqual(e)) {\n\t\t\t\tlabelToMerge = new Label(e.getLabel());\n\t\t\t\tlabelToMerge.flip();\n\t\t\t}\n\t\t\tvar depth = existingEdge.getDepth();\n\t\t\tif (depth.isNull()) {\n\t\t\t\tdepth.add(existingLabel);\n\t\t\t}\n\t\t\tdepth.add(labelToMerge);\n\t\t\texistingLabel.merge(labelToMerge);\n\t\t} else {\n\t\t\tthis._edgeList.add(e);\n\t\t}\n\t},\n\tgetGraph: function () {\n\t\treturn this._graph;\n\t},\n\tcancelDuplicateResultEdges: function () {\n\t\tfor (var it = this._graph.getEdgeEnds().iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tvar sym = de.getSym();\n\t\t\tif (de.isInResult() && sym.isInResult()) {\n\t\t\t\tde.setInResult(false);\n\t\t\t\tsym.setInResult(false);\n\t\t\t}\n\t\t}\n\t},\n\tisCoveredByLA: function (coord) {\n\t\tif (this.isCovered(coord, this._resultLineList)) return true;\n\t\tif (this.isCovered(coord, this._resultPolyList)) return true;\n\t\treturn false;\n\t},\n\tcomputeGeometry: function (resultPointList, resultLineList, resultPolyList, opcode) {\n\t\tvar geomList = new ArrayList();\n\t\tgeomList.addAll(resultPointList);\n\t\tgeomList.addAll(resultLineList);\n\t\tgeomList.addAll(resultPolyList);\n\t\tif (geomList.isEmpty()) return OverlayOp.createEmptyResult(opcode, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact);\n\t\treturn this._geomFact.buildGeometry(geomList);\n\t},\n\tmergeSymLabels: function () {\n\t\tfor (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext(); ) {\n\t\t\tvar node = nodeit.next();\n\t\t\tnode.getEdges().mergeSymLabels();\n\t\t}\n\t},\n\tisCovered: function (coord, geomList) {\n\t\tfor (var it = geomList.iterator(); it.hasNext(); ) {\n\t\t\tvar geom = it.next();\n\t\t\tvar loc = this._ptLocator.locate(coord, geom);\n\t\t\tif (loc !== Location.EXTERIOR) return true;\n\t\t}\n\t\treturn false;\n\t},\n\treplaceCollapsedEdges: function () {\n\t\tvar newEdges = new ArrayList();\n\t\tfor (var it = this._edgeList.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tif (e.isCollapsed()) {\n\t\t\t\tit.remove();\n\t\t\t\tnewEdges.add(e.getCollapsedEdge());\n\t\t\t}\n\t\t}\n\t\tthis._edgeList.addAll(newEdges);\n\t},\n\tupdateNodeLabelling: function () {\n\t\tfor (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext(); ) {\n\t\t\tvar node = nodeit.next();\n\t\t\tvar lbl = node.getEdges().getLabel();\n\t\t\tnode.getLabel().merge(lbl);\n\t\t}\n\t},\n\tgetResultGeometry: function (overlayOpCode) {\n\t\tthis.computeOverlay(overlayOpCode);\n\t\treturn this._resultGeom;\n\t},\n\tinsertUniqueEdges: function (edges) {\n\t\tfor (var i = edges.iterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\tthis.insertUniqueEdge(e);\n\t\t}\n\t},\n\tcomputeOverlay: function (opCode) {\n\t\tthis.copyPoints(0);\n\t\tthis.copyPoints(1);\n\t\tthis._arg[0].computeSelfNodes(this._li, false);\n\t\tthis._arg[1].computeSelfNodes(this._li, false);\n\t\tthis._arg[0].computeEdgeIntersections(this._arg[1], this._li, true);\n\t\tvar baseSplitEdges = new ArrayList();\n\t\tthis._arg[0].computeSplitEdges(baseSplitEdges);\n\t\tthis._arg[1].computeSplitEdges(baseSplitEdges);\n\t\tvar splitEdges = baseSplitEdges;\n\t\tthis.insertUniqueEdges(baseSplitEdges);\n\t\tthis.computeLabelsFromDepths();\n\t\tthis.replaceCollapsedEdges();\n\t\tEdgeNodingValidator.checkValid(this._edgeList.getEdges());\n\t\tthis._graph.addEdges(this._edgeList.getEdges());\n\t\tthis.computeLabelling();\n\t\tthis.labelIncompleteNodes();\n\t\tthis.findResultAreaEdges(opCode);\n\t\tthis.cancelDuplicateResultEdges();\n\t\tvar polyBuilder = new PolygonBuilder(this._geomFact);\n\t\tpolyBuilder.add(this._graph);\n\t\tthis._resultPolyList = polyBuilder.getPolygons();\n\t\tvar lineBuilder = new LineBuilder(this, this._geomFact, this._ptLocator);\n\t\tthis._resultLineList = lineBuilder.build(opCode);\n\t\tvar pointBuilder = new PointBuilder(this, this._geomFact, this._ptLocator);\n\t\tthis._resultPointList = pointBuilder.build(opCode);\n\t\tthis._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, opCode);\n\t},\n\tlabelIncompleteNode: function (n, targetIndex) {\n\t\tvar loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());\n\t\tn.getLabel().setLocation(targetIndex, loc);\n\t},\n\tcopyPoints: function (argIndex) {\n\t\tfor (var i = this._arg[argIndex].getNodeIterator(); i.hasNext(); ) {\n\t\t\tvar graphNode = i.next();\n\t\t\tvar newNode = this._graph.addNode(graphNode.getCoordinate());\n\t\t\tnewNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));\n\t\t}\n\t},\n\tfindResultAreaEdges: function (opCode) {\n\t\tfor (var it = this._graph.getEdgeEnds().iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tvar label = de.getLabel();\n\t\t\tif (label.isArea() && !de.isInteriorAreaEdge() && OverlayOp.isResultOfOp(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), opCode)) {\n\t\t\t\tde.setInResult(true);\n\t\t\t}\n\t\t}\n\t},\n\tcomputeLabelsFromDepths: function () {\n\t\tfor (var it = this._edgeList.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar lbl = e.getLabel();\n\t\t\tvar depth = e.getDepth();\n\t\t\tif (!depth.isNull()) {\n\t\t\t\tdepth.normalize();\n\t\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\t\tif (!lbl.isNull(i) && lbl.isArea() && !depth.isNull(i)) {\n\t\t\t\t\t\tif (depth.getDelta(i) === 0) {\n\t\t\t\t\t\t\tlbl.toLine(i);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tAssert.isTrue(!depth.isNull(i, Position.LEFT), \"depth of LEFT side has not been initialized\");\n\t\t\t\t\t\t\tlbl.setLocation(i, Position.LEFT, depth.getLocation(i, Position.LEFT));\n\t\t\t\t\t\t\tAssert.isTrue(!depth.isNull(i, Position.RIGHT), \"depth of RIGHT side has not been initialized\");\n\t\t\t\t\t\t\tlbl.setLocation(i, Position.RIGHT, depth.getLocation(i, Position.RIGHT));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tcomputeLabelling: function () {\n\t\tfor (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext(); ) {\n\t\t\tvar node = nodeit.next();\n\t\t\tnode.getEdges().computeLabelling(this._arg);\n\t\t}\n\t\tthis.mergeSymLabels();\n\t\tthis.updateNodeLabelling();\n\t},\n\tlabelIncompleteNodes: function () {\n\t\tvar nodeCount = 0;\n\t\tfor (var ni = this._graph.getNodes().iterator(); ni.hasNext(); ) {\n\t\t\tvar n = ni.next();\n\t\t\tvar label = n.getLabel();\n\t\t\tif (n.isIsolated()) {\n\t\t\t\tnodeCount++;\n\t\t\t\tif (label.isNull(0)) this.labelIncompleteNode(n, 0); else this.labelIncompleteNode(n, 1);\n\t\t\t}\n\t\t\tn.getEdges().updateLabelling(label);\n\t\t}\n\t},\n\tisCoveredByA: function (coord) {\n\t\tif (this.isCovered(coord, this._resultPolyList)) return true;\n\t\treturn false;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn OverlayOp;\n\t}\n});\nOverlayOp.overlayOp = function (geom0, geom1, opCode) {\n\tvar gov = new OverlayOp(geom0, geom1);\n\tvar geomOv = gov.getResultGeometry(opCode);\n\treturn geomOv;\n};\nOverlayOp.union = function (geom, other) {\n\tif (geom.isEmpty() || other.isEmpty()) {\n\t\tif (geom.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.UNION, geom, other, geom.getFactory());\n\t\tif (geom.isEmpty()) return other.copy();\n\t\tif (other.isEmpty()) return geom.copy();\n\t}\n\tif (geom.isGeometryCollection() || other.isGeometryCollection()) throw new IllegalArgumentException(\"This method does not support GeometryCollection arguments\");\n\treturn SnapIfNeededOverlayOp.overlayOp(geom, other, OverlayOp.UNION);\n};\nOverlayOp.intersection = function (geom, other) {\n\tif (geom.isEmpty() || other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.INTERSECTION, geom, other, geom.getFactory());\n\tif (geom.isGeometryCollection()) {\n\t\tvar g2 = other;\n\t\treturn GeometryCollectionMapper.map(geom, {\n\t\t\tinterfaces_: function () {\n\t\t\t\treturn [MapOp];\n\t\t\t},\n\t\t\tmap: function (g) {\n\t\t\t\treturn g.intersection(g2);\n\t\t\t}\n\t\t});\n\t}\n\tif (geom.isGeometryCollection() || other.isGeometryCollection()) throw new IllegalArgumentException(\"This method does not support GeometryCollection arguments\");\n\treturn SnapIfNeededOverlayOp.overlayOp(geom, other, OverlayOp.INTERSECTION);\n};\nOverlayOp.symDifference = function (geom, other) {\n\tif (geom.isEmpty() || other.isEmpty()) {\n\t\tif (geom.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.SYMDIFFERENCE, geom, other, geom.getFactory());\n\t\tif (geom.isEmpty()) return other.copy();\n\t\tif (other.isEmpty()) return geom.copy();\n\t}\n\tif (geom.isGeometryCollection() || other.isGeometryCollection()) throw new IllegalArgumentException(\"This method does not support GeometryCollection arguments\");\n\treturn SnapIfNeededOverlayOp.overlayOp(geom, other, OverlayOp.SYMDIFFERENCE);\n};\nOverlayOp.resultDimension = function (opCode, g0, g1) {\n\tvar dim0 = g0.getDimension();\n\tvar dim1 = g1.getDimension();\n\tvar resultDimension = -1;\n\tswitch (opCode) {\n\t\tcase OverlayOp.INTERSECTION:\n\t\t\tresultDimension = Math.min(dim0, dim1);\n\t\t\tbreak;\n\t\tcase OverlayOp.UNION:\n\t\t\tresultDimension = Math.max(dim0, dim1);\n\t\t\tbreak;\n\t\tcase OverlayOp.DIFFERENCE:\n\t\t\tresultDimension = dim0;\n\t\t\tbreak;\n\t\tcase OverlayOp.SYMDIFFERENCE:\n\t\t\tresultDimension = Math.max(dim0, dim1);\n\t\t\tbreak;\n\t}\n\treturn resultDimension;\n};\nOverlayOp.createEmptyResult = function (overlayOpCode, a, b, geomFact) {\n\tvar result = null;\n\tswitch (OverlayOp.resultDimension(overlayOpCode, a, b)) {\n\t\tcase -1:\n\t\t\tresult = geomFact.createGeometryCollection();\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tresult = geomFact.createPoint();\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tresult = geomFact.createLineString();\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tresult = geomFact.createPolygon();\n\t\t\tbreak;\n\t}\n\treturn result;\n};\nOverlayOp.difference = function (geom, other) {\n\tif (geom.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.DIFFERENCE, geom, other, geom.getFactory());\n\tif (other.isEmpty()) return geom.copy();\n\tif (geom.isGeometryCollection() || other.isGeometryCollection()) throw new IllegalArgumentException(\"This method does not support GeometryCollection arguments\");\n\treturn SnapIfNeededOverlayOp.overlayOp(geom, other, OverlayOp.DIFFERENCE);\n};\nOverlayOp.isResultOfOp = function () {\n\tif (arguments.length === 2) {\n\t\tlet label = arguments[0], opCode = arguments[1];\n\t\tvar loc0 = label.getLocation(0);\n\t\tvar loc1 = label.getLocation(1);\n\t\treturn OverlayOp.isResultOfOp(loc0, loc1, opCode);\n\t} else if (arguments.length === 3) {\n\t\tlet loc0 = arguments[0], loc1 = arguments[1], overlayOpCode = arguments[2];\n\t\tif (loc0 === Location.BOUNDARY) loc0 = Location.INTERIOR;\n\t\tif (loc1 === Location.BOUNDARY) loc1 = Location.INTERIOR;\n\t\tswitch (overlayOpCode) {\n\t\t\tcase OverlayOp.INTERSECTION:\n\t\t\t\treturn loc0 === Location.INTERIOR && loc1 === Location.INTERIOR;\n\t\t\tcase OverlayOp.UNION:\n\t\t\t\treturn loc0 === Location.INTERIOR || loc1 === Location.INTERIOR;\n\t\t\tcase OverlayOp.DIFFERENCE:\n\t\t\t\treturn loc0 === Location.INTERIOR && loc1 !== Location.INTERIOR;\n\t\t\tcase OverlayOp.SYMDIFFERENCE:\n\t\t\t\treturn loc0 === Location.INTERIOR && loc1 !== Location.INTERIOR || loc0 !== Location.INTERIOR && loc1 === Location.INTERIOR;\n\t\t}\n\t\treturn false;\n\t}\n};\nOverlayOp.INTERSECTION = 1;\nOverlayOp.UNION = 2;\nOverlayOp.DIFFERENCE = 3;\nOverlayOp.SYMDIFFERENCE = 4;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/operation/overlay/OverlayOp.js\n// module id = 30\n// module chunks = 0","export default function RuntimeException (message) {\n  this.name = 'RuntimeException'\n  this.message = message\n  this.stack = (new Error()).stack\n  Error.call(this, message)\n}\n\nRuntimeException.prototype = Object.create(Error.prototype)\nRuntimeException.prototype.constructor = Error\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/lang/RuntimeException.js\n// module id = 31\n// module chunks = 0","import extend from '../../../../extend';\nexport default function GeometryComponentFilter() {}\nextend(GeometryComponentFilter.prototype, {\n\tfilter: function (geom) {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn GeometryComponentFilter;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/GeometryComponentFilter.js\n// module id = 32\n// module chunks = 0","/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html\n * @constructor\n * @private\n */\nexport default function Iterator() {};\n\n/**\n * Returns true if the iteration has more elements.\n * @return {boolean}\n */\nIterator.prototype.hasNext = function() {};\n\n/**\n * Returns the next element in the iteration.\n * @return {Object}\n */\nIterator.prototype.next = function() {};\n\n/**\n * Removes from the underlying collection the last element returned by the\n * iterator (optional operation).\n */\nIterator.prototype.remove = function() {};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/util/Iterator.js\n// module id = 33\n// module chunks = 0","import ArrayList from './ArrayList'\nimport SortedMap from './SortedMap'\nimport HashSet from './HashSet'\n\nconst BLACK = 0\nconst RED = 1\nfunction colorOf (p) { return (p == null ? BLACK : p.color) }\nfunction parentOf (p) { return (p == null ? null : p.parent) }\nfunction setColor (p, c) { if (p !== null) p.color = c }\nfunction leftOf (p) { return (p == null ? null : p.left) }\nfunction rightOf (p) { return (p == null ? null : p.right) }\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeMap.html\n *\n * @extends {SortedMap}\n * @constructor\n * @private\n */\nexport default function TreeMap() {\n  /**\n   * @type {Object}\n   * @private\n   */\n  this.root_ = null;\n  /**\n   * @type {number}\n   * @private\n  */\n  this.size_ = 0;\n};\nTreeMap.prototype = new SortedMap();\n\n\n/**\n * @override\n */\nTreeMap.prototype.get = function(key) {\n  var p = this.root_;\n  while (p !== null) {\n    var cmp = key['compareTo'](p.key);\n    if (cmp < 0) {\n      p = p.left;\n    } else if (cmp > 0) {\n      p = p.right;\n    } else {\n      return p.value;\n    }\n  }\n  return null;\n};\n\n\n/**\n * @override\n */\nTreeMap.prototype.put = function(key, value) {\n  if (this.root_ === null) {\n    this.root_ = {\n      key: key,\n      value: value,\n      left: null,\n      right: null,\n      parent: null,\n      color: BLACK,\n      getValue() { return this.value },\n      getKey() { return this.key }\n    };\n    this.size_ = 1;\n    return null;\n  }\n  var t = this.root_, parent, cmp;\n  do {\n    parent = t;\n    cmp = key['compareTo'](t.key);\n    if (cmp < 0) {\n      t = t.left;\n    } else if (cmp > 0) {\n      t = t.right;\n    } else {\n      var oldValue = t.value;\n      t.value = value;\n      return oldValue;\n    }\n  } while (t !== null);\n  var e = {\n    key: key,\n    left: null,\n    right: null,\n    value: value,\n    parent: parent,\n    color: BLACK,\n    getValue() { return this.value },\n    getKey() { return this.key }\n  };\n  if (cmp < 0) {\n    parent.left = e;\n  } else {\n    parent.right = e;\n  }\n  this.fixAfterInsertion(e);\n  this.size_++;\n  return null;\n};\n\n\n/**\n * @param {Object} x\n */\nTreeMap.prototype.fixAfterInsertion = function(x) {\n  x.color = RED;\n  while (x != null && x != this.root_ && x.parent.color == RED) {\n    if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {\n      var y = rightOf(parentOf(parentOf(x)));\n      if (colorOf(y) == RED) {\n        setColor(parentOf(x), BLACK);\n        setColor(y, BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        x = parentOf(parentOf(x));\n      } else {\n        if (x == rightOf(parentOf(x))) {\n          x = parentOf(x);\n          this.rotateLeft(x);\n        }\n        setColor(parentOf(x), BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        this.rotateRight(parentOf(parentOf(x)));\n      }\n    } else {\n      var y = leftOf(parentOf(parentOf(x)));\n      if (colorOf(y) == RED) {\n        setColor(parentOf(x), BLACK);\n        setColor(y, BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        x = parentOf(parentOf(x));\n      } else {\n        if (x == leftOf(parentOf(x))) {\n          x = parentOf(x);\n          this.rotateRight(x);\n        }\n        setColor(parentOf(x), BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        this.rotateLeft(parentOf(parentOf(x)));\n      }\n    }\n  }\n  this.root_.color = BLACK;\n};\n\n\n/**\n * @override\n */\nTreeMap.prototype.values = function() {\n  var arrayList = new ArrayList();\n  var p = this.getFirstEntry();\n  if (p !== null) {\n    arrayList.add(p.value);\n    while ((p = TreeMap.successor(p)) !== null) {\n      arrayList.add(p.value);\n    }\n  }\n  return arrayList;\n};\n\n\n/**\n * @override\n */\nTreeMap.prototype.entrySet = function() {\n  var hashSet = new HashSet();\n  var p = this.getFirstEntry();\n  if (p !== null) {\n    hashSet.add(p);\n    while ((p = TreeMap.successor(p)) !== null) {\n      hashSet.add(p);\n    }\n  }\n  return hashSet;\n};\n\n\n/**\n * @param {Object} p\n */\nTreeMap.prototype.rotateLeft = function(p) {\n  if (p != null) {\n    var r = p.right;\n    p.right = r.left;\n    if (r.left != null)\n      r.left.parent = p;\n    r.parent = p.parent;\n    if (p.parent == null)\n      this.root_ = r;\n    else if (p.parent.left == p)\n      p.parent.left = r;\n    else\n      p.parent.right = r;\n    r.left = p;\n    p.parent = r;\n  }\n};\n\n\n/**\n * @param {Object} p\n */\nTreeMap.prototype.rotateRight = function(p) {\n  if (p != null) {\n    var l = p.left;\n    p.left = l.right;\n    if (l.right != null) l.right.parent = p;\n    l.parent = p.parent;\n    if (p.parent == null)\n      this.root_ = l;\n    else if (p.parent.right == p)\n      p.parent.right = l;\n    else p.parent.left = l;\n    l.right = p;\n    p.parent = l;\n  }\n};\n\n\n/**\n * @return {Object}\n */\nTreeMap.prototype.getFirstEntry = function() {\n  var p = this.root_;\n  if (p != null) {\n    while (p.left != null) {\n      p = p.left;\n    }\n  }\n  return p;\n};\n\n\n/**\n * @param {Object} t\n * @return {Object}\n * @private\n */\nTreeMap.successor = function(t) {\n  if (t === null)\n    return null;\n  else if (t.right !== null) {\n    var p = t.right;\n    while (p.left !== null) {\n      p = p.left;\n    }\n    return p;\n  } else {\n    var p = t.parent;\n    var ch = t;\n    while (p !== null && ch === p.right) {\n      ch = p;\n      p = p.parent;\n    }\n    return p;\n  }\n};\n\n\n/**\n * @override\n */\nTreeMap.prototype.size = function() {\n  return this.size_;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/util/TreeMap.js\n// module id = 34\n// module chunks = 0","import Geometry from './Geometry';\nimport CoordinateFilter from './CoordinateFilter';\nimport hasInterface from '../../../../hasInterface';\nimport extend from '../../../../extend';\nimport GeometryComponentFilter from './GeometryComponentFilter';\nimport Dimension from './Dimension';\nimport GeometryFilter from './GeometryFilter';\nimport CoordinateSequenceFilter from './CoordinateSequenceFilter';\nimport Puntal from './Puntal';\nimport Envelope from './Envelope';\nimport Assert from '../util/Assert';\nimport inherits from '../../../../inherits';\nexport default function Point() {\n\tthis._coordinates = null;\n\tlet coordinates = arguments[0], factory = arguments[1];\n\tGeometry.call(this, factory);\n\tthis.init(coordinates);\n}\ninherits(Point, Geometry);\nextend(Point.prototype, {\n\tcomputeEnvelopeInternal: function () {\n\t\tif (this.isEmpty()) {\n\t\t\treturn new Envelope();\n\t\t}\n\t\tvar env = new Envelope();\n\t\tenv.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0));\n\t\treturn env;\n\t},\n\tgetCoordinates: function () {\n\t\treturn this.isEmpty() ? [] : [this.getCoordinate()];\n\t},\n\tequalsExact: function () {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry)) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this.isEmpty() && other.isEmpty()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (this.isEmpty() !== other.isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn this.equal(other.getCoordinate(), this.getCoordinate(), tolerance);\n\t\t} else return Geometry.prototype.equalsExact.apply(this, arguments);\n\t},\n\tnormalize: function () {},\n\tgetCoordinate: function () {\n\t\treturn this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null;\n\t},\n\tgetBoundaryDimension: function () {\n\t\treturn Dimension.FALSE;\n\t},\n\tgetTypeCode: function () {\n\t\treturn Geometry.TYPECODE_POINT;\n\t},\n\tgetDimension: function () {\n\t\treturn 0;\n\t},\n\tgetNumPoints: function () {\n\t\treturn this.isEmpty() ? 0 : 1;\n\t},\n\treverse: function () {\n\t\treturn this.copy();\n\t},\n\tgetX: function () {\n\t\tif (this.getCoordinate() === null) {\n\t\t\tthrow new IllegalStateException(\"getX called on empty Point\");\n\t\t}\n\t\treturn this.getCoordinate().x;\n\t},\n\tcompareToSameClass: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet other = arguments[0];\n\t\t\tvar point = other;\n\t\t\treturn this.getCoordinate().compareTo(point.getCoordinate());\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet other = arguments[0], comp = arguments[1];\n\t\t\tvar point = other;\n\t\t\treturn comp.compare(this._coordinates, point._coordinates);\n\t\t}\n\t},\n\tapply: function () {\n\t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfilter.filter(this.getCoordinate());\n\t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tif (this.isEmpty()) return null;\n\t\t\tfilter.filter(this._coordinates, 0);\n\t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n\t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t}\n\t},\n\tgetBoundary: function () {\n\t\treturn this.getFactory().createGeometryCollection();\n\t},\n\tgetGeometryType: function () {\n\t\treturn Geometry.TYPENAME_POINT;\n\t},\n\tcopy: function () {\n\t\treturn new Point(this._coordinates.copy(), this._factory);\n\t},\n\tgetCoordinateSequence: function () {\n\t\treturn this._coordinates;\n\t},\n\tgetY: function () {\n\t\tif (this.getCoordinate() === null) {\n\t\t\tthrow new IllegalStateException(\"getY called on empty Point\");\n\t\t}\n\t\treturn this.getCoordinate().y;\n\t},\n\tisEmpty: function () {\n\t\treturn this._coordinates.size() === 0;\n\t},\n\tinit: function (coordinates) {\n\t\tif (coordinates === null) {\n\t\t\tcoordinates = this.getFactory().getCoordinateSequenceFactory().create([]);\n\t\t}\n\t\tAssert.isTrue(coordinates.size() <= 1);\n\t\tthis._coordinates = coordinates;\n\t},\n\tisSimple: function () {\n\t\treturn true;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Puntal];\n\t},\n\tgetClass: function () {\n\t\treturn Point;\n\t}\n});\nPoint.serialVersionUID = 4902022702746614570;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/Point.js\n// module id = 35\n// module chunks = 0","import Geometry from './Geometry';\nimport extend from '../../../../extend';\nimport GeometryCollection from './GeometryCollection';\nimport Polygonal from './Polygonal';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport inherits from '../../../../inherits';\nexport default function MultiPolygon() {\n\tlet polygons = arguments[0], factory = arguments[1];\n\tGeometryCollection.call(this, polygons, factory);\n}\ninherits(MultiPolygon, GeometryCollection);\nextend(MultiPolygon.prototype, {\n\tequalsExact: function () {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry)) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn GeometryCollection.prototype.equalsExact.call(this, other, tolerance);\n\t\t} else return GeometryCollection.prototype.equalsExact.apply(this, arguments);\n\t},\n\tgetBoundaryDimension: function () {\n\t\treturn 1;\n\t},\n\tgetTypeCode: function () {\n\t\treturn Geometry.TYPECODE_MULTIPOLYGON;\n\t},\n\tgetDimension: function () {\n\t\treturn 2;\n\t},\n\treverse: function () {\n\t\tvar n = this._geometries.length;\n\t\tvar revGeoms = new Array(n).fill(null);\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\trevGeoms[i] = this._geometries[i].reverse();\n\t\t}\n\t\treturn this.getFactory().createMultiPolygon(revGeoms);\n\t},\n\tgetBoundary: function () {\n\t\tif (this.isEmpty()) {\n\t\t\treturn this.getFactory().createMultiLineString();\n\t\t}\n\t\tvar allRings = new ArrayList();\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tvar polygon = this._geometries[i];\n\t\t\tvar rings = polygon.getBoundary();\n\t\t\tfor (var j = 0; j < rings.getNumGeometries(); j++) {\n\t\t\t\tallRings.add(rings.getGeometryN(j));\n\t\t\t}\n\t\t}\n\t\tvar allRingsArray = new Array(allRings.size()).fill(null);\n\t\treturn this.getFactory().createMultiLineString(allRings.toArray(allRingsArray));\n\t},\n\tgetGeometryType: function () {\n\t\treturn Geometry.TYPENAME_MULTIPOLYGON;\n\t},\n\tcopy: function () {\n\t\tvar polygons = new Array(this._geometries.length).fill(null);\n\t\tfor (var i = 0; i < polygons.length; i++) {\n\t\t\tpolygons[i] = this._geometries[i].copy();\n\t\t}\n\t\treturn new MultiPolygon(polygons, this._factory);\n\t},\n\tinterfaces_: function () {\n\t\treturn [Polygonal];\n\t},\n\tgetClass: function () {\n\t\treturn MultiPolygon;\n\t}\n});\nMultiPolygon.serialVersionUID = -551033529766975875;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/MultiPolygon.js\n// module id = 36\n// module chunks = 0","/**\n * @module org/locationtech/jts/io/WKTWriter\n */\n\nimport WKTParser from './WKTParser'\nimport extend from '../../../../extend'\n\n/**\n * Writes the Well-Known Text representation of a {@link Geometry}. The\n * Well-Known Text format is defined in the <A\n * HREF=\"http://www.opengis.org/techno/specs.htm\"> OGC Simple Features\n * Specification for SQL</A>.\n * <p>\n * The <code>WKTWriter</code> outputs coordinates rounded to the precision\n * model. Only the maximum number of decimal places necessary to represent the\n * ordinates to the required precision will be output.\n * <p>\n * The SFS WKT spec does not define a special tag for {@link LinearRing}s.\n * Under the spec, rings are output as <code>LINESTRING</code>s.\n */\n\n/**\n * @param {GeometryFactory} geometryFactory\n * @constructor\n */\nexport default function WKTWriter (geometryFactory) {\n  this.parser = new WKTParser(geometryFactory)\n}\n\nextend(WKTWriter.prototype, {\n  /**\n   * Converts a <code>Geometry</code> to its Well-known Text representation.\n   *\n   * @param {Geometry} geometry a <code>Geometry</code> to process.\n   * @return {string} a <Geometry Tagged Text> string (see the OpenGIS Simple\n   *         Features Specification).\n   * @memberof module:org/locationtech/jts/io/WKTWriter#\n   */\n  write (geometry) {\n    return this.parser.write(geometry)\n  }\n})\n\nextend(WKTWriter, {\n  /**\n   * Generates the WKT for a <tt>LINESTRING</tt> specified by two\n   * {@link Coordinate}s.\n   *\n   * @param p0 the first coordinate.\n   * @param p1 the second coordinate.\n   *\n   * @return the WKT.\n   * @private\n   */\n  toLineString (p0, p1) {\n    if (arguments.length !== 2) {\n      throw new Error('Not implemented')\n    }\n\n    return 'LINESTRING ( ' + p0.x + ' ' + p0.y + ', ' + p1.x + ' ' + p1.y + ' )'\n  }\n})\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/io/WKTWriter.js\n// module id = 37\n// module chunks = 0","import Arrays from './Arrays'\nimport ArrayList from './ArrayList'\n\nconst Collections = {\n  reverseOrder: function () {\n    return {\n      compare (a, b) {\n        return b.compareTo(a)\n      }\n    }\n  },\n  min: function (l) {\n    Collections.sort(l)\n    return l.get(0)\n  },\n  sort: function (l, c) {\n    const a = l.toArray()\n    if (c) {\n      Arrays.sort(a, c)\n    } else {\n      Arrays.sort(a)\n    }\n    const i = l.iterator()\n    for (let pos = 0, alen = a.length; pos < alen; pos++) {\n      i.next()\n      i.set(a[pos])\n    }\n  },\n  singletonList: function (o) {\n    const arrayList = new ArrayList()\n    arrayList.add(o)\n    return arrayList\n  }\n}\n\nexport default Collections\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/util/Collections.js\n// module id = 38\n// module chunks = 0","import NotRepresentableException from '../algorithm/NotRepresentableException';\nimport Coordinate from './Coordinate';\nimport Double from '../../../../java/lang/Double';\nimport extend from '../../../../extend';\nimport Orientation from '../algorithm/Orientation';\nimport Comparable from '../../../../java/lang/Comparable';\nimport RobustLineIntersector from '../algorithm/RobustLineIntersector';\nimport HCoordinate from '../algorithm/HCoordinate';\nimport Serializable from '../../../../java/io/Serializable';\nimport Distance from '../algorithm/Distance';\nexport default function LineSegment() {\n\tthis.p0 = null;\n\tthis.p1 = null;\n\tif (arguments.length === 0) {\n\t\tLineSegment.call(this, new Coordinate(), new Coordinate());\n\t} else if (arguments.length === 1) {\n\t\tlet ls = arguments[0];\n\t\tLineSegment.call(this, ls.p0, ls.p1);\n\t} else if (arguments.length === 2) {\n\t\tlet p0 = arguments[0], p1 = arguments[1];\n\t\tthis.p0 = p0;\n\t\tthis.p1 = p1;\n\t} else if (arguments.length === 4) {\n\t\tlet x0 = arguments[0], y0 = arguments[1], x1 = arguments[2], y1 = arguments[3];\n\t\tLineSegment.call(this, new Coordinate(x0, y0), new Coordinate(x1, y1));\n\t}\n}\nextend(LineSegment.prototype, {\n\tminX: function () {\n\t\treturn Math.min(this.p0.x, this.p1.x);\n\t},\n\torientationIndex: function () {\n\t\tif (arguments[0] instanceof LineSegment) {\n\t\t\tlet seg = arguments[0];\n\t\t\tvar orient0 = Orientation.index(this.p0, this.p1, seg.p0);\n\t\t\tvar orient1 = Orientation.index(this.p0, this.p1, seg.p1);\n\t\t\tif (orient0 >= 0 && orient1 >= 0) return Math.max(orient0, orient1);\n\t\t\tif (orient0 <= 0 && orient1 <= 0) return Math.max(orient0, orient1);\n\t\t\treturn 0;\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet p = arguments[0];\n\t\t\treturn Orientation.index(this.p0, this.p1, p);\n\t\t}\n\t},\n\ttoGeometry: function (geomFactory) {\n\t\treturn geomFactory.createLineString([this.p0, this.p1]);\n\t},\n\tisVertical: function () {\n\t\treturn this.p0.x === this.p1.x;\n\t},\n\tequals: function (o) {\n\t\tif (!(o instanceof LineSegment)) {\n\t\t\treturn false;\n\t\t}\n\t\tvar other = o;\n\t\treturn this.p0.equals(other.p0) && this.p1.equals(other.p1);\n\t},\n\tintersection: function (line) {\n\t\tvar li = new RobustLineIntersector();\n\t\tli.computeIntersection(this.p0, this.p1, line.p0, line.p1);\n\t\tif (li.hasIntersection()) return li.getIntersection(0);\n\t\treturn null;\n\t},\n\tproject: function () {\n\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\tlet p = arguments[0];\n\t\t\tif (p.equals(this.p0) || p.equals(this.p1)) return new Coordinate(p);\n\t\t\tvar r = this.projectionFactor(p);\n\t\t\tvar coord = new Coordinate();\n\t\t\tcoord.x = this.p0.x + r * (this.p1.x - this.p0.x);\n\t\t\tcoord.y = this.p0.y + r * (this.p1.y - this.p0.y);\n\t\t\treturn coord;\n\t\t} else if (arguments[0] instanceof LineSegment) {\n\t\t\tlet seg = arguments[0];\n\t\t\tvar pf0 = this.projectionFactor(seg.p0);\n\t\t\tvar pf1 = this.projectionFactor(seg.p1);\n\t\t\tif (pf0 >= 1.0 && pf1 >= 1.0) return null;\n\t\t\tif (pf0 <= 0.0 && pf1 <= 0.0) return null;\n\t\t\tvar newp0 = this.project(seg.p0);\n\t\t\tif (pf0 < 0.0) newp0 = this.p0;\n\t\t\tif (pf0 > 1.0) newp0 = this.p1;\n\t\t\tvar newp1 = this.project(seg.p1);\n\t\t\tif (pf1 < 0.0) newp1 = this.p0;\n\t\t\tif (pf1 > 1.0) newp1 = this.p1;\n\t\t\treturn new LineSegment(newp0, newp1);\n\t\t}\n\t},\n\tnormalize: function () {\n\t\tif (this.p1.compareTo(this.p0) < 0) this.reverse();\n\t},\n\tangle: function () {\n\t\treturn Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);\n\t},\n\tgetCoordinate: function (i) {\n\t\tif (i === 0) return this.p0;\n\t\treturn this.p1;\n\t},\n\tdistancePerpendicular: function (p) {\n\t\treturn Distance.pointToLinePerpendicular(p, this.p0, this.p1);\n\t},\n\tminY: function () {\n\t\treturn Math.min(this.p0.y, this.p1.y);\n\t},\n\tmidPoint: function () {\n\t\treturn LineSegment.midPoint(this.p0, this.p1);\n\t},\n\tprojectionFactor: function (p) {\n\t\tif (p.equals(this.p0)) return 0.0;\n\t\tif (p.equals(this.p1)) return 1.0;\n\t\tvar dx = this.p1.x - this.p0.x;\n\t\tvar dy = this.p1.y - this.p0.y;\n\t\tvar len = dx * dx + dy * dy;\n\t\tif (len <= 0.0) return Double.NaN;\n\t\tvar r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len;\n\t\treturn r;\n\t},\n\tclosestPoints: function (line) {\n\t\tvar intPt = this.intersection(line);\n\t\tif (intPt !== null) {\n\t\t\treturn [intPt, intPt];\n\t\t}\n\t\tvar closestPt = new Array(2).fill(null);\n\t\tvar minDistance = Double.MAX_VALUE;\n\t\tvar dist = null;\n\t\tvar close00 = this.closestPoint(line.p0);\n\t\tminDistance = close00.distance(line.p0);\n\t\tclosestPt[0] = close00;\n\t\tclosestPt[1] = line.p0;\n\t\tvar close01 = this.closestPoint(line.p1);\n\t\tdist = close01.distance(line.p1);\n\t\tif (dist < minDistance) {\n\t\t\tminDistance = dist;\n\t\t\tclosestPt[0] = close01;\n\t\t\tclosestPt[1] = line.p1;\n\t\t}\n\t\tvar close10 = line.closestPoint(this.p0);\n\t\tdist = close10.distance(this.p0);\n\t\tif (dist < minDistance) {\n\t\t\tminDistance = dist;\n\t\t\tclosestPt[0] = this.p0;\n\t\t\tclosestPt[1] = close10;\n\t\t}\n\t\tvar close11 = line.closestPoint(this.p1);\n\t\tdist = close11.distance(this.p1);\n\t\tif (dist < minDistance) {\n\t\t\tminDistance = dist;\n\t\t\tclosestPt[0] = this.p1;\n\t\t\tclosestPt[1] = close11;\n\t\t}\n\t\treturn closestPt;\n\t},\n\tclosestPoint: function (p) {\n\t\tvar factor = this.projectionFactor(p);\n\t\tif (factor > 0 && factor < 1) {\n\t\t\treturn this.project(p);\n\t\t}\n\t\tvar dist0 = this.p0.distance(p);\n\t\tvar dist1 = this.p1.distance(p);\n\t\tif (dist0 < dist1) return this.p0;\n\t\treturn this.p1;\n\t},\n\tmaxX: function () {\n\t\treturn Math.max(this.p0.x, this.p1.x);\n\t},\n\tgetLength: function () {\n\t\treturn this.p0.distance(this.p1);\n\t},\n\tcompareTo: function (o) {\n\t\tvar other = o;\n\t\tvar comp0 = this.p0.compareTo(other.p0);\n\t\tif (comp0 !== 0) return comp0;\n\t\treturn this.p1.compareTo(other.p1);\n\t},\n\treverse: function () {\n\t\tvar temp = this.p0;\n\t\tthis.p0 = this.p1;\n\t\tthis.p1 = temp;\n\t},\n\tequalsTopo: function (other) {\n\t\treturn this.p0.equals(other.p0) && this.p1.equals(other.p1) || this.p0.equals(other.p1) && this.p1.equals(other.p0);\n\t},\n\tlineIntersection: function (line) {\n\t\ttry {\n\t\t\tvar intPt = HCoordinate.intersection(this.p0, this.p1, line.p0, line.p1);\n\t\t\treturn intPt;\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof NotRepresentableException) {} else throw ex;\n\t\t} finally {}\n\t\treturn null;\n\t},\n\tmaxY: function () {\n\t\treturn Math.max(this.p0.y, this.p1.y);\n\t},\n\tpointAlongOffset: function (segmentLengthFraction, offsetDistance) {\n\t\tvar segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);\n\t\tvar segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);\n\t\tvar dx = this.p1.x - this.p0.x;\n\t\tvar dy = this.p1.y - this.p0.y;\n\t\tvar len = Math.sqrt(dx * dx + dy * dy);\n\t\tvar ux = 0.0;\n\t\tvar uy = 0.0;\n\t\tif (offsetDistance !== 0.0) {\n\t\t\tif (len <= 0.0) throw new IllegalStateException(\"Cannot compute offset from zero-length line segment\");\n\t\t\tux = offsetDistance * dx / len;\n\t\t\tuy = offsetDistance * dy / len;\n\t\t}\n\t\tvar offsetx = segx - uy;\n\t\tvar offsety = segy + ux;\n\t\tvar coord = new Coordinate(offsetx, offsety);\n\t\treturn coord;\n\t},\n\tsetCoordinates: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet ls = arguments[0];\n\t\t\tthis.setCoordinates(ls.p0, ls.p1);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet p0 = arguments[0], p1 = arguments[1];\n\t\t\tthis.p0.x = p0.x;\n\t\t\tthis.p0.y = p0.y;\n\t\t\tthis.p1.x = p1.x;\n\t\t\tthis.p1.y = p1.y;\n\t\t}\n\t},\n\tsegmentFraction: function (inputPt) {\n\t\tvar segFrac = this.projectionFactor(inputPt);\n\t\tif (segFrac < 0.0) segFrac = 0.0; else if (segFrac > 1.0 || Double.isNaN(segFrac)) segFrac = 1.0;\n\t\treturn segFrac;\n\t},\n\ttoString: function () {\n\t\treturn \"LINESTRING( \" + this.p0.x + \" \" + this.p0.y + \", \" + this.p1.x + \" \" + this.p1.y + \")\";\n\t},\n\tisHorizontal: function () {\n\t\treturn this.p0.y === this.p1.y;\n\t},\n\tdistance: function () {\n\t\tif (arguments[0] instanceof LineSegment) {\n\t\t\tlet ls = arguments[0];\n\t\t\treturn Distance.segmentToSegment(this.p0, this.p1, ls.p0, ls.p1);\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet p = arguments[0];\n\t\t\treturn Distance.pointToSegment(p, this.p0, this.p1);\n\t\t}\n\t},\n\tpointAlong: function (segmentLengthFraction) {\n\t\tvar coord = new Coordinate();\n\t\tcoord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);\n\t\tcoord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);\n\t\treturn coord;\n\t},\n\thashCode: function () {\n\t\tvar bits0 = java.lang.Double.doubleToLongBits(this.p0.x);\n\t\tbits0 ^= java.lang.Double.doubleToLongBits(this.p0.y) * 31;\n\t\tvar hash0 = Math.trunc(bits0) ^ Math.trunc(bits0 >> 32);\n\t\tvar bits1 = java.lang.Double.doubleToLongBits(this.p1.x);\n\t\tbits1 ^= java.lang.Double.doubleToLongBits(this.p1.y) * 31;\n\t\tvar hash1 = Math.trunc(bits1) ^ Math.trunc(bits1 >> 32);\n\t\treturn hash0 ^ hash1;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparable, Serializable];\n\t},\n\tgetClass: function () {\n\t\treturn LineSegment;\n\t}\n});\nLineSegment.midPoint = function (p0, p1) {\n\treturn new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);\n};\nLineSegment.serialVersionUID = 3252005833466256227;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/LineSegment.js\n// module id = 39\n// module chunks = 0","export default function Clonable () {}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/lang/Cloneable.js\n// module id = 40\n// module chunks = 0","export default function Comparator () {}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/util/Comparator.js\n// module id = 41\n// module chunks = 0","import extend from '../../../../extend';\nexport default function CoordinateFilter() {}\nextend(CoordinateFilter.prototype, {\n\tfilter: function (coord) {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn CoordinateFilter;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/CoordinateFilter.js\n// module id = 42\n// module chunks = 0","import Collection from './Collection'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/List.html\n *\n * @extends {javascript.util.Collection}\n * @constructor\n * @private\n */\nexport default function List() { };\nList.prototype = Object.create(Collection.prototype);\nList.prototype.constructor = List\n\n/**\n * Returns the element at the specified position in this list.\n * @param {number} index\n * @return {Object}\n */\nList.prototype.get = function() { };\n\n\n/**\n * Replaces the element at the specified position in this list with the\n * specified element (optional operation).\n * @param {number} index\n * @param {Object} e\n * @return {Object}\n */\nList.prototype.set = function() { };\n\n\n/**\n * Returns true if this collection contains no elements.\n * @return {boolean}\n */\nList.prototype.isEmpty = function() { };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/util/List.js\n// module id = 43\n// module chunks = 0","import extend from '../../../../extend';\nexport default function CoordinateSequenceFilter() {}\nextend(CoordinateSequenceFilter.prototype, {\n\tfilter: function (seq, i) {},\n\tisDone: function () {},\n\tisGeometryChanged: function () {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn CoordinateSequenceFilter;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/CoordinateSequenceFilter.js\n// module id = 44\n// module chunks = 0","export default function StringBuilder (str) {\n    this.str = str\n  }\n  \n  StringBuilder.prototype.append = function (e) {\n    this.str += e\n  }\n  \n  StringBuilder.prototype.setCharAt = function (i, c) {\n    this.str = this.str.substr(0, i) + c + this.str.substr(i + 1)\n  }\n  \n  StringBuilder.prototype.toString = function (e) {\n    return this.str\n  }\n  \n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/lang/StringBuilder.js\n// module id = 45\n// module chunks = 0","export default function Integer (value) {\n  this.value = value\n}\n\nInteger.prototype.intValue = function () {\n  return this.value\n}\nInteger.prototype.compareTo = function (o) {\n  if (this.value < o) return -1\n  if (this.value > o) return 1\n  return 0\n}\n\nInteger.isNaN = n => Number.isNaN(n)\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/lang/Integer.js\n// module id = 46\n// module chunks = 0","import extend from '../../../../extend';\nexport default function Polygonal() {}\nextend(Polygonal.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Polygonal;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/Polygonal.js\n// module id = 47\n// module chunks = 0","import Geometry from './Geometry';\nimport extend from '../../../../extend';\nimport GeometryCollection from './GeometryCollection';\nimport Dimension from './Dimension';\nimport Puntal from './Puntal';\nimport inherits from '../../../../inherits';\nexport default function MultiPoint() {\n\tlet points = arguments[0], factory = arguments[1];\n\tGeometryCollection.call(this, points, factory);\n}\ninherits(MultiPoint, GeometryCollection);\nextend(MultiPoint.prototype, {\n\tisValid: function () {\n\t\treturn true;\n\t},\n\tequalsExact: function () {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry)) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn GeometryCollection.prototype.equalsExact.call(this, other, tolerance);\n\t\t} else return GeometryCollection.prototype.equalsExact.apply(this, arguments);\n\t},\n\tgetCoordinate: function () {\n\t\tif (arguments.length === 1 && Number.isInteger(arguments[0])) {\n\t\t\tlet n = arguments[0];\n\t\t\treturn this._geometries[n].getCoordinate();\n\t\t} else return GeometryCollection.prototype.getCoordinate.apply(this, arguments);\n\t},\n\tgetBoundaryDimension: function () {\n\t\treturn Dimension.FALSE;\n\t},\n\tgetTypeCode: function () {\n\t\treturn Geometry.TYPECODE_MULTIPOINT;\n\t},\n\tgetDimension: function () {\n\t\treturn 0;\n\t},\n\tgetBoundary: function () {\n\t\treturn this.getFactory().createGeometryCollection();\n\t},\n\tgetGeometryType: function () {\n\t\treturn Geometry.TYPENAME_MULTIPOINT;\n\t},\n\tcopy: function () {\n\t\tvar points = new Array(this._geometries.length).fill(null);\n\t\tfor (var i = 0; i < points.length; i++) {\n\t\t\tpoints[i] = this._geometries[i].copy();\n\t\t}\n\t\treturn new MultiPoint(points, this._factory);\n\t},\n\tinterfaces_: function () {\n\t\treturn [Puntal];\n\t},\n\tgetClass: function () {\n\t\treturn MultiPoint;\n\t}\n});\nMultiPoint.serialVersionUID = -8048474874175355449;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/MultiPoint.js\n// module id = 48\n// module chunks = 0","import Coordinate from '../geom/Coordinate';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../extend';\nexport default function Quadrant() {}\nextend(Quadrant.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Quadrant;\n\t}\n});\nQuadrant.isNorthern = function (quad) {\n\treturn quad === Quadrant.NE || quad === Quadrant.NW;\n};\nQuadrant.isOpposite = function (quad1, quad2) {\n\tif (quad1 === quad2) return false;\n\tvar diff = (quad1 - quad2 + 4) % 4;\n\tif (diff === 2) return true;\n\treturn false;\n};\nQuadrant.commonHalfPlane = function (quad1, quad2) {\n\tif (quad1 === quad2) return quad1;\n\tvar diff = (quad1 - quad2 + 4) % 4;\n\tif (diff === 2) return -1;\n\tvar min = quad1 < quad2 ? quad1 : quad2;\n\tvar max = quad1 > quad2 ? quad1 : quad2;\n\tif (min === 0 && max === 3) return 3;\n\treturn min;\n};\nQuadrant.isInHalfPlane = function (quad, halfPlane) {\n\tif (halfPlane === Quadrant.SE) {\n\t\treturn quad === Quadrant.SE || quad === Quadrant.SW;\n\t}\n\treturn quad === halfPlane || quad === halfPlane + 1;\n};\nQuadrant.quadrant = function () {\n\tif (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n\t\tlet dx = arguments[0], dy = arguments[1];\n\t\tif (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException(\"Cannot compute the quadrant for point ( \" + dx + \", \" + dy + \" )\");\n\t\tif (dx >= 0.0) {\n\t\t\tif (dy >= 0.0) return Quadrant.NE; else return Quadrant.SE;\n\t\t} else {\n\t\t\tif (dy >= 0.0) return Quadrant.NW; else return Quadrant.SW;\n\t\t}\n\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n\t\tlet p0 = arguments[0], p1 = arguments[1];\n\t\tif (p1.x === p0.x && p1.y === p0.y) throw new IllegalArgumentException(\"Cannot compute the quadrant for two identical points \" + p0);\n\t\tif (p1.x >= p0.x) {\n\t\t\tif (p1.y >= p0.y) return Quadrant.NE; else return Quadrant.SE;\n\t\t} else {\n\t\t\tif (p1.y >= p0.y) return Quadrant.NW; else return Quadrant.SW;\n\t\t}\n\t}\n};\nQuadrant.NE = 0;\nQuadrant.NW = 1;\nQuadrant.SW = 2;\nQuadrant.SE = 3;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geomgraph/Quadrant.js\n// module id = 49\n// module chunks = 0","import SegmentNodeList from './SegmentNodeList';\nimport WKTWriter from '../io/WKTWriter';\nimport CoordinateArraySequence from '../geom/impl/CoordinateArraySequence';\nimport Coordinate from '../geom/Coordinate';\nimport Octant from './Octant';\nimport extend from '../../../../extend';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport NodableSegmentString from './NodableSegmentString';\nexport default function NodedSegmentString() {\n\tthis._nodeList = new SegmentNodeList(this);\n\tthis._pts = null;\n\tthis._data = null;\n\tlet pts = arguments[0], data = arguments[1];\n\tthis._pts = pts;\n\tthis._data = data;\n}\nextend(NodedSegmentString.prototype, {\n\tgetCoordinates: function () {\n\t\treturn this._pts;\n\t},\n\tsize: function () {\n\t\treturn this._pts.length;\n\t},\n\tgetCoordinate: function (i) {\n\t\treturn this._pts[i];\n\t},\n\tisClosed: function () {\n\t\treturn this._pts[0].equals(this._pts[this._pts.length - 1]);\n\t},\n\tgetSegmentOctant: function (index) {\n\t\tif (index === this._pts.length - 1) return -1;\n\t\treturn this.safeOctant(this.getCoordinate(index), this.getCoordinate(index + 1));\n\t},\n\tsetData: function (data) {\n\t\tthis._data = data;\n\t},\n\tsafeOctant: function (p0, p1) {\n\t\tif (p0.equals2D(p1)) return 0;\n\t\treturn Octant.octant(p0, p1);\n\t},\n\tgetData: function () {\n\t\treturn this._data;\n\t},\n\taddIntersection: function () {\n\t\tif (arguments.length === 2) {\n\t\t\tlet intPt = arguments[0], segmentIndex = arguments[1];\n\t\t\tthis.addIntersectionNode(intPt, segmentIndex);\n\t\t} else if (arguments.length === 4) {\n\t\t\tlet li = arguments[0], segmentIndex = arguments[1], geomIndex = arguments[2], intIndex = arguments[3];\n\t\t\tvar intPt = new Coordinate(li.getIntersection(intIndex));\n\t\t\tthis.addIntersection(intPt, segmentIndex);\n\t\t}\n\t},\n\ttoString: function () {\n\t\treturn WKTWriter.toLineString(new CoordinateArraySequence(this._pts));\n\t},\n\tgetNodeList: function () {\n\t\treturn this._nodeList;\n\t},\n\taddIntersectionNode: function (intPt, segmentIndex) {\n\t\tvar normalizedSegmentIndex = segmentIndex;\n\t\tvar nextSegIndex = normalizedSegmentIndex + 1;\n\t\tif (nextSegIndex < this._pts.length) {\n\t\t\tvar nextPt = this._pts[nextSegIndex];\n\t\t\tif (intPt.equals2D(nextPt)) {\n\t\t\t\tnormalizedSegmentIndex = nextSegIndex;\n\t\t\t}\n\t\t}\n\t\tvar ei = this._nodeList.add(intPt, normalizedSegmentIndex);\n\t\treturn ei;\n\t},\n\taddIntersections: function (li, segmentIndex, geomIndex) {\n\t\tfor (var i = 0; i < li.getIntersectionNum(); i++) {\n\t\t\tthis.addIntersection(li, segmentIndex, geomIndex, i);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [NodableSegmentString];\n\t},\n\tgetClass: function () {\n\t\treturn NodedSegmentString;\n\t}\n});\nNodedSegmentString.getNodedSubstrings = function () {\n\tif (arguments.length === 1) {\n\t\tlet segStrings = arguments[0];\n\t\tvar resultEdgelist = new ArrayList();\n\t\tNodedSegmentString.getNodedSubstrings(segStrings, resultEdgelist);\n\t\treturn resultEdgelist;\n\t} else if (arguments.length === 2) {\n\t\tlet segStrings = arguments[0], resultEdgelist = arguments[1];\n\t\tfor (var i = segStrings.iterator(); i.hasNext(); ) {\n\t\t\tvar ss = i.next();\n\t\t\tss.getNodeList().addSplitEdges(resultEdgelist);\n\t\t}\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/noding/NodedSegmentString.js\n// module id = 50\n// module chunks = 0","/*eslint-disable no-undef */\n\n/**\n * @module org/locationtech/jts/io/OL3Parser\n */\n\nimport Coordinate from '../geom/Coordinate'\nimport GeometryFactory from '../geom/GeometryFactory'\nimport extend from '../../../../extend'\n\nfunction p2c (p) { return [p.x, p.y] }\n\n/**\n * OpenLayers Geometry parser and writer\n * @param {GeometryFactory} geometryFactory\n * @param {ol} olReference \n * @constructor\n */\nexport default function OL3Parser (geometryFactory, olReference) {\n  this.geometryFactory = geometryFactory || new GeometryFactory()\n  this.ol = olReference || (typeof ol !== 'undefined' && ol)\n}\n\nextend(OL3Parser.prototype, {\n\n  /**\n   * Inject OpenLayers geom classes\n   */\n  inject(Point, LineString, LinearRing, Polygon, MultiPoint, MultiLineString, MultiPolygon, GeometryCollection) {\n    this.ol = {\n      geom: {\n        Point, LineString, LinearRing, Polygon, MultiPoint, MultiLineString, MultiPolygon, GeometryCollection\n      }\n    }\n  },\n\n  /**\n   * @param geometry {ol.geom.Geometry}\n   * @return {Geometry}\n   * @memberof module:org/locationtech/jts/io/OL3Parser#\n   */\n  read (geometry) {\n    const ol = this.ol\n    if (geometry instanceof ol.geom.Point) {\n      return this.convertFromPoint(geometry)\n    } else if (geometry instanceof ol.geom.LineString) {\n      return this.convertFromLineString(geometry)\n    } else if (geometry instanceof ol.geom.LinearRing) {\n      return this.convertFromLinearRing(geometry)\n    } else if (geometry instanceof ol.geom.Polygon) {\n      return this.convertFromPolygon(geometry)\n    } else if (geometry instanceof ol.geom.MultiPoint) {\n      return this.convertFromMultiPoint(geometry)\n    } else if (geometry instanceof ol.geom.MultiLineString) {\n      return this.convertFromMultiLineString(geometry)\n    } else if (geometry instanceof ol.geom.MultiPolygon) {\n      return this.convertFromMultiPolygon(geometry)\n    } else if (geometry instanceof ol.geom.GeometryCollection) {\n      return this.convertFromCollection(geometry)\n    }\n  },\n\n  convertFromPoint (point) {\n    const coordinates = point.getCoordinates()\n    return this.geometryFactory.createPoint(new Coordinate(coordinates[0], coordinates[1]))\n  },\n\n  convertFromLineString (lineString) {\n    return this.geometryFactory.createLineString(lineString.getCoordinates().map(function (coordinates) {\n      return new Coordinate(coordinates[0], coordinates[1])\n    }))\n  },\n\n  convertFromLinearRing (linearRing) {\n    return this.geometryFactory.createLinearRing(linearRing.getCoordinates().map(function (coordinates) {\n      return new Coordinate(coordinates[0], coordinates[1])\n    }))\n  },\n\n  convertFromPolygon (polygon) {\n    const linearRings = polygon.getLinearRings()\n    var shell = null\n    var holes = []\n    for (let i = 0; i < linearRings.length; i++) {\n      const linearRing = this.convertFromLinearRing(linearRings[i])\n      if (i === 0) {\n        shell = linearRing\n      } else {\n        holes.push(linearRing)\n      }\n    }\n    return this.geometryFactory.createPolygon(shell, holes)\n  },\n\n  convertFromMultiPoint (multiPoint) {\n    const points = multiPoint.getPoints().map(function (point) {\n      return this.convertFromPoint(point)\n    }, this)\n    return this.geometryFactory.createMultiPoint(points)\n  },\n\n  convertFromMultiLineString (multiLineString) {\n    const lineStrings = multiLineString.getLineStrings().map(function (lineString) {\n      return this.convertFromLineString(lineString)\n    }, this)\n    return this.geometryFactory.createMultiLineString(lineStrings)\n  },\n\n  convertFromMultiPolygon (multiPolygon) {\n    const polygons = multiPolygon.getPolygons().map(function (polygon) {\n      return this.convertFromPolygon(polygon)\n    }, this)\n    return this.geometryFactory.createMultiPolygon(polygons)\n  },\n\n  convertFromCollection (collection) {\n    const geometries = collection.getGeometries().map(function (geometry) {\n      return this.read(geometry)\n    }, this)\n    return this.geometryFactory.createGeometryCollection(geometries)\n  },\n\n  /**\n   * @param geometry\n   *          {Geometry}\n   * @return {ol.geom.Geometry}\n   * @memberof module:org/locationtech/jts/io/OL3Parser#\n   */\n  write (geometry) {\n    if (geometry.getGeometryType() === 'Point') {\n      return this.convertToPoint(geometry.getCoordinate())\n    } else if (geometry.getGeometryType() === 'LineString') {\n      return this.convertToLineString(geometry)\n    } else if (geometry.getGeometryType() === 'LinearRing') {\n      return this.convertToLinearRing(geometry)\n    } else if (geometry.getGeometryType() === 'Polygon') {\n      return this.convertToPolygon(geometry)\n    } else if (geometry.getGeometryType() === 'MultiPoint') {\n      return this.convertToMultiPoint(geometry)\n    } else if (geometry.getGeometryType() === 'MultiLineString') {\n      return this.convertToMultiLineString(geometry)\n    } else if (geometry.getGeometryType() === 'MultiPolygon') {\n      return this.convertToMultiPolygon(geometry)\n    } else if (geometry.getGeometryType() === 'GeometryCollection') {\n      return this.convertToCollection(geometry)\n    }\n  },\n\n  convertToPoint (coordinate) {\n    return new this.ol.geom.Point([coordinate.x, coordinate.y])\n  },\n\n  convertToLineString (lineString) {\n    var points = lineString._points._coordinates.map(p2c)\n    return new this.ol.geom.LineString(points)\n  },\n\n  convertToLinearRing (linearRing) {\n    var points = linearRing._points._coordinates.map(p2c)\n    return new this.ol.geom.LinearRing(points)\n  },\n\n  convertToPolygon (polygon) {\n    var rings = [polygon._shell._points._coordinates.map(p2c)]\n    for (let i = 0; i < polygon._holes.length; i++) {\n      rings.push(polygon._holes[i]._points._coordinates.map(p2c))\n    }\n    return new this.ol.geom.Polygon(rings)\n  },\n\n  convertToMultiPoint (multiPoint) {\n    return new this.ol.geom.MultiPoint(multiPoint.getCoordinates().map(p2c))\n  },\n\n  convertToMultiLineString (multiLineString) {\n    var lineStrings = []\n    for (let i = 0; i < multiLineString._geometries.length; i++) {\n      lineStrings.push(this.convertToLineString(multiLineString._geometries[i]).getCoordinates())\n    }\n    return new this.ol.geom.MultiLineString(lineStrings)\n  },\n\n  convertToMultiPolygon (multiPolygon) {\n    var polygons = []\n    for (let i = 0; i < multiPolygon._geometries.length; i++) {\n      polygons.push(this.convertToPolygon(multiPolygon._geometries[i]).getCoordinates())\n    }\n    return new this.ol.geom.MultiPolygon(polygons)\n  },\n\n  convertToCollection (geometryCollection) {\n    var geometries = []\n    for (let i = 0; i < geometryCollection._geometries.length; i++) {\n      var geometry = geometryCollection._geometries[i]\n      geometries.push(this.write(geometry))\n    }\n    return new this.ol.geom.GeometryCollection(geometries)\n  }\n})\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/io/OL3Parser.js\n// module id = 51\n// module chunks = 0","import extend from '../../../../extend';\nexport default function BoundaryNodeRule() {}\nextend(BoundaryNodeRule.prototype, {\n\tisInBoundary: function (boundaryCount) {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn BoundaryNodeRule;\n\t}\n});\nfunction Mod2BoundaryNodeRule() {}\nextend(Mod2BoundaryNodeRule.prototype, {\n\tisInBoundary: function (boundaryCount) {\n\t\treturn boundaryCount % 2 === 1;\n\t},\n\tinterfaces_: function () {\n\t\treturn [BoundaryNodeRule];\n\t},\n\tgetClass: function () {\n\t\treturn Mod2BoundaryNodeRule;\n\t}\n});\nfunction EndPointBoundaryNodeRule() {}\nextend(EndPointBoundaryNodeRule.prototype, {\n\tisInBoundary: function (boundaryCount) {\n\t\treturn boundaryCount > 0;\n\t},\n\tinterfaces_: function () {\n\t\treturn [BoundaryNodeRule];\n\t},\n\tgetClass: function () {\n\t\treturn EndPointBoundaryNodeRule;\n\t}\n});\nfunction MultiValentEndPointBoundaryNodeRule() {}\nextend(MultiValentEndPointBoundaryNodeRule.prototype, {\n\tisInBoundary: function (boundaryCount) {\n\t\treturn boundaryCount > 1;\n\t},\n\tinterfaces_: function () {\n\t\treturn [BoundaryNodeRule];\n\t},\n\tgetClass: function () {\n\t\treturn MultiValentEndPointBoundaryNodeRule;\n\t}\n});\nfunction MonoValentEndPointBoundaryNodeRule() {}\nextend(MonoValentEndPointBoundaryNodeRule.prototype, {\n\tisInBoundary: function (boundaryCount) {\n\t\treturn boundaryCount === 1;\n\t},\n\tinterfaces_: function () {\n\t\treturn [BoundaryNodeRule];\n\t},\n\tgetClass: function () {\n\t\treturn MonoValentEndPointBoundaryNodeRule;\n\t}\n});\nBoundaryNodeRule.Mod2BoundaryNodeRule = Mod2BoundaryNodeRule;\nBoundaryNodeRule.EndPointBoundaryNodeRule = EndPointBoundaryNodeRule;\nBoundaryNodeRule.MultiValentEndPointBoundaryNodeRule = MultiValentEndPointBoundaryNodeRule;\nBoundaryNodeRule.MonoValentEndPointBoundaryNodeRule = MonoValentEndPointBoundaryNodeRule;\nBoundaryNodeRule.MOD2_BOUNDARY_RULE = new Mod2BoundaryNodeRule();\nBoundaryNodeRule.ENDPOINT_BOUNDARY_RULE = new EndPointBoundaryNodeRule();\nBoundaryNodeRule.MULTIVALENT_ENDPOINT_BOUNDARY_RULE = new MultiValentEndPointBoundaryNodeRule();\nBoundaryNodeRule.MONOVALENT_ENDPOINT_BOUNDARY_RULE = new MonoValentEndPointBoundaryNodeRule();\nBoundaryNodeRule.OGC_SFS_BOUNDARY_RULE = BoundaryNodeRule.MOD2_BOUNDARY_RULE;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/algorithm/BoundaryNodeRule.js\n// module id = 52\n// module chunks = 0","import hasInterface from '../../../../hasInterface';\nimport Collection from '../../../../java/util/Collection';\nimport Coordinate from './Coordinate';\nimport extend from '../../../../extend';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport inherits from '../../../../inherits';\nexport default function CoordinateList() {\n\tArrayList.apply(this);\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet coord = arguments[0];\n\t\tthis.ensureCapacity(coord.length);\n\t\tthis.add(coord, true);\n\t} else if (arguments.length === 2) {\n\t\tlet coord = arguments[0], allowRepeated = arguments[1];\n\t\tthis.ensureCapacity(coord.length);\n\t\tthis.add(coord, allowRepeated);\n\t}\n}\ninherits(CoordinateList, ArrayList);\nextend(CoordinateList.prototype, {\n\tgetCoordinate: function (i) {\n\t\treturn this.get(i);\n\t},\n\taddAll: function () {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"boolean\" && hasInterface(arguments[0], Collection))) {\n\t\t\tlet coll = arguments[0], allowRepeated = arguments[1];\n\t\t\tvar isChanged = false;\n\t\t\tfor (var i = coll.iterator(); i.hasNext(); ) {\n\t\t\t\tthis.add(i.next(), allowRepeated);\n\t\t\t\tisChanged = true;\n\t\t\t}\n\t\t\treturn isChanged;\n\t\t} else return ArrayList.prototype.addAll.apply(this, arguments);\n\t},\n\tclone: function () {\n\t\tvar clone = ArrayList.prototype.clone.call(this);\n\t\tfor (var i = 0; i < this.size(); i++) {\n\t\t\tclone.add(i, this.get(i).clone());\n\t\t}\n\t\treturn clone;\n\t},\n\ttoCoordinateArray: function () {\n\t\treturn this.toArray(CoordinateList.coordArrayType);\n\t},\n\tadd: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet coord = arguments[0];\n\t\t\tArrayList.prototype.add.call(this, coord);\n\t\t} else if (arguments.length === 2) {\n\t\t\tif (arguments[0] instanceof Array && typeof arguments[1] === \"boolean\") {\n\t\t\t\tlet coord = arguments[0], allowRepeated = arguments[1];\n\t\t\t\tthis.add(coord, allowRepeated, true);\n\t\t\t\treturn true;\n\t\t\t} else if (arguments[0] instanceof Coordinate && typeof arguments[1] === \"boolean\") {\n\t\t\t\tlet coord = arguments[0], allowRepeated = arguments[1];\n\t\t\t\tif (!allowRepeated) {\n\t\t\t\t\tif (this.size() >= 1) {\n\t\t\t\t\t\tvar last = this.get(this.size() - 1);\n\t\t\t\t\t\tif (last.equals2D(coord)) return null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tArrayList.prototype.add.call(this, coord);\n\t\t\t} else if (arguments[0] instanceof Object && typeof arguments[1] === \"boolean\") {\n\t\t\t\tlet obj = arguments[0], allowRepeated = arguments[1];\n\t\t\t\tthis.add(obj, allowRepeated);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tif (typeof arguments[2] === \"boolean\" && (arguments[0] instanceof Array && typeof arguments[1] === \"boolean\")) {\n\t\t\t\tlet coord = arguments[0], allowRepeated = arguments[1], direction = arguments[2];\n\t\t\t\tif (direction) {\n\t\t\t\t\tfor (var i = 0; i < coord.length; i++) {\n\t\t\t\t\t\tthis.add(coord[i], allowRepeated);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (var i = coord.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tthis.add(coord[i], allowRepeated);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else if (typeof arguments[2] === \"boolean\" && (Number.isInteger(arguments[0]) && arguments[1] instanceof Coordinate)) {\n\t\t\t\tlet i = arguments[0], coord = arguments[1], allowRepeated = arguments[2];\n\t\t\t\tif (!allowRepeated) {\n\t\t\t\t\tvar size = this.size();\n\t\t\t\t\tif (size > 0) {\n\t\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t\tvar prev = this.get(i - 1);\n\t\t\t\t\t\t\tif (prev.equals2D(coord)) return null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i < size) {\n\t\t\t\t\t\t\tvar next = this.get(i);\n\t\t\t\t\t\t\tif (next.equals2D(coord)) return null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tArrayList.prototype.add.call(this, i, coord);\n\t\t\t}\n\t\t} else if (arguments.length === 4) {\n\t\t\tlet coord = arguments[0], allowRepeated = arguments[1], start = arguments[2], end = arguments[3];\n\t\t\tvar inc = 1;\n\t\t\tif (start > end) inc = -1;\n\t\t\tfor (var i = start; i !== end; i += inc) {\n\t\t\t\tthis.add(coord[i], allowRepeated);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t},\n\tcloseRing: function () {\n\t\tif (this.size() > 0) this.add(new Coordinate(this.get(0)), false);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn CoordinateList;\n\t}\n});\nCoordinateList.coordArrayType = new Array(0).fill(null);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/CoordinateList.js\n// module id = 53\n// module chunks = 0","/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nexport default function NoSuchElementException(message) {\n  this.message = message || '';\n};\nNoSuchElementException.prototype = new Error();\n\n\n/**\n * @type {string}\n */\nNoSuchElementException.prototype.name = 'NoSuchElementException';\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/util/NoSuchElementException.js\n// module id = 54\n// module chunks = 0","import extend from '../../../../extend';\nexport default function GeometryFilter() {}\nextend(GeometryFilter.prototype, {\n\tfilter: function (geom) {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn GeometryFilter;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/GeometryFilter.js\n// module id = 55\n// module chunks = 0","export default function StringBuffer (str) {\n  this.str = str\n}\n\nStringBuffer.prototype.append = function (e) {\n  this.str += e\n}\n\nStringBuffer.prototype.setCharAt = function (i, c) {\n  this.str = this.str.substr(0, i) + c + this.str.substr(i + 1)\n}\n\nStringBuffer.prototype.toString = function (e) {\n  return this.str\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/lang/StringBuffer.js\n// module id = 56\n// module chunks = 0","import Location from '../geom/Location';\nimport hasInterface from '../../../../hasInterface';\nimport Coordinate from '../geom/Coordinate';\nimport extend from '../../../../extend';\nimport CoordinateSequence from '../geom/CoordinateSequence';\nimport RobustLineIntersector from './RobustLineIntersector';\nimport RayCrossingCounter from './RayCrossingCounter';\nexport default function PointLocation() {}\nextend(PointLocation.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn PointLocation;\n\t}\n});\nPointLocation.isOnLine = function () {\n\tif (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {\n\t\tlet p = arguments[0], line = arguments[1];\n\t\tvar lineIntersector = new RobustLineIntersector();\n\t\tvar p0 = new Coordinate();\n\t\tvar p1 = new Coordinate();\n\t\tvar n = line.size();\n\t\tfor (var i = 1; i < n; i++) {\n\t\t\tline.getCoordinate(i - 1, p0);\n\t\t\tline.getCoordinate(i, p1);\n\t\t\tlineIntersector.computeIntersection(p, p0, p1);\n\t\t\tif (lineIntersector.hasIntersection()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {\n\t\tlet p = arguments[0], line = arguments[1];\n\t\tvar lineIntersector = new RobustLineIntersector();\n\t\tfor (var i = 1; i < line.length; i++) {\n\t\t\tvar p0 = line[i - 1];\n\t\t\tvar p1 = line[i];\n\t\t\tlineIntersector.computeIntersection(p, p0, p1);\n\t\t\tif (lineIntersector.hasIntersection()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\nPointLocation.locateInRing = function (p, ring) {\n\treturn RayCrossingCounter.locatePointInRing(p, ring);\n};\nPointLocation.isInRing = function (p, ring) {\n\treturn PointLocation.locateInRing(p, ring) !== Location.EXTERIOR;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/algorithm/PointLocation.js\n// module id = 58\n// module chunks = 0","import extend from '../../../../extend';\nimport Exception from '../../../../java/lang/Exception';\nimport inherits from '../../../../inherits';\nexport default function NotRepresentableException() {\n\tException.call(this, \"Projective point not representable on the Cartesian plane.\");\n}\ninherits(NotRepresentableException, Exception);\nextend(NotRepresentableException.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn NotRepresentableException;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/algorithm/NotRepresentableException.js\n// module id = 59\n// module chunks = 0","import NotRepresentableException from './NotRepresentableException';\nimport Coordinate from '../geom/Coordinate';\nimport Double from '../../../../java/lang/Double';\nimport extend from '../../../../extend';\nexport default function HCoordinate() {\n\tthis.x = null;\n\tthis.y = null;\n\tthis.w = null;\n\tif (arguments.length === 0) {\n\t\tthis.x = 0.0;\n\t\tthis.y = 0.0;\n\t\tthis.w = 1.0;\n\t} else if (arguments.length === 1) {\n\t\tlet p = arguments[0];\n\t\tthis.x = p.x;\n\t\tthis.y = p.y;\n\t\tthis.w = 1.0;\n\t} else if (arguments.length === 2) {\n\t\tif (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n\t\t\tlet _x = arguments[0], _y = arguments[1];\n\t\t\tthis.x = _x;\n\t\t\tthis.y = _y;\n\t\t\tthis.w = 1.0;\n\t\t} else if (arguments[0] instanceof HCoordinate && arguments[1] instanceof HCoordinate) {\n\t\t\tlet p1 = arguments[0], p2 = arguments[1];\n\t\t\tthis.x = p1.y * p2.w - p2.y * p1.w;\n\t\t\tthis.y = p2.x * p1.w - p1.x * p2.w;\n\t\t\tthis.w = p1.x * p2.y - p2.x * p1.y;\n\t\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n\t\t\tlet p1 = arguments[0], p2 = arguments[1];\n\t\t\tthis.x = p1.y - p2.y;\n\t\t\tthis.y = p2.x - p1.x;\n\t\t\tthis.w = p1.x * p2.y - p2.x * p1.y;\n\t\t}\n\t} else if (arguments.length === 3) {\n\t\tlet _x = arguments[0], _y = arguments[1], _w = arguments[2];\n\t\tthis.x = _x;\n\t\tthis.y = _y;\n\t\tthis.w = _w;\n\t} else if (arguments.length === 4) {\n\t\tlet p1 = arguments[0], p2 = arguments[1], q1 = arguments[2], q2 = arguments[3];\n\t\tvar px = p1.y - p2.y;\n\t\tvar py = p2.x - p1.x;\n\t\tvar pw = p1.x * p2.y - p2.x * p1.y;\n\t\tvar qx = q1.y - q2.y;\n\t\tvar qy = q2.x - q1.x;\n\t\tvar qw = q1.x * q2.y - q2.x * q1.y;\n\t\tthis.x = py * qw - qy * pw;\n\t\tthis.y = qx * pw - px * qw;\n\t\tthis.w = px * qy - qx * py;\n\t}\n}\nextend(HCoordinate.prototype, {\n\tgetY: function () {\n\t\tvar a = this.y / this.w;\n\t\tif (Double.isNaN(a) || Double.isInfinite(a)) {\n\t\t\tthrow new NotRepresentableException();\n\t\t}\n\t\treturn a;\n\t},\n\tgetX: function () {\n\t\tvar a = this.x / this.w;\n\t\tif (Double.isNaN(a) || Double.isInfinite(a)) {\n\t\t\tthrow new NotRepresentableException();\n\t\t}\n\t\treturn a;\n\t},\n\tgetCoordinate: function () {\n\t\tvar p = new Coordinate();\n\t\tp.x = this.getX();\n\t\tp.y = this.getY();\n\t\treturn p;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn HCoordinate;\n\t}\n});\nHCoordinate.intersection = function (p1, p2, q1, q2) {\n\tvar px = p1.y - p2.y;\n\tvar py = p2.x - p1.x;\n\tvar pw = p1.x * p2.y - p2.x * p1.y;\n\tvar qx = q1.y - q2.y;\n\tvar qy = q2.x - q1.x;\n\tvar qw = q1.x * q2.y - q2.x * q1.y;\n\tvar x = py * qw - qy * pw;\n\tvar y = qx * pw - px * qw;\n\tvar w = px * qy - qx * py;\n\tvar xInt = x / w;\n\tvar yInt = y / w;\n\tif (Double.isNaN(xInt) || (Double.isInfinite(xInt) || Double.isNaN(yInt)) || Double.isInfinite(yInt)) {\n\t\tthrow new NotRepresentableException();\n\t}\n\treturn new Coordinate(xInt, yInt);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/algorithm/HCoordinate.js\n// module id = 60\n// module chunks = 0","import IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../extend';\nimport MathUtil from '../math/MathUtil';\nimport Envelope from '../geom/Envelope';\nexport default function Distance() {}\nextend(Distance.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Distance;\n\t}\n});\nDistance.segmentToSegment = function (A, B, C, D) {\n\tif (A.equals(B)) return Distance.pointToSegment(A, C, D);\n\tif (C.equals(D)) return Distance.pointToSegment(D, A, B);\n\tvar noIntersection = false;\n\tif (!Envelope.intersects(A, B, C, D)) {\n\t\tnoIntersection = true;\n\t} else {\n\t\tvar denom = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);\n\t\tif (denom === 0) {\n\t\t\tnoIntersection = true;\n\t\t} else {\n\t\t\tvar r_num = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);\n\t\t\tvar s_num = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y);\n\t\t\tvar s = s_num / denom;\n\t\t\tvar r = r_num / denom;\n\t\t\tif (r < 0 || r > 1 || s < 0 || s > 1) {\n\t\t\t\tnoIntersection = true;\n\t\t\t}\n\t\t}\n\t}\n\tif (noIntersection) {\n\t\treturn MathUtil.min(Distance.pointToSegment(A, C, D), Distance.pointToSegment(B, C, D), Distance.pointToSegment(C, A, B), Distance.pointToSegment(D, A, B));\n\t}\n\treturn 0.0;\n};\nDistance.pointToSegment = function (p, A, B) {\n\tif (A.x === B.x && A.y === B.y) return p.distance(A);\n\tvar len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n\tvar r = ((p.x - A.x) * (B.x - A.x) + (p.y - A.y) * (B.y - A.y)) / len2;\n\tif (r <= 0.0) return p.distance(A);\n\tif (r >= 1.0) return p.distance(B);\n\tvar s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n\treturn Math.abs(s) * Math.sqrt(len2);\n};\nDistance.pointToLinePerpendicular = function (p, A, B) {\n\tvar len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n\tvar s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n\treturn Math.abs(s) * Math.sqrt(len2);\n};\nDistance.pointToSegmentString = function (p, line) {\n\tif (line.length === 0) throw new IllegalArgumentException(\"Line array must contain at least one vertex\");\n\tvar minDistance = p.distance(line[0]);\n\tfor (var i = 0; i < line.length - 1; i++) {\n\t\tvar dist = Distance.pointToSegment(p, line[i], line[i + 1]);\n\t\tif (dist < minDistance) {\n\t\t\tminDistance = dist;\n\t\t}\n\t}\n\treturn minDistance;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/algorithm/Distance.js\n// module id = 61\n// module chunks = 0","import Location from '../geom/Location';\nimport Coordinate from '../geom/Coordinate';\nimport Node from './Node';\nimport extend from '../../../../extend';\nimport NodeMap from './NodeMap';\nimport Orientation from '../algorithm/Orientation';\nimport DirectedEdge from './DirectedEdge';\nimport System from '../../../../java/lang/System';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport Quadrant from './Quadrant';\nimport NodeFactory from './NodeFactory';\nexport default function PlanarGraph() {\n\tthis._edges = new ArrayList();\n\tthis._nodes = null;\n\tthis._edgeEndList = new ArrayList();\n\tif (arguments.length === 0) {\n\t\tthis._nodes = new NodeMap(new NodeFactory());\n\t} else if (arguments.length === 1) {\n\t\tlet nodeFact = arguments[0];\n\t\tthis._nodes = new NodeMap(nodeFact);\n\t}\n}\nextend(PlanarGraph.prototype, {\n\tprintEdges: function (out) {\n\t\tout.println(\"Edges:\");\n\t\tfor (var i = 0; i < this._edges.size(); i++) {\n\t\t\tout.println(\"edge \" + i + \":\");\n\t\t\tvar e = this._edges.get(i);\n\t\t\te.print(out);\n\t\t\te.eiList.print(out);\n\t\t}\n\t},\n\tfind: function (coord) {\n\t\treturn this._nodes.find(coord);\n\t},\n\taddNode: function () {\n\t\tif (arguments[0] instanceof Node) {\n\t\t\tlet node = arguments[0];\n\t\t\treturn this._nodes.addNode(node);\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet coord = arguments[0];\n\t\t\treturn this._nodes.addNode(coord);\n\t\t}\n\t},\n\tgetNodeIterator: function () {\n\t\treturn this._nodes.iterator();\n\t},\n\tlinkResultDirectedEdges: function () {\n\t\tfor (var nodeit = this._nodes.iterator(); nodeit.hasNext(); ) {\n\t\t\tvar node = nodeit.next();\n\t\t\tnode.getEdges().linkResultDirectedEdges();\n\t\t}\n\t},\n\tdebugPrintln: function (o) {\n\t\tSystem.out.println(o);\n\t},\n\tisBoundaryNode: function (geomIndex, coord) {\n\t\tvar node = this._nodes.find(coord);\n\t\tif (node === null) return false;\n\t\tvar label = node.getLabel();\n\t\tif (label !== null && label.getLocation(geomIndex) === Location.BOUNDARY) return true;\n\t\treturn false;\n\t},\n\tlinkAllDirectedEdges: function () {\n\t\tfor (var nodeit = this._nodes.iterator(); nodeit.hasNext(); ) {\n\t\t\tvar node = nodeit.next();\n\t\t\tnode.getEdges().linkAllDirectedEdges();\n\t\t}\n\t},\n\tmatchInSameDirection: function (p0, p1, ep0, ep1) {\n\t\tif (!p0.equals(ep0)) return false;\n\t\tif (Orientation.index(p0, p1, ep1) === Orientation.COLLINEAR && Quadrant.quadrant(p0, p1) === Quadrant.quadrant(ep0, ep1)) return true;\n\t\treturn false;\n\t},\n\tgetEdgeEnds: function () {\n\t\treturn this._edgeEndList;\n\t},\n\tdebugPrint: function (o) {\n\t\tSystem.out.print(o);\n\t},\n\tgetEdgeIterator: function () {\n\t\treturn this._edges.iterator();\n\t},\n\tfindEdgeInSameDirection: function (p0, p1) {\n\t\tfor (var i = 0; i < this._edges.size(); i++) {\n\t\t\tvar e = this._edges.get(i);\n\t\t\tvar eCoord = e.getCoordinates();\n\t\t\tif (this.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) return e;\n\t\t\tif (this.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2])) return e;\n\t\t}\n\t\treturn null;\n\t},\n\tinsertEdge: function (e) {\n\t\tthis._edges.add(e);\n\t},\n\tfindEdgeEnd: function (e) {\n\t\tfor (var i = this.getEdgeEnds().iterator(); i.hasNext(); ) {\n\t\t\tvar ee = i.next();\n\t\t\tif (ee.getEdge() === e) return ee;\n\t\t}\n\t\treturn null;\n\t},\n\taddEdges: function (edgesToAdd) {\n\t\tfor (var it = edgesToAdd.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tthis._edges.add(e);\n\t\t\tvar de1 = new DirectedEdge(e, true);\n\t\t\tvar de2 = new DirectedEdge(e, false);\n\t\t\tde1.setSym(de2);\n\t\t\tde2.setSym(de1);\n\t\t\tthis.add(de1);\n\t\t\tthis.add(de2);\n\t\t}\n\t},\n\tadd: function (e) {\n\t\tthis._nodes.add(e);\n\t\tthis._edgeEndList.add(e);\n\t},\n\tgetNodes: function () {\n\t\treturn this._nodes.values();\n\t},\n\tfindEdge: function (p0, p1) {\n\t\tfor (var i = 0; i < this._edges.size(); i++) {\n\t\t\tvar e = this._edges.get(i);\n\t\t\tvar eCoord = e.getCoordinates();\n\t\t\tif (p0.equals(eCoord[0]) && p1.equals(eCoord[1])) return e;\n\t\t}\n\t\treturn null;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn PlanarGraph;\n\t}\n});\nPlanarGraph.linkResultDirectedEdges = function (nodes) {\n\tfor (var nodeit = nodes.iterator(); nodeit.hasNext(); ) {\n\t\tvar node = nodeit.next();\n\t\tnode.getEdges().linkResultDirectedEdges();\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geomgraph/PlanarGraph.js\n// module id = 62\n// module chunks = 0","import Location from '../geom/Location';\nimport extend from '../../../../extend';\nimport Label from './Label';\nimport inherits from '../../../../inherits';\nimport GraphComponent from './GraphComponent';\nexport default function Node() {\n\tGraphComponent.apply(this);\n\tthis._coord = null;\n\tthis._edges = null;\n\tlet coord = arguments[0], edges = arguments[1];\n\tthis._coord = coord;\n\tthis._edges = edges;\n\tthis._label = new Label(0, Location.NONE);\n}\ninherits(Node, GraphComponent);\nextend(Node.prototype, {\n\tisIncidentEdgeInResult: function () {\n\t\tfor (var it = this.getEdges().getEdges().iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tif (de.getEdge().isInResult()) return true;\n\t\t}\n\t\treturn false;\n\t},\n\tisIsolated: function () {\n\t\treturn this._label.getGeometryCount() === 1;\n\t},\n\tgetCoordinate: function () {\n\t\treturn this._coord;\n\t},\n\tprint: function (out) {\n\t\tout.println(\"node \" + this._coord + \" lbl: \" + this._label);\n\t},\n\tcomputeIM: function (im) {},\n\tcomputeMergedLocation: function (label2, eltIndex) {\n\t\tvar loc = Location.NONE;\n\t\tloc = this._label.getLocation(eltIndex);\n\t\tif (!label2.isNull(eltIndex)) {\n\t\t\tvar nLoc = label2.getLocation(eltIndex);\n\t\t\tif (loc !== Location.BOUNDARY) loc = nLoc;\n\t\t}\n\t\treturn loc;\n\t},\n\tsetLabel: function () {\n\t\tif (arguments.length === 2 && (Number.isInteger(arguments[1]) && Number.isInteger(arguments[0]))) {\n\t\t\tlet argIndex = arguments[0], onLocation = arguments[1];\n\t\t\tif (this._label === null) {\n\t\t\t\tthis._label = new Label(argIndex, onLocation);\n\t\t\t} else this._label.setLocation(argIndex, onLocation);\n\t\t} else return GraphComponent.prototype.setLabel.apply(this, arguments);\n\t},\n\tgetEdges: function () {\n\t\treturn this._edges;\n\t},\n\tmergeLabel: function () {\n\t\tif (arguments[0] instanceof Node) {\n\t\t\tlet n = arguments[0];\n\t\t\tthis.mergeLabel(n._label);\n\t\t} else if (arguments[0] instanceof Label) {\n\t\t\tlet label2 = arguments[0];\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tvar loc = this.computeMergedLocation(label2, i);\n\t\t\t\tvar thisLoc = this._label.getLocation(i);\n\t\t\t\tif (thisLoc === Location.NONE) this._label.setLocation(i, loc);\n\t\t\t}\n\t\t}\n\t},\n\tadd: function (e) {\n\t\tthis._edges.insert(e);\n\t\te.setNode(this);\n\t},\n\tsetLabelBoundary: function (argIndex) {\n\t\tif (this._label === null) return null;\n\t\tvar loc = Location.NONE;\n\t\tif (this._label !== null) loc = this._label.getLocation(argIndex);\n\t\tvar newLoc = null;\n\t\tswitch (loc) {\n\t\t\tcase Location.BOUNDARY:\n\t\t\t\tnewLoc = Location.INTERIOR;\n\t\t\t\tbreak;\n\t\t\tcase Location.INTERIOR:\n\t\t\t\tnewLoc = Location.BOUNDARY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tnewLoc = Location.BOUNDARY;\n\t\t\t\tbreak;\n\t\t}\n\t\tthis._label.setLocation(argIndex, newLoc);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Node;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geomgraph/Node.js\n// module id = 63\n// module chunks = 0","import extend from '../../../../extend';\nexport default function ItemVisitor() {}\nextend(ItemVisitor.prototype, {\n\tvisitItem: function (item) {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn ItemVisitor;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/index/ItemVisitor.js\n// module id = 64\n// module chunks = 0","/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nexport default function OperationNotSupported(message) {\n  this.message = message || '';\n};\nOperationNotSupported.prototype = new Error();\n\n\n/**\n * @type {string}\n */\nOperationNotSupported.prototype.name = 'OperationNotSupported';\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/util/OperationNotSupported.js\n// module id = 65\n// module chunks = 0","import Collection from './Collection'\nimport Iterator from './Iterator'\nimport NoSuchElementException from './NoSuchElementException'\nimport OperationNotSupported from './OperationNotSupported'\nimport Set from './Set'\n\n/**\n * @see http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html\n *\n * @extends {javascript.util.Set}\n * @constructor\n * @private\n */\nexport default function HashSet() {\n  /**\n   * @type {Array}\n   * @private\n  */\n  this.array_ = [];\n\n  if (arguments[0] instanceof Collection) {\n    this.addAll(arguments[0]);\n  }\n};\nHashSet.prototype = new Set();\n\n\n/**\n * @override\n */\nHashSet.prototype.contains = function(o) {\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    var e = this.array_[i];\n    if (e === o) {\n      return true;\n    }\n  }\n  return false;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.add = function(o) {\n  if (this.contains(o)) {\n    return false;\n  }\n\n  this.array_.push(o);\n\n  return true;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.addAll = function(c) {\n  for (var i = c.iterator(); i.hasNext();) {\n    this.add(i.next());\n  }\n  return true;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.remove = function(o) {\n  throw new javascript.util.OperationNotSupported();\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.size = function() {\n  return this.array_.length;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.isEmpty = function() {\n  return this.array_.length === 0;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.toArray = function() {\n  var array = [];\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    array.push(this.array_[i]);\n  }\n\n  return array;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.iterator = function() {\n  return new Iterator_(this);\n};\n\n\n\n/**\n * @extends {Iterator}\n * @param {HashSet} hashSet\n * @constructor\n * @private\n */\nvar Iterator_ = function(hashSet) {\n  /**\n   * @type {HashSet}\n   * @private\n   */\n  this.hashSet_ = hashSet;\n  /**\n   * @type {number}\n   * @private\n   */\n  this.position_ = 0;\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.next = function() {\n  if (this.position_ === this.hashSet_.size()) {\n    throw new NoSuchElementException();\n  }\n  return this.hashSet_.array_[this.position_++];\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.hasNext = function() {\n  if (this.position_ < this.hashSet_.size()) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.remove = function() {\n  throw new OperationNotSupported();\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/util/HashSet.js\n// module id = 67\n// module chunks = 0","import ArrayList from './ArrayList'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Arrays.html\n *\n * @constructor\n * @private\n */\nexport default function Arrays() {};\n\n/**\n */\nArrays.sort = function() {\n  var a = arguments[0], i, t, comparator, compare;\n  if (arguments.length === 1) {\n    compare = function(a, b) {\n      return a.compareTo(b);\n    }\n    a.sort(compare);\n    return;\n  } else if (arguments.length === 2) {\n    comparator = arguments[1];\n    compare = function(a, b) {\n      return comparator['compare'](a, b);\n    };\n    a.sort(compare);\n  } else if (arguments.length === 3) {\n    t = a.slice(arguments[1], arguments[2]);\n    t.sort();\n    var r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));\n    a.splice(0, a.length);\n    for (i = 0; i < r.length; i++) {\n      a.push(r[i]);\n    }\n    return;\n  } else if (arguments.length === 4) {\n    t = a.slice(arguments[1], arguments[2]);\n    comparator = arguments[3];\n    compare = function(a, b) {\n      return comparator['compare'](a, b);\n    };\n    t.sort(compare);\n    r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));\n    a.splice(0, a.length);\n    for (i = 0; i < r.length; i++) {\n      a.push(r[i]);\n    }\n    return;\n  }\n};\n\n\n/**\n * @param {Array} array\n * @return {ArrayList}\n */\nArrays.asList = function(array) {\n  var arrayList = new ArrayList();\n  for (var i = 0, len = array.length; i < len; i++) {\n    arrayList.add(array[i]);\n  }\n  return arrayList;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/util/Arrays.js\n// module id = 68\n// module chunks = 0","import hasInterface from '../../../../hasInterface';\nimport StringUtil from '../util/StringUtil';\nimport Double from '../../../../java/lang/Double';\nimport extend from '../../../../extend';\nimport CoordinateSequence from './CoordinateSequence';\nimport StringBuilder from '../../../../java/lang/StringBuilder';\nexport default function CoordinateSequences() {}\nextend(CoordinateSequences.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn CoordinateSequences;\n\t}\n});\nCoordinateSequences.copyCoord = function (src, srcPos, dest, destPos) {\n\tvar minDim = Math.min(src.getDimension(), dest.getDimension());\n\tfor (var dim = 0; dim < minDim; dim++) {\n\t\tdest.setOrdinate(destPos, dim, src.getOrdinate(srcPos, dim));\n\t}\n};\nCoordinateSequences.isRing = function (seq) {\n\tvar n = seq.size();\n\tif (n === 0) return true;\n\tif (n <= 3) return false;\n\treturn seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);\n};\nCoordinateSequences.isEqual = function (cs1, cs2) {\n\tvar cs1Size = cs1.size();\n\tvar cs2Size = cs2.size();\n\tif (cs1Size !== cs2Size) return false;\n\tvar dim = Math.min(cs1.getDimension(), cs2.getDimension());\n\tfor (var i = 0; i < cs1Size; i++) {\n\t\tfor (var d = 0; d < dim; d++) {\n\t\t\tvar v1 = cs1.getOrdinate(i, d);\n\t\t\tvar v2 = cs2.getOrdinate(i, d);\n\t\t\tif (cs1.getOrdinate(i, d) === cs2.getOrdinate(i, d)) continue;\n\t\t\tif (Double.isNaN(v1) && Double.isNaN(v2)) continue;\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n};\nCoordinateSequences.extend = function (fact, seq, size) {\n\tvar newseq = fact.create(size, seq.getDimension());\n\tvar n = seq.size();\n\tCoordinateSequences.copy(seq, 0, newseq, 0, n);\n\tif (n > 0) {\n\t\tfor (var i = n; i < size; i++) CoordinateSequences.copy(seq, n - 1, newseq, i, 1);\n\t}\n\treturn newseq;\n};\nCoordinateSequences.reverse = function (seq) {\n\tvar last = seq.size() - 1;\n\tvar mid = Math.trunc(last / 2);\n\tfor (var i = 0; i <= mid; i++) {\n\t\tCoordinateSequences.swap(seq, i, last - i);\n\t}\n};\nCoordinateSequences.swap = function (seq, i, j) {\n\tif (i === j) return null;\n\tfor (var dim = 0; dim < seq.getDimension(); dim++) {\n\t\tvar tmp = seq.getOrdinate(i, dim);\n\t\tseq.setOrdinate(i, dim, seq.getOrdinate(j, dim));\n\t\tseq.setOrdinate(j, dim, tmp);\n\t}\n};\nCoordinateSequences.copy = function (src, srcPos, dest, destPos, length) {\n\tfor (var i = 0; i < length; i++) {\n\t\tCoordinateSequences.copyCoord(src, srcPos + i, dest, destPos + i);\n\t}\n};\nCoordinateSequences.toString = function () {\n\tif (arguments.length === 1 && hasInterface(arguments[0], CoordinateSequence)) {\n\t\tlet cs = arguments[0];\n\t\tvar size = cs.size();\n\t\tif (size === 0) return \"()\";\n\t\tvar dim = cs.getDimension();\n\t\tvar builder = new StringBuilder();\n\t\tbuilder.append('(');\n\t\tfor (var i = 0; i < size; i++) {\n\t\t\tif (i > 0) builder.append(\" \");\n\t\t\tfor (var d = 0; d < dim; d++) {\n\t\t\t\tif (d > 0) builder.append(\",\");\n\t\t\t\tbuilder.append(StringUtil.toString(cs.getOrdinate(i, d)));\n\t\t\t}\n\t\t}\n\t\tbuilder.append(')');\n\t\treturn builder.toString();\n\t}\n};\nCoordinateSequences.ensureValidRing = function (fact, seq) {\n\tvar n = seq.size();\n\tif (n === 0) return seq;\n\tif (n <= 3) return CoordinateSequences.createClosedRing(fact, seq, 4);\n\tvar isClosed = seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);\n\tif (isClosed) return seq;\n\treturn CoordinateSequences.createClosedRing(fact, seq, n + 1);\n};\nCoordinateSequences.createClosedRing = function (fact, seq, size) {\n\tvar newseq = fact.create(size, seq.getDimension());\n\tvar n = seq.size();\n\tCoordinateSequences.copy(seq, 0, newseq, 0, n);\n\tfor (var i = n; i < size; i++) CoordinateSequences.copy(seq, 0, newseq, i, 1);\n\treturn newseq;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/CoordinateSequences.js\n// module id = 69\n// module chunks = 0","import hasInterface from '../../../../../hasInterface';\nimport Coordinate from '../Coordinate';\nimport IllegalArgumentException from '../../../../../java/lang/IllegalArgumentException';\nimport Double from '../../../../../java/lang/Double';\nimport extend from '../../../../../extend';\nimport CoordinateSequence from '../CoordinateSequence';\nimport Serializable from '../../../../../java/io/Serializable';\nimport StringBuilder from '../../../../../java/lang/StringBuilder';\nexport default function CoordinateArraySequence() {\n\tthis._dimension = 3;\n\tthis._coordinates = null;\n\tif (arguments.length === 1) {\n\t\tif (arguments[0] instanceof Array) {\n\t\t\tlet coordinates = arguments[0];\n\t\t\tCoordinateArraySequence.call(this, coordinates, 3);\n\t\t} else if (Number.isInteger(arguments[0])) {\n\t\t\tlet size = arguments[0];\n\t\t\tthis._coordinates = new Array(size).fill(null);\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tthis._coordinates[i] = new Coordinate();\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\tlet coordSeq = arguments[0];\n\t\t\tif (coordSeq === null) {\n\t\t\t\tthis._coordinates = new Array(0).fill(null);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthis._dimension = coordSeq.getDimension();\n\t\t\tthis._coordinates = new Array(coordSeq.size()).fill(null);\n\t\t\tfor (var i = 0; i < this._coordinates.length; i++) {\n\t\t\t\tthis._coordinates[i] = coordSeq.getCoordinateCopy(i);\n\t\t\t}\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tif (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {\n\t\t\tlet coordinates = arguments[0], dimension = arguments[1];\n\t\t\tthis._coordinates = coordinates;\n\t\t\tthis._dimension = dimension;\n\t\t\tif (coordinates === null) this._coordinates = new Array(0).fill(null);\n\t\t} else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n\t\t\tlet size = arguments[0], dimension = arguments[1];\n\t\t\tthis._coordinates = new Array(size).fill(null);\n\t\t\tthis._dimension = dimension;\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tthis._coordinates[i] = new Coordinate();\n\t\t\t}\n\t\t}\n\t}\n}\nextend(CoordinateArraySequence.prototype, {\n\tsetOrdinate: function (index, ordinateIndex, value) {\n\t\tswitch (ordinateIndex) {\n\t\t\tcase CoordinateSequence.X:\n\t\t\t\tthis._coordinates[index].x = value;\n\t\t\t\tbreak;\n\t\t\tcase CoordinateSequence.Y:\n\t\t\t\tthis._coordinates[index].y = value;\n\t\t\t\tbreak;\n\t\t\tcase CoordinateSequence.Z:\n\t\t\t\tthis._coordinates[index].z = value;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException(\"invalid ordinateIndex\");\n\t\t}\n\t},\n\tsize: function () {\n\t\treturn this._coordinates.length;\n\t},\n\tgetOrdinate: function (index, ordinateIndex) {\n\t\tswitch (ordinateIndex) {\n\t\t\tcase CoordinateSequence.X:\n\t\t\t\treturn this._coordinates[index].x;\n\t\t\tcase CoordinateSequence.Y:\n\t\t\t\treturn this._coordinates[index].y;\n\t\t\tcase CoordinateSequence.Z:\n\t\t\t\treturn this._coordinates[index].z;\n\t\t}\n\t\treturn Double.NaN;\n\t},\n\tgetCoordinate: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet i = arguments[0];\n\t\t\treturn this._coordinates[i];\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet index = arguments[0], coord = arguments[1];\n\t\t\tcoord.x = this._coordinates[index].x;\n\t\t\tcoord.y = this._coordinates[index].y;\n\t\t\tcoord.z = this._coordinates[index].z;\n\t\t}\n\t},\n\tgetCoordinateCopy: function (i) {\n\t\treturn new Coordinate(this._coordinates[i]);\n\t},\n\tgetDimension: function () {\n\t\treturn this._dimension;\n\t},\n\tgetX: function (index) {\n\t\treturn this._coordinates[index].x;\n\t},\n\texpandEnvelope: function (env) {\n\t\tfor (var i = 0; i < this._coordinates.length; i++) {\n\t\t\tenv.expandToInclude(this._coordinates[i]);\n\t\t}\n\t\treturn env;\n\t},\n\tcopy: function () {\n\t\tvar cloneCoordinates = new Array(this.size()).fill(null);\n\t\tfor (var i = 0; i < this._coordinates.length; i++) {\n\t\t\tcloneCoordinates[i] = this._coordinates[i].copy();\n\t\t}\n\t\treturn new CoordinateArraySequence(cloneCoordinates, this._dimension);\n\t},\n\ttoString: function () {\n\t\tif (this._coordinates.length > 0) {\n\t\t\tvar strBuilder = new StringBuilder(17 * this._coordinates.length);\n\t\t\tstrBuilder.append('(');\n\t\t\tstrBuilder.append(this._coordinates[0]);\n\t\t\tfor (var i = 1; i < this._coordinates.length; i++) {\n\t\t\t\tstrBuilder.append(\", \");\n\t\t\t\tstrBuilder.append(this._coordinates[i]);\n\t\t\t}\n\t\t\tstrBuilder.append(')');\n\t\t\treturn strBuilder.toString();\n\t\t} else {\n\t\t\treturn \"()\";\n\t\t}\n\t},\n\tgetY: function (index) {\n\t\treturn this._coordinates[index].y;\n\t},\n\ttoCoordinateArray: function () {\n\t\treturn this._coordinates;\n\t},\n\tinterfaces_: function () {\n\t\treturn [CoordinateSequence, Serializable];\n\t},\n\tgetClass: function () {\n\t\treturn CoordinateArraySequence;\n\t}\n});\nCoordinateArraySequence.serialVersionUID = -915438501601840650;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/impl/CoordinateArraySequence.js\n// module id = 70\n// module chunks = 0","import HashMap from '../../../../java/util/HashMap';\nimport Coordinate from './Coordinate';\nimport Double from '../../../../java/lang/Double';\nimport extend from '../../../../extend';\nimport Integer from '../../../../java/lang/Integer';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Serializable from '../../../../java/io/Serializable';\nexport default function PrecisionModel() {\n\tthis._modelType = null;\n\tthis._scale = null;\n\tif (arguments.length === 0) {\n\t\tthis._modelType = PrecisionModel.FLOATING;\n\t} else if (arguments.length === 1) {\n\t\tif (arguments[0] instanceof Type) {\n\t\t\tlet modelType = arguments[0];\n\t\t\tthis._modelType = modelType;\n\t\t\tif (modelType === PrecisionModel.FIXED) {\n\t\t\t\tthis.setScale(1.0);\n\t\t\t}\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet scale = arguments[0];\n\t\t\tthis._modelType = PrecisionModel.FIXED;\n\t\t\tthis.setScale(scale);\n\t\t} else if (arguments[0] instanceof PrecisionModel) {\n\t\t\tlet pm = arguments[0];\n\t\t\tthis._modelType = pm._modelType;\n\t\t\tthis._scale = pm._scale;\n\t\t}\n\t}\n}\nextend(PrecisionModel.prototype, {\n\tequals: function (other) {\n\t\tif (!(other instanceof PrecisionModel)) {\n\t\t\treturn false;\n\t\t}\n\t\tvar otherPrecisionModel = other;\n\t\treturn this._modelType === otherPrecisionModel._modelType && this._scale === otherPrecisionModel._scale;\n\t},\n\tcompareTo: function (o) {\n\t\tvar other = o;\n\t\tvar sigDigits = this.getMaximumSignificantDigits();\n\t\tvar otherSigDigits = other.getMaximumSignificantDigits();\n\t\treturn new Integer(sigDigits).compareTo(new Integer(otherSigDigits));\n\t},\n\tgetScale: function () {\n\t\treturn this._scale;\n\t},\n\tisFloating: function () {\n\t\treturn this._modelType === PrecisionModel.FLOATING || this._modelType === PrecisionModel.FLOATING_SINGLE;\n\t},\n\tgetType: function () {\n\t\treturn this._modelType;\n\t},\n\ttoString: function () {\n\t\tvar description = \"UNKNOWN\";\n\t\tif (this._modelType === PrecisionModel.FLOATING) {\n\t\t\tdescription = \"Floating\";\n\t\t} else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n\t\t\tdescription = \"Floating-Single\";\n\t\t} else if (this._modelType === PrecisionModel.FIXED) {\n\t\t\tdescription = \"Fixed (Scale=\" + this.getScale() + \")\";\n\t\t}\n\t\treturn description;\n\t},\n\tmakePrecise: function () {\n\t\tif (typeof arguments[0] === \"number\") {\n\t\t\tlet val = arguments[0];\n\t\t\tif (Double.isNaN(val)) return val;\n\t\t\tif (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n\t\t\t\tvar floatSingleVal = val;\n\t\t\t\treturn floatSingleVal;\n\t\t\t}\n\t\t\tif (this._modelType === PrecisionModel.FIXED) {\n\t\t\t\treturn Math.round(val * this._scale) / this._scale;\n\t\t\t}\n\t\t\treturn val;\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet coord = arguments[0];\n\t\t\tif (this._modelType === PrecisionModel.FLOATING) return null;\n\t\t\tcoord.x = this.makePrecise(coord.x);\n\t\t\tcoord.y = this.makePrecise(coord.y);\n\t\t}\n\t},\n\tgetMaximumSignificantDigits: function () {\n\t\tvar maxSigDigits = 16;\n\t\tif (this._modelType === PrecisionModel.FLOATING) {\n\t\t\tmaxSigDigits = 16;\n\t\t} else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n\t\t\tmaxSigDigits = 6;\n\t\t} else if (this._modelType === PrecisionModel.FIXED) {\n\t\t\tmaxSigDigits = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)));\n\t\t}\n\t\treturn maxSigDigits;\n\t},\n\tsetScale: function (scale) {\n\t\tthis._scale = Math.abs(scale);\n\t},\n\tinterfaces_: function () {\n\t\treturn [Serializable, Comparable];\n\t},\n\tgetClass: function () {\n\t\treturn PrecisionModel;\n\t}\n});\nPrecisionModel.mostPrecise = function (pm1, pm2) {\n\tif (pm1.compareTo(pm2) >= 0) return pm1;\n\treturn pm2;\n};\nfunction Type() {\n\tthis._name = null;\n\tlet name = arguments[0];\n\tthis._name = name;\n\tType.nameToTypeMap.put(name, this);\n}\nextend(Type.prototype, {\n\treadResolve: function () {\n\t\treturn Type.nameToTypeMap.get(this._name);\n\t},\n\ttoString: function () {\n\t\treturn this._name;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Serializable];\n\t},\n\tgetClass: function () {\n\t\treturn Type;\n\t}\n});\nType.serialVersionUID = -5528602631731589822;\nType.nameToTypeMap = new HashMap();\nPrecisionModel.Type = Type;\nPrecisionModel.serialVersionUID = 7777263578777803835;\nPrecisionModel.FIXED = new Type(\"FIXED\");\nPrecisionModel.FLOATING = new Type(\"FLOATING\");\nPrecisionModel.FLOATING_SINGLE = new Type(\"FLOATING SINGLE\");\nPrecisionModel.maximumPreciseValue = 9007199254740992.0;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/PrecisionModel.js\n// module id = 71\n// module chunks = 0","import STRtree from '../index/strtree/STRtree';\nimport NodedSegmentString from './NodedSegmentString';\nimport MonotoneChainOverlapAction from '../index/chain/MonotoneChainOverlapAction';\nimport extend from '../../../../extend';\nimport MonotoneChainBuilder from '../index/chain/MonotoneChainBuilder';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport inherits from '../../../../inherits';\nimport SinglePassNoder from './SinglePassNoder';\nexport default function MCIndexNoder() {\n\tthis._monoChains = new ArrayList();\n\tthis._index = new STRtree();\n\tthis._idCounter = 0;\n\tthis._nodedSegStrings = null;\n\tthis._nOverlaps = 0;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet si = arguments[0];\n\t\tSinglePassNoder.call(this, si);\n\t}\n}\ninherits(MCIndexNoder, SinglePassNoder);\nextend(MCIndexNoder.prototype, {\n\tgetMonotoneChains: function () {\n\t\treturn this._monoChains;\n\t},\n\tgetNodedSubstrings: function () {\n\t\treturn NodedSegmentString.getNodedSubstrings(this._nodedSegStrings);\n\t},\n\tgetIndex: function () {\n\t\treturn this._index;\n\t},\n\tadd: function (segStr) {\n\t\tvar segChains = MonotoneChainBuilder.getChains(segStr.getCoordinates(), segStr);\n\t\tfor (var i = segChains.iterator(); i.hasNext(); ) {\n\t\t\tvar mc = i.next();\n\t\t\tmc.setId(this._idCounter++);\n\t\t\tthis._index.insert(mc.getEnvelope(), mc);\n\t\t\tthis._monoChains.add(mc);\n\t\t}\n\t},\n\tcomputeNodes: function (inputSegStrings) {\n\t\tthis._nodedSegStrings = inputSegStrings;\n\t\tfor (var i = inputSegStrings.iterator(); i.hasNext(); ) {\n\t\t\tthis.add(i.next());\n\t\t}\n\t\tthis.intersectChains();\n\t},\n\tintersectChains: function () {\n\t\tvar overlapAction = new SegmentOverlapAction(this._segInt);\n\t\tfor (var i = this._monoChains.iterator(); i.hasNext(); ) {\n\t\t\tvar queryChain = i.next();\n\t\t\tvar overlapChains = this._index.query(queryChain.getEnvelope());\n\t\t\tfor (var j = overlapChains.iterator(); j.hasNext(); ) {\n\t\t\t\tvar testChain = j.next();\n\t\t\t\tif (testChain.getId() > queryChain.getId()) {\n\t\t\t\t\tqueryChain.computeOverlaps(testChain, overlapAction);\n\t\t\t\t\tthis._nOverlaps++;\n\t\t\t\t}\n\t\t\t\tif (this._segInt.isDone()) return null;\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn MCIndexNoder;\n\t}\n});\nfunction SegmentOverlapAction() {\n\tMonotoneChainOverlapAction.apply(this);\n\tthis._si = null;\n\tlet si = arguments[0];\n\tthis._si = si;\n}\ninherits(SegmentOverlapAction, MonotoneChainOverlapAction);\nextend(SegmentOverlapAction.prototype, {\n\toverlap: function () {\n\t\tif (arguments.length === 4) {\n\t\t\tlet mc1 = arguments[0], start1 = arguments[1], mc2 = arguments[2], start2 = arguments[3];\n\t\t\tvar ss1 = mc1.getContext();\n\t\t\tvar ss2 = mc2.getContext();\n\t\t\tthis._si.processIntersections(ss1, start1, ss2, start2);\n\t\t} else return MonotoneChainOverlapAction.prototype.overlap.apply(this, arguments);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn SegmentOverlapAction;\n\t}\n});\nMCIndexNoder.SegmentOverlapAction = SegmentOverlapAction;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/noding/MCIndexNoder.js\n// module id = 72\n// module chunks = 0","import Boundable from './Boundable';\nimport extend from '../../../../../extend';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Serializable from '../../../../../java/io/Serializable';\nimport Assert from '../../util/Assert';\nexport default function AbstractNode() {\n\tthis._childBoundables = new ArrayList();\n\tthis._bounds = null;\n\tthis._level = null;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet level = arguments[0];\n\t\tthis._level = level;\n\t}\n}\nextend(AbstractNode.prototype, {\n\tgetLevel: function () {\n\t\treturn this._level;\n\t},\n\tsize: function () {\n\t\treturn this._childBoundables.size();\n\t},\n\tgetChildBoundables: function () {\n\t\treturn this._childBoundables;\n\t},\n\taddChildBoundable: function (childBoundable) {\n\t\tAssert.isTrue(this._bounds === null);\n\t\tthis._childBoundables.add(childBoundable);\n\t},\n\tisEmpty: function () {\n\t\treturn this._childBoundables.isEmpty();\n\t},\n\tgetBounds: function () {\n\t\tif (this._bounds === null) {\n\t\t\tthis._bounds = this.computeBounds();\n\t\t}\n\t\treturn this._bounds;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Boundable, Serializable];\n\t},\n\tgetClass: function () {\n\t\treturn AbstractNode;\n\t}\n});\nAbstractNode.serialVersionUID = 6493722185909573708;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/index/strtree/AbstractNode.js\n// module id = 73\n// module chunks = 0","import extend from '../../../../extend';\nexport default function Noder() {}\nextend(Noder.prototype, {\n\tcomputeNodes: function (segStrings) {},\n\tgetNodedSubstrings: function () {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Noder;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/noding/Noder.js\n// module id = 74\n// module chunks = 0","import extend from '../../../../extend';\nexport default function SegmentIntersector() {}\nextend(SegmentIntersector.prototype, {\n\tprocessIntersections: function (e0, segIndex0, e1, segIndex1) {},\n\tisDone: function () {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn SegmentIntersector;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/noding/SegmentIntersector.js\n// module id = 75\n// module chunks = 0","import EdgeIntersectionList from './EdgeIntersectionList';\nimport IntersectionMatrix from '../geom/IntersectionMatrix';\nimport MonotoneChainEdge from './index/MonotoneChainEdge';\nimport Position from './Position';\nimport Coordinate from '../geom/Coordinate';\nimport extend from '../../../../extend';\nimport Label from './Label';\nimport Envelope from '../geom/Envelope';\nimport inherits from '../../../../inherits';\nimport StringBuilder from '../../../../java/lang/StringBuilder';\nimport Depth from './Depth';\nimport GraphComponent from './GraphComponent';\nexport default function Edge() {\n\tGraphComponent.apply(this);\n\tthis.pts = null;\n\tthis._env = null;\n\tthis.eiList = new EdgeIntersectionList(this);\n\tthis._name = null;\n\tthis._mce = null;\n\tthis._isIsolated = true;\n\tthis._depth = new Depth();\n\tthis._depthDelta = 0;\n\tif (arguments.length === 1) {\n\t\tlet pts = arguments[0];\n\t\tEdge.call(this, pts, null);\n\t} else if (arguments.length === 2) {\n\t\tlet pts = arguments[0], label = arguments[1];\n\t\tthis.pts = pts;\n\t\tthis._label = label;\n\t}\n}\ninherits(Edge, GraphComponent);\nextend(Edge.prototype, {\n\tgetDepth: function () {\n\t\treturn this._depth;\n\t},\n\tgetCollapsedEdge: function () {\n\t\tvar newPts = new Array(2).fill(null);\n\t\tnewPts[0] = this.pts[0];\n\t\tnewPts[1] = this.pts[1];\n\t\tvar newe = new Edge(newPts, Label.toLineLabel(this._label));\n\t\treturn newe;\n\t},\n\tisIsolated: function () {\n\t\treturn this._isIsolated;\n\t},\n\tgetCoordinates: function () {\n\t\treturn this.pts;\n\t},\n\tsetIsolated: function (isIsolated) {\n\t\tthis._isIsolated = isIsolated;\n\t},\n\tsetName: function (name) {\n\t\tthis._name = name;\n\t},\n\tequals: function (o) {\n\t\tif (!(o instanceof Edge)) return false;\n\t\tvar e = o;\n\t\tif (this.pts.length !== e.pts.length) return false;\n\t\tvar isEqualForward = true;\n\t\tvar isEqualReverse = true;\n\t\tvar iRev = this.pts.length;\n\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\tif (!this.pts[i].equals2D(e.pts[i])) {\n\t\t\t\tisEqualForward = false;\n\t\t\t}\n\t\t\tif (!this.pts[i].equals2D(e.pts[-- iRev])) {\n\t\t\t\tisEqualReverse = false;\n\t\t\t}\n\t\t\tif (!isEqualForward && !isEqualReverse) return false;\n\t\t}\n\t\treturn true;\n\t},\n\tgetCoordinate: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tif (this.pts.length > 0) return this.pts[0];\n\t\t\treturn null;\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet i = arguments[0];\n\t\t\treturn this.pts[i];\n\t\t}\n\t},\n\tprint: function (out) {\n\t\tout.print(\"edge \" + this._name + \": \");\n\t\tout.print(\"LINESTRING (\");\n\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\tif (i > 0) out.print(\",\");\n\t\t\tout.print(this.pts[i].x + \" \" + this.pts[i].y);\n\t\t}\n\t\tout.print(\")  \" + this._label + \" \" + this._depthDelta);\n\t},\n\tcomputeIM: function (im) {\n\t\tEdge.updateIM(this._label, im);\n\t},\n\tisCollapsed: function () {\n\t\tif (!this._label.isArea()) return false;\n\t\tif (this.pts.length !== 3) return false;\n\t\tif (this.pts[0].equals(this.pts[2])) return true;\n\t\treturn false;\n\t},\n\tisClosed: function () {\n\t\treturn this.pts[0].equals(this.pts[this.pts.length - 1]);\n\t},\n\tgetMaximumSegmentIndex: function () {\n\t\treturn this.pts.length - 1;\n\t},\n\tgetDepthDelta: function () {\n\t\treturn this._depthDelta;\n\t},\n\tgetNumPoints: function () {\n\t\treturn this.pts.length;\n\t},\n\tprintReverse: function (out) {\n\t\tout.print(\"edge \" + this._name + \": \");\n\t\tfor (var i = this.pts.length - 1; i >= 0; i--) {\n\t\t\tout.print(this.pts[i] + \" \");\n\t\t}\n\t\tout.println(\"\");\n\t},\n\tgetMonotoneChainEdge: function () {\n\t\tif (this._mce === null) this._mce = new MonotoneChainEdge(this);\n\t\treturn this._mce;\n\t},\n\tgetEnvelope: function () {\n\t\tif (this._env === null) {\n\t\t\tthis._env = new Envelope();\n\t\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\t\tthis._env.expandToInclude(this.pts[i]);\n\t\t\t}\n\t\t}\n\t\treturn this._env;\n\t},\n\taddIntersection: function (li, segmentIndex, geomIndex, intIndex) {\n\t\tvar intPt = new Coordinate(li.getIntersection(intIndex));\n\t\tvar normalizedSegmentIndex = segmentIndex;\n\t\tvar dist = li.getEdgeDistance(geomIndex, intIndex);\n\t\tvar nextSegIndex = normalizedSegmentIndex + 1;\n\t\tif (nextSegIndex < this.pts.length) {\n\t\t\tvar nextPt = this.pts[nextSegIndex];\n\t\t\tif (intPt.equals2D(nextPt)) {\n\t\t\t\tnormalizedSegmentIndex = nextSegIndex;\n\t\t\t\tdist = 0.0;\n\t\t\t}\n\t\t}\n\t\tvar ei = this.eiList.add(intPt, normalizedSegmentIndex, dist);\n\t},\n\ttoString: function () {\n\t\tvar builder = new StringBuilder();\n\t\tbuilder.append(\"edge \" + this._name + \": \");\n\t\tbuilder.append(\"LINESTRING (\");\n\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\tif (i > 0) builder.append(\",\");\n\t\t\tbuilder.append(this.pts[i].x + \" \" + this.pts[i].y);\n\t\t}\n\t\tbuilder.append(\")  \" + this._label + \" \" + this._depthDelta);\n\t\treturn builder.toString();\n\t},\n\tisPointwiseEqual: function (e) {\n\t\tif (this.pts.length !== e.pts.length) return false;\n\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\tif (!this.pts[i].equals2D(e.pts[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\tsetDepthDelta: function (depthDelta) {\n\t\tthis._depthDelta = depthDelta;\n\t},\n\tgetEdgeIntersectionList: function () {\n\t\treturn this.eiList;\n\t},\n\taddIntersections: function (li, segmentIndex, geomIndex) {\n\t\tfor (var i = 0; i < li.getIntersectionNum(); i++) {\n\t\t\tthis.addIntersection(li, segmentIndex, geomIndex, i);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Edge;\n\t}\n});\nEdge.updateIM = function () {\n\tif (arguments.length === 2 && (arguments[1] instanceof IntersectionMatrix && arguments[0] instanceof Label)) {\n\t\tlet label = arguments[0], im = arguments[1];\n\t\tim.setAtLeastIfValid(label.getLocation(0, Position.ON), label.getLocation(1, Position.ON), 1);\n\t\tif (label.isArea()) {\n\t\t\tim.setAtLeastIfValid(label.getLocation(0, Position.LEFT), label.getLocation(1, Position.LEFT), 2);\n\t\t\tim.setAtLeastIfValid(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), 2);\n\t\t}\n\t} else return GraphComponent.prototype.updateIM.apply(this, arguments);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geomgraph/Edge.js\n// module id = 76\n// module chunks = 0","import WKTWriter from '../../io/WKTWriter';\nimport Coordinate from '../../geom/Coordinate';\nimport Double from '../../../../../java/lang/Double';\nimport extend from '../../../../../extend';\nimport Comparator from '../../../../../java/util/Comparator';\nexport default function IntervalRTreeNode() {\n\tthis._min = Double.POSITIVE_INFINITY;\n\tthis._max = Double.NEGATIVE_INFINITY;\n}\nextend(IntervalRTreeNode.prototype, {\n\tgetMin: function () {\n\t\treturn this._min;\n\t},\n\tintersects: function (queryMin, queryMax) {\n\t\tif (this._min > queryMax || this._max < queryMin) return false;\n\t\treturn true;\n\t},\n\tgetMax: function () {\n\t\treturn this._max;\n\t},\n\ttoString: function () {\n\t\treturn WKTWriter.toLineString(new Coordinate(this._min, 0), new Coordinate(this._max, 0));\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn IntervalRTreeNode;\n\t}\n});\nfunction NodeComparator() {}\nextend(NodeComparator.prototype, {\n\tcompare: function (o1, o2) {\n\t\tvar n1 = o1;\n\t\tvar n2 = o2;\n\t\tvar mid1 = (n1._min + n1._max) / 2;\n\t\tvar mid2 = (n2._min + n2._max) / 2;\n\t\tif (mid1 < mid2) return -1;\n\t\tif (mid1 > mid2) return 1;\n\t\treturn 0;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparator];\n\t},\n\tgetClass: function () {\n\t\treturn NodeComparator;\n\t}\n});\nIntervalRTreeNode.NodeComparator = NodeComparator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/index/intervalrtree/IntervalRTreeNode.js\n// module id = 77\n// module chunks = 0","import Control from './control';\nimport Util from '../helper/util';\nimport delSVG from '../../img/buffer.svg';\n\n/**\n * Control for deleting geometries.\n * @extends {ole.Control}\n * @alias ole.TopologyControl\n */\nclass TopologyControl extends Control {\n  /**\n   * @inheritdoc\n   * @param {Object} [options] Control options.\n   * @param {number} [options.hitTolerance] Select tolerance in pixels\n   *   (default is 10)\n   */\n  constructor(options) {\n    super(Object.assign({\n      title: 'TopoloyOp',\n      className: 'ole-control-topology',\n      image: delSVG,\n    }, options));\n\n    /**\n     * @type {ol.interaction.Select}\n     * @private\n     */\n    this.selectInteraction = new ol.interaction.Select({\n      toggleCondition: () => true,\n      hitTolerance: options.hitTolerance || 10,\n      source: this.source,\n      multi: true,\n    });\n\n    this.selectInteraction.on('select', () => {\n      const feats = this.selectInteraction.getFeatures();\n\n      try {\n        this.applyTopologyOperation(feats.getArray());\n      } catch (ex) {\n        Util.logError('Unable to process features.');\n        feats.clear();\n      }\n    });\n  }\n\n  /**\n   * Apply a topology operation for given features.\n   * @param {Array.<ol.Feature>} features Features.\n   */\n  applyTopologyOperation(features) {\n    this.topologyFeatures = features;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  activate() {\n    this.map.addInteraction(this.selectInteraction);\n    this.addedFeatures = [];\n    super.activate();\n  }\n\n  /**\n   * @inheritdoc\n   */\n  deactivate() {\n    this.addedFeatures = [];\n    this.map.removeInteraction(this.selectInteraction);\n    super.deactivate();\n  }\n}\n\nexport default TopologyControl;\n\n\n\n// WEBPACK FOOTER //\n// ./src/control/topology.js","export default function Long(high, low) {\n  this.low = low | 0\n  this.high = high | 0\n}\n\nLong.toBinaryString = function (i) {\n  var result = ''\n  for (var mask = 0x80000000; mask > 0; mask >>>= 1)\n    result += (i.high & mask) === mask ? '1' : '0'\n  for (var mask = 0x80000000; mask > 0; mask >>>= 1)\n    result += (i.low & mask) === mask ? '1' : '0'\n  return result\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/lang/Long.js\n// module id = 79\n// module chunks = 0","import hasInterface from '../../../../hasInterface';\nimport extend from '../../../../extend';\nimport CoordinateSequence from './CoordinateSequence';\nexport default function CoordinateSequenceFactory() {}\nextend(CoordinateSequenceFactory.prototype, {\n\tcreate: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordSeq = arguments[0];\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet size = arguments[0], dimension = arguments[1];\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn CoordinateSequenceFactory;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/CoordinateSequenceFactory.js\n// module id = 80\n// module chunks = 0","import LineString from '../geom/LineString';\nimport BoundaryNodeRule from '../algorithm/BoundaryNodeRule';\nimport extend from '../../../../extend';\nimport CoordinateArrays from '../geom/CoordinateArrays';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport TreeMap from '../../../../java/util/TreeMap';\nimport MultiLineString from '../geom/MultiLineString';\nexport default function BoundaryOp() {\n\tthis._geom = null;\n\tthis._geomFact = null;\n\tthis._bnRule = null;\n\tthis._endpointMap = null;\n\tif (arguments.length === 1) {\n\t\tlet geom = arguments[0];\n\t\tBoundaryOp.call(this, geom, BoundaryNodeRule.MOD2_BOUNDARY_RULE);\n\t} else if (arguments.length === 2) {\n\t\tlet geom = arguments[0], bnRule = arguments[1];\n\t\tthis._geom = geom;\n\t\tthis._geomFact = geom.getFactory();\n\t\tthis._bnRule = bnRule;\n\t}\n}\nextend(BoundaryOp.prototype, {\n\tboundaryMultiLineString: function (mLine) {\n\t\tif (this._geom.isEmpty()) {\n\t\t\treturn this.getEmptyMultiPoint();\n\t\t}\n\t\tvar bdyPts = this.computeBoundaryCoordinates(mLine);\n\t\tif (bdyPts.length === 1) {\n\t\t\treturn this._geomFact.createPoint(bdyPts[0]);\n\t\t}\n\t\treturn this._geomFact.createMultiPointFromCoords(bdyPts);\n\t},\n\tgetBoundary: function () {\n\t\tif (this._geom instanceof LineString) return this.boundaryLineString(this._geom);\n\t\tif (this._geom instanceof MultiLineString) return this.boundaryMultiLineString(this._geom);\n\t\treturn this._geom.getBoundary();\n\t},\n\tboundaryLineString: function (line) {\n\t\tif (this._geom.isEmpty()) {\n\t\t\treturn this.getEmptyMultiPoint();\n\t\t}\n\t\tif (line.isClosed()) {\n\t\t\tvar closedEndpointOnBoundary = this._bnRule.isInBoundary(2);\n\t\t\tif (closedEndpointOnBoundary) {\n\t\t\t\treturn line.getStartPoint();\n\t\t\t} else {\n\t\t\t\treturn this._geomFact.createMultiPoint();\n\t\t\t}\n\t\t}\n\t\treturn this._geomFact.createMultiPoint([line.getStartPoint(), line.getEndPoint()]);\n\t},\n\tgetEmptyMultiPoint: function () {\n\t\treturn this._geomFact.createMultiPoint();\n\t},\n\tcomputeBoundaryCoordinates: function (mLine) {\n\t\tvar bdyPts = new ArrayList();\n\t\tthis._endpointMap = new TreeMap();\n\t\tfor (var i = 0; i < mLine.getNumGeometries(); i++) {\n\t\t\tvar line = mLine.getGeometryN(i);\n\t\t\tif (line.getNumPoints() === 0) continue;\n\t\t\tthis.addEndpoint(line.getCoordinateN(0));\n\t\t\tthis.addEndpoint(line.getCoordinateN(line.getNumPoints() - 1));\n\t\t}\n\t\tfor (var it = this._endpointMap.entrySet().iterator(); it.hasNext(); ) {\n\t\t\tvar entry = it.next();\n\t\t\tvar counter = entry.getValue();\n\t\t\tvar valence = counter.count;\n\t\t\tif (this._bnRule.isInBoundary(valence)) {\n\t\t\t\tbdyPts.add(entry.getKey());\n\t\t\t}\n\t\t}\n\t\treturn CoordinateArrays.toCoordinateArray(bdyPts);\n\t},\n\taddEndpoint: function (pt) {\n\t\tvar counter = this._endpointMap.get(pt);\n\t\tif (counter === null) {\n\t\t\tcounter = new Counter();\n\t\t\tthis._endpointMap.put(pt, counter);\n\t\t}\n\t\tcounter.count++;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn BoundaryOp;\n\t}\n});\nBoundaryOp.getBoundary = function () {\n\tif (arguments.length === 1) {\n\t\tlet g = arguments[0];\n\t\tvar bop = new BoundaryOp(g);\n\t\treturn bop.getBoundary();\n\t} else if (arguments.length === 2) {\n\t\tlet g = arguments[0], bnRule = arguments[1];\n\t\tvar bop = new BoundaryOp(g, bnRule);\n\t\treturn bop.getBoundary();\n\t}\n};\nfunction Counter() {\n\tthis.count = null;\n}\nextend(Counter.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Counter;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/operation/BoundaryOp.js\n// module id = 81\n// module chunks = 0","/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Map.html\n *\n * @constructor\n * @private\n */\nexport default function Map() {};\n\n\n/**\n * Returns the value to which the specified key is mapped, or null if this map\n * contains no mapping for the key.\n * @param {Object} key\n * @return {Object}\n */\nMap.prototype.get = function() {};\n\n\n/**\n * Associates the specified value with the specified key in this map (optional\n * operation).\n * @param {Object} key\n * @param {Object} value\n * @return {Object}\n */\nMap.prototype.put = function() {};\n\n\n/**\n * Returns the number of key-value mappings in this map.\n * @return {number}\n */\nMap.prototype.size = function() {};\n\n\n/**\n * Returns a Collection view of the values contained in this map.\n * @return {javascript.util.Collection}\n */\nMap.prototype.values = function() {};\n\n/**\n * Returns a {@link Set} view of the mappings contained in this map.\n * The set is backed by the map, so changes to the map are\n * reflected in the set, and vice-versa.  If the map is modified\n * while an iteration over the set is in progress (except through\n * the iterator's own <tt>remove</tt> operation, or through the\n * <tt>setValue</tt> operation on a map entry returned by the\n * iterator) the results of the iteration are undefined.  The set\n * supports element removal, which removes the corresponding\n * mapping from the map, via the <tt>Iterator.remove</tt>,\n * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and\n * <tt>clear</tt> operations.  It does not support the\n * <tt>add</tt> or <tt>addAll</tt> operations.\n *\n * @return {Set} a set view of the mappings contained in this map\n */\nMap.prototype.entrySet = function() {};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/util/Map.js\n// module id = 82\n// module chunks = 0","import Collection from './Collection'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Set.html\n *\n * @extends {Collection}\n * @constructor\n * @private\n */\nexport default function Set() {};\nSet.prototype = new Collection();\n\n\n/**\n * Returns true if this set contains the specified element. More formally,\n * returns true if and only if this set contains an element e such that (o==null ?\n * e==null : o.equals(e)).\n * @param {Object} e\n * @return {boolean}\n */\nSet.prototype.contains = function() {};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/util/Set.js\n// module id = 83\n// module chunks = 0","import extend from '../../../../extend';\nexport default function Lineal() {}\nextend(Lineal.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Lineal;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/Lineal.js\n// module id = 84\n// module chunks = 0","import Collection from './Collection'\nimport Iterator from './Iterator'\nimport NoSuchElementException from './NoSuchElementException'\nimport OperationNotSupported from './OperationNotSupported'\nimport SortedSet from './SortedSet'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeSet.html\n *\n * @extends {SortedSet}\n * @constructor\n * @private\n */\nexport default function TreeSet() {\n  /**\n   * @type {Array}\n   * @private\n  */\n  this.array_ = [];\n\n  if (arguments[0] instanceof Collection) {\n    this.addAll(arguments[0]);\n  }\n};\nTreeSet.prototype = new SortedSet();\n\n\n/**\n * @override\n */\nTreeSet.prototype.contains = function(o) {\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    var e = this.array_[i];\n    if (e['compareTo'](o) === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.add = function(o) {\n  if (this.contains(o)) {\n    return false;\n  }\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    var e = this.array_[i];\n    if (e['compareTo'](o) === 1) {\n      this.array_.splice(i, 0, o);\n      return true;\n    }\n  }\n\n  this.array_.push(o);\n\n  return true;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.addAll = function(c) {\n  for (var i = c.iterator(); i.hasNext();) {\n    this.add(i.next());\n  }\n  return true;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.remove = function(e) {\n  throw new OperationNotSupported();\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.size = function() {\n  return this.array_.length;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.isEmpty = function() {\n  return this.array_.length === 0;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.toArray = function() {\n  var array = [];\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    array.push(this.array_[i]);\n  }\n\n  return array;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.iterator = function() {\n  return new Iterator_(this);\n};\n\n\n\n/**\n * @extends {javascript.util.Iterator}\n * @param {javascript.util.TreeSet} treeSet\n * @constructor\n * @private\n */\nvar Iterator_ = function(treeSet) {\n  /**\n   * @type {javascript.util.TreeSet}\n   * @private\n   */\n  this.treeSet_ = treeSet;\n  /**\n   * @type {number}\n   * @private\n   */\n  this.position_ = 0;\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.next = function() {\n  if (this.position_ === this.treeSet_.size()) {\n    throw new NoSuchElementException();\n  }\n  return this.treeSet_.array_[this.position_++];\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.hasNext = function() {\n  if (this.position_ < this.treeSet_.size()) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.remove = function() {\n  throw new OperationNotSupported();\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/util/TreeSet.js\n// module id = 85\n// module chunks = 0","export default function Character () {}\nCharacter.isWhitespace = c => ((c <= 32 && c >= 0) || c == 127)\nCharacter.toUpperCase = c => c.toUpperCase()\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/lang/Character.js\n// module id = 86\n// module chunks = 0","import extend from '../../../../extend';\nexport default function Puntal() {}\nextend(Puntal.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Puntal;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/Puntal.js\n// module id = 87\n// module chunks = 0","import Coordinate from '../geom/Coordinate';\nimport extend from '../../../../extend';\nimport DD from '../math/DD';\nexport default function CGAlgorithmsDD() {}\nextend(CGAlgorithmsDD.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn CGAlgorithmsDD;\n\t}\n});\nCGAlgorithmsDD.orientationIndex = function (p1, p2, q) {\n\tvar index = CGAlgorithmsDD.orientationIndexFilter(p1, p2, q);\n\tif (index <= 1) return index;\n\tvar dx1 = DD.valueOf(p2.x).selfAdd(-p1.x);\n\tvar dy1 = DD.valueOf(p2.y).selfAdd(-p1.y);\n\tvar dx2 = DD.valueOf(q.x).selfAdd(-p2.x);\n\tvar dy2 = DD.valueOf(q.y).selfAdd(-p2.y);\n\treturn dx1.selfMultiply(dy2).selfSubtract(dy1.selfMultiply(dx2)).signum();\n};\nCGAlgorithmsDD.signOfDet2x2 = function () {\n\tif (arguments[0] instanceof DD) {\n\t\tlet x1 = arguments[0], y1 = arguments[1], x2 = arguments[2], y2 = arguments[3];\n\t\tvar det = x1.multiply(y2).selfSubtract(y1.multiply(x2));\n\t\treturn det.signum();\n\t} else if (typeof arguments[0] === \"number\") {\n\t\tlet dx1 = arguments[0], dy1 = arguments[1], dx2 = arguments[2], dy2 = arguments[3];\n\t\tvar x1 = DD.valueOf(dx1);\n\t\tvar y1 = DD.valueOf(dy1);\n\t\tvar x2 = DD.valueOf(dx2);\n\t\tvar y2 = DD.valueOf(dy2);\n\t\tvar det = x1.multiply(y2).selfSubtract(y1.multiply(x2));\n\t\treturn det.signum();\n\t}\n};\nCGAlgorithmsDD.intersection = function (p1, p2, q1, q2) {\n\tvar denom1 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p2.x).selfSubtract(p1.x));\n\tvar denom2 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p2.y).selfSubtract(p1.y));\n\tvar denom = denom1.subtract(denom2);\n\tvar numx1 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));\n\tvar numx2 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));\n\tvar numx = numx1.subtract(numx2);\n\tvar fracP = numx.selfDivide(denom).doubleValue();\n\tvar x = DD.valueOf(p1.x).selfAdd(DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(fracP)).doubleValue();\n\tvar numy1 = DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));\n\tvar numy2 = DD.valueOf(p2.y).selfSubtract(p1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));\n\tvar numy = numy1.subtract(numy2);\n\tvar fracQ = numy.selfDivide(denom).doubleValue();\n\tvar y = DD.valueOf(q1.y).selfAdd(DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(fracQ)).doubleValue();\n\treturn new Coordinate(x, y);\n};\nCGAlgorithmsDD.orientationIndexFilter = function (pa, pb, pc) {\n\tvar detsum = null;\n\tvar detleft = (pa.x - pc.x) * (pb.y - pc.y);\n\tvar detright = (pa.y - pc.y) * (pb.x - pc.x);\n\tvar det = detleft - detright;\n\tif (detleft > 0.0) {\n\t\tif (detright <= 0.0) {\n\t\t\treturn CGAlgorithmsDD.signum(det);\n\t\t} else {\n\t\t\tdetsum = detleft + detright;\n\t\t}\n\t} else if (detleft < 0.0) {\n\t\tif (detright >= 0.0) {\n\t\t\treturn CGAlgorithmsDD.signum(det);\n\t\t} else {\n\t\t\tdetsum = -detleft - detright;\n\t\t}\n\t} else {\n\t\treturn CGAlgorithmsDD.signum(det);\n\t}\n\tvar errbound = CGAlgorithmsDD.DP_SAFE_EPSILON * detsum;\n\tif (det >= errbound || -det >= errbound) {\n\t\treturn CGAlgorithmsDD.signum(det);\n\t}\n\treturn 2;\n};\nCGAlgorithmsDD.signum = function (x) {\n\tif (x > 0) return 1;\n\tif (x < 0) return -1;\n\treturn 0;\n};\nCGAlgorithmsDD.DP_SAFE_EPSILON = 1e-15;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/algorithm/CGAlgorithmsDD.js\n// module id = 88\n// module chunks = 0","import ArrayList from './ArrayList'\nimport MapInterface from './Map'\nimport HashSet from './HashSet'\nimport MapPolyfill from '../../Map'\n\nlet MapImpl = typeof Map === 'undefined' || !Map.prototype.values ? MapPolyfill : Map\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/HashMap.html\n *\n * @extends {javascript.util.Map}\n * @constructor\n * @private\n */\nexport default function HashMap () {\n  /**\n   * @type {Object}\n   * @private\n  */\n  this.map_ = new MapImpl()\n}\nHashMap.prototype = new MapInterface()\n\n/**\n * @override\n */\nHashMap.prototype.get = function (key) {\n  return this.map_.get(key) || null\n}\n\n/**\n * @override\n */\nHashMap.prototype.put = function (key, value) {\n  this.map_.set(key, value)\n  return value\n}\n\n/**\n * @override\n */\nHashMap.prototype.values = function () {\n  const arrayList = new ArrayList()\n  const it = this.map_.values()\n  let o = it.next()\n  while (!o.done) {\n    arrayList.add(o.value)\n    o = it.next()\n  }\n  return arrayList\n}\n\n/**\n * @override\n */\nHashMap.prototype.entrySet = function () {\n  const hashSet = new HashSet()\n  this.map_.entries().forEach(entry => hashSet.add(entry))\n  return hashSet\n}\n\n/**\n * @override\n */\nHashMap.prototype.size = function () {\n  return this.map_.size()\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/util/HashMap.js\n// module id = 89\n// module chunks = 0","import PointLocation from '../../algorithm/PointLocation';\nimport TopologyException from '../../geom/TopologyException';\nimport extend from '../../../../../extend';\nimport MaximalEdgeRing from './MaximalEdgeRing';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Assert from '../../util/Assert';\nimport PlanarGraph from '../../geomgraph/PlanarGraph';\nexport default function PolygonBuilder() {\n\tthis._geometryFactory = null;\n\tthis._shellList = new ArrayList();\n\tlet geometryFactory = arguments[0];\n\tthis._geometryFactory = geometryFactory;\n}\nextend(PolygonBuilder.prototype, {\n\tsortShellsAndHoles: function (edgeRings, shellList, freeHoleList) {\n\t\tfor (var it = edgeRings.iterator(); it.hasNext(); ) {\n\t\t\tvar er = it.next();\n\t\t\tif (er.isHole()) {\n\t\t\t\tfreeHoleList.add(er);\n\t\t\t} else {\n\t\t\t\tshellList.add(er);\n\t\t\t}\n\t\t}\n\t},\n\tcomputePolygons: function (shellList) {\n\t\tvar resultPolyList = new ArrayList();\n\t\tfor (var it = shellList.iterator(); it.hasNext(); ) {\n\t\t\tvar er = it.next();\n\t\t\tvar poly = er.toPolygon(this._geometryFactory);\n\t\t\tresultPolyList.add(poly);\n\t\t}\n\t\treturn resultPolyList;\n\t},\n\tplaceFreeHoles: function (shellList, freeHoleList) {\n\t\tfor (var it = freeHoleList.iterator(); it.hasNext(); ) {\n\t\t\tvar hole = it.next();\n\t\t\tif (hole.getShell() === null) {\n\t\t\t\tvar shell = this.findEdgeRingContaining(hole, shellList);\n\t\t\t\tif (shell === null) throw new TopologyException(\"unable to assign hole to a shell\", hole.getCoordinate(0));\n\t\t\t\thole.setShell(shell);\n\t\t\t}\n\t\t}\n\t},\n\tbuildMinimalEdgeRings: function (maxEdgeRings, shellList, freeHoleList) {\n\t\tvar edgeRings = new ArrayList();\n\t\tfor (var it = maxEdgeRings.iterator(); it.hasNext(); ) {\n\t\t\tvar er = it.next();\n\t\t\tif (er.getMaxNodeDegree() > 2) {\n\t\t\t\ter.linkDirectedEdgesForMinimalEdgeRings();\n\t\t\t\tvar minEdgeRings = er.buildMinimalRings();\n\t\t\t\tvar shell = this.findShell(minEdgeRings);\n\t\t\t\tif (shell !== null) {\n\t\t\t\t\tthis.placePolygonHoles(shell, minEdgeRings);\n\t\t\t\t\tshellList.add(shell);\n\t\t\t\t} else {\n\t\t\t\t\tfreeHoleList.addAll(minEdgeRings);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tedgeRings.add(er);\n\t\t\t}\n\t\t}\n\t\treturn edgeRings;\n\t},\n\tcontainsPoint: function (p) {\n\t\tfor (var it = this._shellList.iterator(); it.hasNext(); ) {\n\t\t\tvar er = it.next();\n\t\t\tif (er.containsPoint(p)) return true;\n\t\t}\n\t\treturn false;\n\t},\n\tbuildMaximalEdgeRings: function (dirEdges) {\n\t\tvar maxEdgeRings = new ArrayList();\n\t\tfor (var it = dirEdges.iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tif (de.isInResult() && de.getLabel().isArea()) {\n\t\t\t\tif (de.getEdgeRing() === null) {\n\t\t\t\t\tvar er = new MaximalEdgeRing(de, this._geometryFactory);\n\t\t\t\t\tmaxEdgeRings.add(er);\n\t\t\t\t\ter.setInResult();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn maxEdgeRings;\n\t},\n\tplacePolygonHoles: function (shell, minEdgeRings) {\n\t\tfor (var it = minEdgeRings.iterator(); it.hasNext(); ) {\n\t\t\tvar er = it.next();\n\t\t\tif (er.isHole()) {\n\t\t\t\ter.setShell(shell);\n\t\t\t}\n\t\t}\n\t},\n\tgetPolygons: function () {\n\t\tvar resultPolyList = this.computePolygons(this._shellList);\n\t\treturn resultPolyList;\n\t},\n\tfindEdgeRingContaining: function (testEr, shellList) {\n\t\tvar testRing = testEr.getLinearRing();\n\t\tvar testEnv = testRing.getEnvelopeInternal();\n\t\tvar testPt = testRing.getCoordinateN(0);\n\t\tvar minShell = null;\n\t\tvar minEnv = null;\n\t\tfor (var it = shellList.iterator(); it.hasNext(); ) {\n\t\t\tvar tryShell = it.next();\n\t\t\tvar tryRing = tryShell.getLinearRing();\n\t\t\tvar tryEnv = tryRing.getEnvelopeInternal();\n\t\t\tif (minShell !== null) minEnv = minShell.getLinearRing().getEnvelopeInternal();\n\t\t\tvar isContained = false;\n\t\t\tif (tryEnv.contains(testEnv) && PointLocation.isInRing(testPt, tryRing.getCoordinates())) isContained = true;\n\t\t\tif (isContained) {\n\t\t\t\tif (minShell === null || minEnv.contains(tryEnv)) {\n\t\t\t\t\tminShell = tryShell;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn minShell;\n\t},\n\tfindShell: function (minEdgeRings) {\n\t\tvar shellCount = 0;\n\t\tvar shell = null;\n\t\tfor (var it = minEdgeRings.iterator(); it.hasNext(); ) {\n\t\t\tvar er = it.next();\n\t\t\tif (!er.isHole()) {\n\t\t\t\tshell = er;\n\t\t\t\tshellCount++;\n\t\t\t}\n\t\t}\n\t\tAssert.isTrue(shellCount <= 1, \"found two shells in MinimalEdgeRing list\");\n\t\treturn shell;\n\t},\n\tadd: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet graph = arguments[0];\n\t\t\tthis.add(graph.getEdgeEnds(), graph.getNodes());\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet dirEdges = arguments[0], nodes = arguments[1];\n\t\t\tPlanarGraph.linkResultDirectedEdges(nodes);\n\t\t\tvar maxEdgeRings = this.buildMaximalEdgeRings(dirEdges);\n\t\t\tvar freeHoleList = new ArrayList();\n\t\t\tvar edgeRings = this.buildMinimalEdgeRings(maxEdgeRings, this._shellList, freeHoleList);\n\t\t\tthis.sortShellsAndHoles(edgeRings, this._shellList, freeHoleList);\n\t\t\tthis.placeFreeHoles(this._shellList, freeHoleList);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn PolygonBuilder;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/operation/overlay/PolygonBuilder.js\n// module id = 90\n// module chunks = 0","export default function Exception () {}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/lang/Exception.js\n// module id = 91\n// module chunks = 0","import Location from '../geom/Location';\nimport hasInterface from '../../../../hasInterface';\nimport Coordinate from '../geom/Coordinate';\nimport extend from '../../../../extend';\nimport Orientation from './Orientation';\nimport CoordinateSequence from '../geom/CoordinateSequence';\nexport default function RayCrossingCounter() {\n\tthis._p = null;\n\tthis._crossingCount = 0;\n\tthis._isPointOnSegment = false;\n\tlet p = arguments[0];\n\tthis._p = p;\n}\nextend(RayCrossingCounter.prototype, {\n\tcountSegment: function (p1, p2) {\n\t\tif (p1.x < this._p.x && p2.x < this._p.x) return null;\n\t\tif (this._p.x === p2.x && this._p.y === p2.y) {\n\t\t\tthis._isPointOnSegment = true;\n\t\t\treturn null;\n\t\t}\n\t\tif (p1.y === this._p.y && p2.y === this._p.y) {\n\t\t\tvar minx = p1.x;\n\t\t\tvar maxx = p2.x;\n\t\t\tif (minx > maxx) {\n\t\t\t\tminx = p2.x;\n\t\t\t\tmaxx = p1.x;\n\t\t\t}\n\t\t\tif (this._p.x >= minx && this._p.x <= maxx) {\n\t\t\t\tthis._isPointOnSegment = true;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tif (p1.y > this._p.y && p2.y <= this._p.y || p2.y > this._p.y && p1.y <= this._p.y) {\n\t\t\tvar orient = Orientation.index(p1, p2, this._p);\n\t\t\tif (orient === Orientation.COLLINEAR) {\n\t\t\t\tthis._isPointOnSegment = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (p2.y < p1.y) {\n\t\t\t\torient = -orient;\n\t\t\t}\n\t\t\tif (orient === Orientation.LEFT) {\n\t\t\t\tthis._crossingCount++;\n\t\t\t}\n\t\t}\n\t},\n\tisPointInPolygon: function () {\n\t\treturn this.getLocation() !== Location.EXTERIOR;\n\t},\n\tgetLocation: function () {\n\t\tif (this._isPointOnSegment) return Location.BOUNDARY;\n\t\tif (this._crossingCount % 2 === 1) {\n\t\t\treturn Location.INTERIOR;\n\t\t}\n\t\treturn Location.EXTERIOR;\n\t},\n\tisOnSegment: function () {\n\t\treturn this._isPointOnSegment;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn RayCrossingCounter;\n\t}\n});\nRayCrossingCounter.locatePointInRing = function () {\n\tif (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {\n\t\tlet p = arguments[0], ring = arguments[1];\n\t\tvar counter = new RayCrossingCounter(p);\n\t\tvar p1 = new Coordinate();\n\t\tvar p2 = new Coordinate();\n\t\tfor (var i = 1; i < ring.size(); i++) {\n\t\t\tring.getCoordinate(i, p1);\n\t\t\tring.getCoordinate(i - 1, p2);\n\t\t\tcounter.countSegment(p1, p2);\n\t\t\tif (counter.isOnSegment()) return counter.getLocation();\n\t\t}\n\t\treturn counter.getLocation();\n\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {\n\t\tlet p = arguments[0], ring = arguments[1];\n\t\tvar counter = new RayCrossingCounter(p);\n\t\tfor (var i = 1; i < ring.length; i++) {\n\t\t\tvar p1 = ring[i];\n\t\t\tvar p2 = ring[i - 1];\n\t\t\tcounter.countSegment(p1, p2);\n\t\t\tif (counter.isOnSegment()) return counter.getLocation();\n\t\t}\n\t\treturn counter.getLocation();\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/algorithm/RayCrossingCounter.js\n// module id = 92\n// module chunks = 0","import Location from '../geom/Location';\nimport Position from './Position';\nimport PointLocation from '../algorithm/PointLocation';\nimport TopologyException from '../geom/TopologyException';\nimport extend from '../../../../extend';\nimport Orientation from '../algorithm/Orientation';\nimport Label from './Label';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport Assert from '../util/Assert';\nexport default function EdgeRing() {\n\tthis._startDe = null;\n\tthis._maxNodeDegree = -1;\n\tthis._edges = new ArrayList();\n\tthis._pts = new ArrayList();\n\tthis._label = new Label(Location.NONE);\n\tthis._ring = null;\n\tthis._isHole = null;\n\tthis._shell = null;\n\tthis._holes = new ArrayList();\n\tthis._geometryFactory = null;\n\tlet start = arguments[0], geometryFactory = arguments[1];\n\tthis._geometryFactory = geometryFactory;\n\tthis.computePoints(start);\n\tthis.computeRing();\n}\nextend(EdgeRing.prototype, {\n\tcomputeRing: function () {\n\t\tif (this._ring !== null) return null;\n\t\tvar coord = new Array(this._pts.size()).fill(null);\n\t\tfor (var i = 0; i < this._pts.size(); i++) {\n\t\t\tcoord[i] = this._pts.get(i);\n\t\t}\n\t\tthis._ring = this._geometryFactory.createLinearRing(coord);\n\t\tthis._isHole = Orientation.isCCW(this._ring.getCoordinates());\n\t},\n\tisIsolated: function () {\n\t\treturn this._label.getGeometryCount() === 1;\n\t},\n\tcomputePoints: function (start) {\n\t\tthis._startDe = start;\n\t\tvar de = start;\n\t\tvar isFirstEdge = true;\n\t\tdo {\n\t\t\tif (de === null) throw new TopologyException(\"Found null DirectedEdge\");\n\t\t\tif (de.getEdgeRing() === this) throw new TopologyException(\"Directed Edge visited twice during ring-building at \" + de.getCoordinate());\n\t\t\tthis._edges.add(de);\n\t\t\tvar label = de.getLabel();\n\t\t\tAssert.isTrue(label.isArea());\n\t\t\tthis.mergeLabel(label);\n\t\t\tthis.addPoints(de.getEdge(), de.isForward(), isFirstEdge);\n\t\t\tisFirstEdge = false;\n\t\t\tthis.setEdgeRing(de, this);\n\t\t\tde = this.getNext(de);\n\t\t} while (de !== this._startDe);\n\t},\n\tgetLinearRing: function () {\n\t\treturn this._ring;\n\t},\n\tgetCoordinate: function (i) {\n\t\treturn this._pts.get(i);\n\t},\n\tcomputeMaxNodeDegree: function () {\n\t\tthis._maxNodeDegree = 0;\n\t\tvar de = this._startDe;\n\t\tdo {\n\t\t\tvar node = de.getNode();\n\t\t\tvar degree = node.getEdges().getOutgoingDegree(this);\n\t\t\tif (degree > this._maxNodeDegree) this._maxNodeDegree = degree;\n\t\t\tde = this.getNext(de);\n\t\t} while (de !== this._startDe);\n\t\tthis._maxNodeDegree *= 2;\n\t},\n\taddPoints: function (edge, isForward, isFirstEdge) {\n\t\tvar edgePts = edge.getCoordinates();\n\t\tif (isForward) {\n\t\t\tvar startIndex = 1;\n\t\t\tif (isFirstEdge) startIndex = 0;\n\t\t\tfor (var i = startIndex; i < edgePts.length; i++) {\n\t\t\t\tthis._pts.add(edgePts[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tvar startIndex = edgePts.length - 2;\n\t\t\tif (isFirstEdge) startIndex = edgePts.length - 1;\n\t\t\tfor (var i = startIndex; i >= 0; i--) {\n\t\t\t\tthis._pts.add(edgePts[i]);\n\t\t\t}\n\t\t}\n\t},\n\tisHole: function () {\n\t\treturn this._isHole;\n\t},\n\tsetInResult: function () {\n\t\tvar de = this._startDe;\n\t\tdo {\n\t\t\tde.getEdge().setInResult(true);\n\t\t\tde = de.getNext();\n\t\t} while (de !== this._startDe);\n\t},\n\tcontainsPoint: function (p) {\n\t\tvar shell = this.getLinearRing();\n\t\tvar env = shell.getEnvelopeInternal();\n\t\tif (!env.contains(p)) return false;\n\t\tif (!PointLocation.isInRing(p, shell.getCoordinates())) return false;\n\t\tfor (var i = this._holes.iterator(); i.hasNext(); ) {\n\t\t\tvar hole = i.next();\n\t\t\tif (hole.containsPoint(p)) return false;\n\t\t}\n\t\treturn true;\n\t},\n\taddHole: function (ring) {\n\t\tthis._holes.add(ring);\n\t},\n\tisShell: function () {\n\t\treturn this._shell === null;\n\t},\n\tgetLabel: function () {\n\t\treturn this._label;\n\t},\n\tgetEdges: function () {\n\t\treturn this._edges;\n\t},\n\tgetMaxNodeDegree: function () {\n\t\tif (this._maxNodeDegree < 0) this.computeMaxNodeDegree();\n\t\treturn this._maxNodeDegree;\n\t},\n\tgetShell: function () {\n\t\treturn this._shell;\n\t},\n\tmergeLabel: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet deLabel = arguments[0];\n\t\t\tthis.mergeLabel(deLabel, 0);\n\t\t\tthis.mergeLabel(deLabel, 1);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet deLabel = arguments[0], geomIndex = arguments[1];\n\t\t\tvar loc = deLabel.getLocation(geomIndex, Position.RIGHT);\n\t\t\tif (loc === Location.NONE) return null;\n\t\t\tif (this._label.getLocation(geomIndex) === Location.NONE) {\n\t\t\t\tthis._label.setLocation(geomIndex, loc);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t},\n\tsetShell: function (shell) {\n\t\tthis._shell = shell;\n\t\tif (shell !== null) shell.addHole(this);\n\t},\n\ttoPolygon: function (geometryFactory) {\n\t\tvar holeLR = new Array(this._holes.size()).fill(null);\n\t\tfor (var i = 0; i < this._holes.size(); i++) {\n\t\t\tholeLR[i] = this._holes.get(i).getLinearRing();\n\t\t}\n\t\tvar poly = geometryFactory.createPolygon(this.getLinearRing(), holeLR);\n\t\treturn poly;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn EdgeRing;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeRing.js\n// module id = 93\n// module chunks = 0","import extend from '../../../../extend';\nimport Assert from '../util/Assert';\nexport default function GraphComponent() {\n\tthis._label = null;\n\tthis._isInResult = false;\n\tthis._isCovered = false;\n\tthis._isCoveredSet = false;\n\tthis._isVisited = false;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet label = arguments[0];\n\t\tthis._label = label;\n\t}\n}\nextend(GraphComponent.prototype, {\n\tsetVisited: function (isVisited) {\n\t\tthis._isVisited = isVisited;\n\t},\n\tsetInResult: function (isInResult) {\n\t\tthis._isInResult = isInResult;\n\t},\n\tisCovered: function () {\n\t\treturn this._isCovered;\n\t},\n\tisCoveredSet: function () {\n\t\treturn this._isCoveredSet;\n\t},\n\tsetLabel: function (label) {\n\t\tthis._label = label;\n\t},\n\tgetLabel: function () {\n\t\treturn this._label;\n\t},\n\tsetCovered: function (isCovered) {\n\t\tthis._isCovered = isCovered;\n\t\tthis._isCoveredSet = true;\n\t},\n\tupdateIM: function (im) {\n\t\tAssert.isTrue(this._label.getGeometryCount() >= 2, \"found partial label\");\n\t\tthis.computeIM(im);\n\t},\n\tisInResult: function () {\n\t\treturn this._isInResult;\n\t},\n\tisVisited: function () {\n\t\treturn this._isVisited;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn GraphComponent;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geomgraph/GraphComponent.js\n// module id = 94\n// module chunks = 0","import Location from '../geom/Location';\nimport EdgeEnd from './EdgeEnd';\nimport Position from './Position';\nimport TopologyException from '../geom/TopologyException';\nimport extend from '../../../../extend';\nimport Label from './Label';\nimport inherits from '../../../../inherits';\nexport default function DirectedEdge() {\n\tthis._isForward = null;\n\tthis._isInResult = false;\n\tthis._isVisited = false;\n\tthis._sym = null;\n\tthis._next = null;\n\tthis._nextMin = null;\n\tthis._edgeRing = null;\n\tthis._minEdgeRing = null;\n\tthis._depth = [0, -999, -999];\n\tlet edge = arguments[0], isForward = arguments[1];\n\tEdgeEnd.call(this, edge);\n\tthis._isForward = isForward;\n\tif (isForward) {\n\t\tthis.init(edge.getCoordinate(0), edge.getCoordinate(1));\n\t} else {\n\t\tvar n = edge.getNumPoints() - 1;\n\t\tthis.init(edge.getCoordinate(n), edge.getCoordinate(n - 1));\n\t}\n\tthis.computeDirectedLabel();\n}\ninherits(DirectedEdge, EdgeEnd);\nextend(DirectedEdge.prototype, {\n\tgetNextMin: function () {\n\t\treturn this._nextMin;\n\t},\n\tgetDepth: function (position) {\n\t\treturn this._depth[position];\n\t},\n\tsetVisited: function (isVisited) {\n\t\tthis._isVisited = isVisited;\n\t},\n\tcomputeDirectedLabel: function () {\n\t\tthis._label = new Label(this._edge.getLabel());\n\t\tif (!this._isForward) this._label.flip();\n\t},\n\tgetNext: function () {\n\t\treturn this._next;\n\t},\n\tsetDepth: function (position, depthVal) {\n\t\tif (this._depth[position] !== -999) {\n\t\t\tif (this._depth[position] !== depthVal) throw new TopologyException(\"assigned depths do not match\", this.getCoordinate());\n\t\t}\n\t\tthis._depth[position] = depthVal;\n\t},\n\tisInteriorAreaEdge: function () {\n\t\tvar isInteriorAreaEdge = true;\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (!(this._label.isArea(i) && this._label.getLocation(i, Position.LEFT) === Location.INTERIOR && this._label.getLocation(i, Position.RIGHT) === Location.INTERIOR)) {\n\t\t\t\tisInteriorAreaEdge = false;\n\t\t\t}\n\t\t}\n\t\treturn isInteriorAreaEdge;\n\t},\n\tsetNextMin: function (nextMin) {\n\t\tthis._nextMin = nextMin;\n\t},\n\tprint: function (out) {\n\t\tEdgeEnd.prototype.print.call(this, out);\n\t\tout.print(\" \" + this._depth[Position.LEFT] + \"/\" + this._depth[Position.RIGHT]);\n\t\tout.print(\" (\" + this.getDepthDelta() + \")\");\n\t\tif (this._isInResult) out.print(\" inResult\");\n\t},\n\tsetMinEdgeRing: function (minEdgeRing) {\n\t\tthis._minEdgeRing = minEdgeRing;\n\t},\n\tisLineEdge: function () {\n\t\tvar isLine = this._label.isLine(0) || this._label.isLine(1);\n\t\tvar isExteriorIfArea0 = !this._label.isArea(0) || this._label.allPositionsEqual(0, Location.EXTERIOR);\n\t\tvar isExteriorIfArea1 = !this._label.isArea(1) || this._label.allPositionsEqual(1, Location.EXTERIOR);\n\t\treturn isLine && isExteriorIfArea0 && isExteriorIfArea1;\n\t},\n\tsetEdgeRing: function (edgeRing) {\n\t\tthis._edgeRing = edgeRing;\n\t},\n\tgetMinEdgeRing: function () {\n\t\treturn this._minEdgeRing;\n\t},\n\tgetDepthDelta: function () {\n\t\tvar depthDelta = this._edge.getDepthDelta();\n\t\tif (!this._isForward) depthDelta = -depthDelta;\n\t\treturn depthDelta;\n\t},\n\tsetInResult: function (isInResult) {\n\t\tthis._isInResult = isInResult;\n\t},\n\tgetSym: function () {\n\t\treturn this._sym;\n\t},\n\tisForward: function () {\n\t\treturn this._isForward;\n\t},\n\tgetEdge: function () {\n\t\treturn this._edge;\n\t},\n\tprintEdge: function (out) {\n\t\tthis.print(out);\n\t\tout.print(\" \");\n\t\tif (this._isForward) this._edge.print(out); else this._edge.printReverse(out);\n\t},\n\tsetSym: function (de) {\n\t\tthis._sym = de;\n\t},\n\tsetVisitedEdge: function (isVisited) {\n\t\tthis.setVisited(isVisited);\n\t\tthis._sym.setVisited(isVisited);\n\t},\n\tsetEdgeDepths: function (position, depth) {\n\t\tvar depthDelta = this.getEdge().getDepthDelta();\n\t\tif (!this._isForward) depthDelta = -depthDelta;\n\t\tvar directionFactor = 1;\n\t\tif (position === Position.LEFT) directionFactor = -1;\n\t\tvar oppositePos = Position.opposite(position);\n\t\tvar delta = depthDelta * directionFactor;\n\t\tvar oppositeDepth = depth + delta;\n\t\tthis.setDepth(position, depth);\n\t\tthis.setDepth(oppositePos, oppositeDepth);\n\t},\n\tgetEdgeRing: function () {\n\t\treturn this._edgeRing;\n\t},\n\tisInResult: function () {\n\t\treturn this._isInResult;\n\t},\n\tsetNext: function (next) {\n\t\tthis._next = next;\n\t},\n\tisVisited: function () {\n\t\treturn this._isVisited;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn DirectedEdge;\n\t}\n});\nDirectedEdge.depthFactor = function (currLocation, nextLocation) {\n\tif (currLocation === Location.EXTERIOR && nextLocation === Location.INTERIOR) return 1; else if (currLocation === Location.INTERIOR && nextLocation === Location.EXTERIOR) return -1;\n\treturn 0;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geomgraph/DirectedEdge.js\n// module id = 95\n// module chunks = 0","import Node from './Node';\nimport extend from '../../../../extend';\nexport default function NodeFactory() {}\nextend(NodeFactory.prototype, {\n\tcreateNode: function (coord) {\n\t\treturn new Node(coord, null);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn NodeFactory;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geomgraph/NodeFactory.js\n// module id = 96\n// module chunks = 0","import Boundable from './Boundable';\nimport extend from '../../../../../extend';\nimport Serializable from '../../../../../java/io/Serializable';\nexport default function ItemBoundable() {\n\tthis._bounds = null;\n\tthis._item = null;\n\tlet bounds = arguments[0], item = arguments[1];\n\tthis._bounds = bounds;\n\tthis._item = item;\n}\nextend(ItemBoundable.prototype, {\n\tgetItem: function () {\n\t\treturn this._item;\n\t},\n\tgetBounds: function () {\n\t\treturn this._bounds;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Boundable, Serializable];\n\t},\n\tgetClass: function () {\n\t\treturn ItemBoundable;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/index/strtree/ItemBoundable.js\n// module id = 97\n// module chunks = 0","import extend from '../../../../../extend';\nexport default function Boundable() {}\nextend(Boundable.prototype, {\n\tgetBounds: function () {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Boundable;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/index/strtree/Boundable.js\n// module id = 98\n// module chunks = 0","import Coordinate from '../geom/Coordinate';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../extend';\nexport default function Octant() {}\nextend(Octant.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Octant;\n\t}\n});\nOctant.octant = function () {\n\tif (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n\t\tlet dx = arguments[0], dy = arguments[1];\n\t\tif (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException(\"Cannot compute the octant for point ( \" + dx + \", \" + dy + \" )\");\n\t\tvar adx = Math.abs(dx);\n\t\tvar ady = Math.abs(dy);\n\t\tif (dx >= 0) {\n\t\t\tif (dy >= 0) {\n\t\t\t\tif (adx >= ady) return 0; else return 1;\n\t\t\t} else {\n\t\t\t\tif (adx >= ady) return 7; else return 6;\n\t\t\t}\n\t\t} else {\n\t\t\tif (dy >= 0) {\n\t\t\t\tif (adx >= ady) return 3; else return 2;\n\t\t\t} else {\n\t\t\t\tif (adx >= ady) return 4; else return 5;\n\t\t\t}\n\t\t}\n\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n\t\tlet p0 = arguments[0], p1 = arguments[1];\n\t\tvar dx = p1.x - p0.x;\n\t\tvar dy = p1.y - p0.y;\n\t\tif (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException(\"Cannot compute the octant for two identical points \" + p0);\n\t\treturn Octant.octant(dx, dy);\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/noding/Octant.js\n// module id = 99\n// module chunks = 0","import extend from '../../../../extend';\nexport default function SegmentString() {}\nextend(SegmentString.prototype, {\n\tgetCoordinates: function () {},\n\tsize: function () {},\n\tgetCoordinate: function (i) {},\n\tisClosed: function () {},\n\tsetData: function (data) {},\n\tgetData: function () {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn SegmentString;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/noding/SegmentString.js\n// module id = 100\n// module chunks = 0","import extend from '../../../../../extend';\nimport Envelope from '../../geom/Envelope';\nexport default function MonotoneChain() {\n\tthis._pts = null;\n\tthis._start = null;\n\tthis._end = null;\n\tthis._env = null;\n\tthis._context = null;\n\tthis._id = null;\n\tlet pts = arguments[0], start = arguments[1], end = arguments[2], context = arguments[3];\n\tthis._pts = pts;\n\tthis._start = start;\n\tthis._end = end;\n\tthis._context = context;\n}\nextend(MonotoneChain.prototype, {\n\tgetLineSegment: function (index, ls) {\n\t\tls.p0 = this._pts[index];\n\t\tls.p1 = this._pts[index + 1];\n\t},\n\tcomputeSelect: function (searchEnv, start0, end0, mcs) {\n\t\tvar p0 = this._pts[start0];\n\t\tvar p1 = this._pts[end0];\n\t\tif (end0 - start0 === 1) {\n\t\t\tmcs.select(this, start0);\n\t\t\treturn null;\n\t\t}\n\t\tif (!searchEnv.intersects(p0, p1)) return null;\n\t\tvar mid = Math.trunc((start0 + end0) / 2);\n\t\tif (start0 < mid) {\n\t\t\tthis.computeSelect(searchEnv, start0, mid, mcs);\n\t\t}\n\t\tif (mid < end0) {\n\t\t\tthis.computeSelect(searchEnv, mid, end0, mcs);\n\t\t}\n\t},\n\tgetCoordinates: function () {\n\t\tvar coord = new Array(this._end - this._start + 1).fill(null);\n\t\tvar index = 0;\n\t\tfor (var i = this._start; i <= this._end; i++) {\n\t\t\tcoord[index++] = this._pts[i];\n\t\t}\n\t\treturn coord;\n\t},\n\tcomputeOverlaps: function () {\n\t\tif (arguments.length === 2) {\n\t\t\tlet mc = arguments[0], mco = arguments[1];\n\t\t\tthis.computeOverlaps(this._start, this._end, mc, mc._start, mc._end, mco);\n\t\t} else if (arguments.length === 6) {\n\t\t\tlet start0 = arguments[0], end0 = arguments[1], mc = arguments[2], start1 = arguments[3], end1 = arguments[4], mco = arguments[5];\n\t\t\tif (end0 - start0 === 1 && end1 - start1 === 1) {\n\t\t\t\tmco.overlap(this, start0, mc, start1);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (!this.overlaps(start0, end0, mc, start1, end1)) return null;\n\t\t\tvar mid0 = Math.trunc((start0 + end0) / 2);\n\t\t\tvar mid1 = Math.trunc((start1 + end1) / 2);\n\t\t\tif (start0 < mid0) {\n\t\t\t\tif (start1 < mid1) this.computeOverlaps(start0, mid0, mc, start1, mid1, mco);\n\t\t\t\tif (mid1 < end1) this.computeOverlaps(start0, mid0, mc, mid1, end1, mco);\n\t\t\t}\n\t\t\tif (mid0 < end0) {\n\t\t\t\tif (start1 < mid1) this.computeOverlaps(mid0, end0, mc, start1, mid1, mco);\n\t\t\t\tif (mid1 < end1) this.computeOverlaps(mid0, end0, mc, mid1, end1, mco);\n\t\t\t}\n\t\t}\n\t},\n\tsetId: function (id) {\n\t\tthis._id = id;\n\t},\n\tselect: function (searchEnv, mcs) {\n\t\tthis.computeSelect(searchEnv, this._start, this._end, mcs);\n\t},\n\tgetEnvelope: function () {\n\t\tif (this._env === null) {\n\t\t\tvar p0 = this._pts[this._start];\n\t\t\tvar p1 = this._pts[this._end];\n\t\t\tthis._env = new Envelope(p0, p1);\n\t\t}\n\t\treturn this._env;\n\t},\n\toverlaps: function (start0, end0, mc, start1, end1) {\n\t\treturn Envelope.intersects(this._pts[start0], this._pts[end0], mc._pts[start1], mc._pts[end1]);\n\t},\n\tgetEndIndex: function () {\n\t\treturn this._end;\n\t},\n\tgetStartIndex: function () {\n\t\treturn this._start;\n\t},\n\tgetContext: function () {\n\t\treturn this._context;\n\t},\n\tgetId: function () {\n\t\treturn this._id;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn MonotoneChain;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/index/chain/MonotoneChain.js\n// module id = 101\n// module chunks = 0","import extend from '../../../../extend';\nimport Orientation from './Orientation';\nexport default function Angle() {}\nextend(Angle.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Angle;\n\t}\n});\nAngle.toDegrees = function (radians) {\n\treturn radians * 180 / Math.PI;\n};\nAngle.normalize = function (angle) {\n\twhile (angle > Math.PI) angle -= Angle.PI_TIMES_2;\n\twhile (angle <= -Math.PI) angle += Angle.PI_TIMES_2;\n\treturn angle;\n};\nAngle.angle = function () {\n\tif (arguments.length === 1) {\n\t\tlet p = arguments[0];\n\t\treturn Math.atan2(p.y, p.x);\n\t} else if (arguments.length === 2) {\n\t\tlet p0 = arguments[0], p1 = arguments[1];\n\t\tvar dx = p1.x - p0.x;\n\t\tvar dy = p1.y - p0.y;\n\t\treturn Math.atan2(dy, dx);\n\t}\n};\nAngle.isAcute = function (p0, p1, p2) {\n\tvar dx0 = p0.x - p1.x;\n\tvar dy0 = p0.y - p1.y;\n\tvar dx1 = p2.x - p1.x;\n\tvar dy1 = p2.y - p1.y;\n\tvar dotprod = dx0 * dx1 + dy0 * dy1;\n\treturn dotprod > 0;\n};\nAngle.isObtuse = function (p0, p1, p2) {\n\tvar dx0 = p0.x - p1.x;\n\tvar dy0 = p0.y - p1.y;\n\tvar dx1 = p2.x - p1.x;\n\tvar dy1 = p2.y - p1.y;\n\tvar dotprod = dx0 * dx1 + dy0 * dy1;\n\treturn dotprod < 0;\n};\nAngle.interiorAngle = function (p0, p1, p2) {\n\tvar anglePrev = Angle.angle(p1, p0);\n\tvar angleNext = Angle.angle(p1, p2);\n\treturn Math.abs(angleNext - anglePrev);\n};\nAngle.normalizePositive = function (angle) {\n\tif (angle < 0.0) {\n\t\twhile (angle < 0.0) angle += Angle.PI_TIMES_2;\n\t\tif (angle >= Angle.PI_TIMES_2) angle = 0.0;\n\t} else {\n\t\twhile (angle >= Angle.PI_TIMES_2) angle -= Angle.PI_TIMES_2;\n\t\tif (angle < 0.0) angle = 0.0;\n\t}\n\treturn angle;\n};\nAngle.angleBetween = function (tip1, tail, tip2) {\n\tvar a1 = Angle.angle(tail, tip1);\n\tvar a2 = Angle.angle(tail, tip2);\n\treturn Angle.diff(a1, a2);\n};\nAngle.diff = function (ang1, ang2) {\n\tvar delAngle = null;\n\tif (ang1 < ang2) {\n\t\tdelAngle = ang2 - ang1;\n\t} else {\n\t\tdelAngle = ang1 - ang2;\n\t}\n\tif (delAngle > Math.PI) {\n\t\tdelAngle = 2 * Math.PI - delAngle;\n\t}\n\treturn delAngle;\n};\nAngle.toRadians = function (angleDegrees) {\n\treturn angleDegrees * Math.PI / 180.0;\n};\nAngle.getTurn = function (ang1, ang2) {\n\tvar crossproduct = Math.sin(ang2 - ang1);\n\tif (crossproduct > 0) {\n\t\treturn Angle.COUNTERCLOCKWISE;\n\t}\n\tif (crossproduct < 0) {\n\t\treturn Angle.CLOCKWISE;\n\t}\n\treturn Angle.NONE;\n};\nAngle.angleBetweenOriented = function (tip1, tail, tip2) {\n\tvar a1 = Angle.angle(tail, tip1);\n\tvar a2 = Angle.angle(tail, tip2);\n\tvar angDel = a2 - a1;\n\tif (angDel <= -Math.PI) return angDel + Angle.PI_TIMES_2;\n\tif (angDel > Math.PI) return angDel - Angle.PI_TIMES_2;\n\treturn angDel;\n};\nAngle.PI_TIMES_2 = 2.0 * Math.PI;\nAngle.PI_OVER_2 = Math.PI / 2.0;\nAngle.PI_OVER_4 = Math.PI / 4.0;\nAngle.COUNTERCLOCKWISE = Orientation.COUNTERCLOCKWISE;\nAngle.CLOCKWISE = Orientation.CLOCKWISE;\nAngle.NONE = Orientation.COLLINEAR;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/algorithm/Angle.js\n// module id = 102\n// module chunks = 0","import DirectedEdgeStar from '../../geomgraph/DirectedEdgeStar';\nimport Node from '../../geomgraph/Node';\nimport extend from '../../../../../extend';\nimport inherits from '../../../../../inherits';\nimport NodeFactory from '../../geomgraph/NodeFactory';\nexport default function OverlayNodeFactory() {\n\tNodeFactory.apply(this);\n}\ninherits(OverlayNodeFactory, NodeFactory);\nextend(OverlayNodeFactory.prototype, {\n\tcreateNode: function (coord) {\n\t\treturn new Node(coord, new DirectedEdgeStar());\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn OverlayNodeFactory;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/operation/overlay/OverlayNodeFactory.js\n// module id = 103\n// module chunks = 0","import extend from '../../../../../extend';\nexport default function PointOnGeometryLocator() {}\nextend(PointOnGeometryLocator.prototype, {\n\tlocate: function (p) {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn PointOnGeometryLocator;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/algorithm/locate/PointOnGeometryLocator.js\n// module id = 104\n// module chunks = 0","import Iterator from '../../../../java/util/Iterator';\nimport NoSuchElementException from '../../../../java/util/NoSuchElementException';\nimport extend from '../../../../extend';\nimport GeometryCollection from './GeometryCollection';\nexport default function GeometryCollectionIterator() {\n\tthis._parent = null;\n\tthis._atStart = null;\n\tthis._max = null;\n\tthis._index = null;\n\tthis._subcollectionIterator = null;\n\tlet parent = arguments[0];\n\tthis._parent = parent;\n\tthis._atStart = true;\n\tthis._index = 0;\n\tthis._max = parent.getNumGeometries();\n}\nextend(GeometryCollectionIterator.prototype, {\n\tnext: function () {\n\t\tif (this._atStart) {\n\t\t\tthis._atStart = false;\n\t\t\tif (GeometryCollectionIterator.isAtomic(this._parent)) this._index++;\n\t\t\treturn this._parent;\n\t\t}\n\t\tif (this._subcollectionIterator !== null) {\n\t\t\tif (this._subcollectionIterator.hasNext()) {\n\t\t\t\treturn this._subcollectionIterator.next();\n\t\t\t} else {\n\t\t\t\tthis._subcollectionIterator = null;\n\t\t\t}\n\t\t}\n\t\tif (this._index >= this._max) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tvar obj = this._parent.getGeometryN(this._index++);\n\t\tif (obj instanceof GeometryCollection) {\n\t\t\tthis._subcollectionIterator = new GeometryCollectionIterator(obj);\n\t\t\treturn this._subcollectionIterator.next();\n\t\t}\n\t\treturn obj;\n\t},\n\tremove: function () {\n\t\tthrow new UnsupportedOperationException(this.getClass().getName());\n\t},\n\thasNext: function () {\n\t\tif (this._atStart) {\n\t\t\treturn true;\n\t\t}\n\t\tif (this._subcollectionIterator !== null) {\n\t\t\tif (this._subcollectionIterator.hasNext()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tthis._subcollectionIterator = null;\n\t\t}\n\t\tif (this._index >= this._max) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Iterator];\n\t},\n\tgetClass: function () {\n\t\treturn GeometryCollectionIterator;\n\t}\n});\nGeometryCollectionIterator.isAtomic = function (geom) {\n\treturn !(geom instanceof GeometryCollection);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/GeometryCollectionIterator.js\n// module id = 105\n// module chunks = 0","import OrientedCoordinateArray from '../noding/OrientedCoordinateArray';\nimport extend from '../../../../extend';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport TreeMap from '../../../../java/util/TreeMap';\nexport default function EdgeList() {\n\tthis._edges = new ArrayList();\n\tthis._ocaMap = new TreeMap();\n}\nextend(EdgeList.prototype, {\n\tprint: function (out) {\n\t\tout.print(\"MULTILINESTRING ( \");\n\t\tfor (var j = 0; j < this._edges.size(); j++) {\n\t\t\tvar e = this._edges.get(j);\n\t\t\tif (j > 0) out.print(\",\");\n\t\t\tout.print(\"(\");\n\t\t\tvar pts = e.getCoordinates();\n\t\t\tfor (var i = 0; i < pts.length; i++) {\n\t\t\t\tif (i > 0) out.print(\",\");\n\t\t\t\tout.print(pts[i].x + \" \" + pts[i].y);\n\t\t\t}\n\t\t\tout.println(\")\");\n\t\t}\n\t\tout.print(\")  \");\n\t},\n\taddAll: function (edgeColl) {\n\t\tfor (var i = edgeColl.iterator(); i.hasNext(); ) {\n\t\t\tthis.add(i.next());\n\t\t}\n\t},\n\tfindEdgeIndex: function (e) {\n\t\tfor (var i = 0; i < this._edges.size(); i++) {\n\t\t\tif (this._edges.get(i).equals(e)) return i;\n\t\t}\n\t\treturn -1;\n\t},\n\titerator: function () {\n\t\treturn this._edges.iterator();\n\t},\n\tgetEdges: function () {\n\t\treturn this._edges;\n\t},\n\tget: function (i) {\n\t\treturn this._edges.get(i);\n\t},\n\tfindEqualEdge: function (e) {\n\t\tvar oca = new OrientedCoordinateArray(e.getCoordinates());\n\t\tvar matchEdge = this._ocaMap.get(oca);\n\t\treturn matchEdge;\n\t},\n\tadd: function (e) {\n\t\tthis._edges.add(e);\n\t\tvar oca = new OrientedCoordinateArray(e.getCoordinates());\n\t\tthis._ocaMap.put(oca, e);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn EdgeList;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeList.js\n// module id = 106\n// module chunks = 0","module.exports = \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiCiAgIHhtbG5zOmlua3NjYXBlPSJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlIgogICB3aWR0aD0iMTUxLjQ4NDA0bW0iCiAgIGhlaWdodD0iMTQ3LjEzMzEybW0iCiAgIHZpZXdCb3g9IjAgMCA1MzYuNzU0NSA1MjEuMzM3ODUiCiAgIGlkPSJzdmcyIgogICB2ZXJzaW9uPSIxLjEiCiAgIGlua3NjYXBlOnZlcnNpb249IjAuOTEgcjEzNzI1IgogICBzb2RpcG9kaTpkb2NuYW1lPSJidWZmZXIuc3ZnIgogICBpbmtzY2FwZTpleHBvcnQtZmlsZW5hbWU9Ii9ob21lL21hcmlvL3JlcG9zaXRvcmllcy9vbGU0L2ltZy9yb3RhdGUucG5nIgogICBpbmtzY2FwZTpleHBvcnQteGRwaT0iMTYuODE4ODcyIgogICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMTYuODE4ODcyIj4KICA8ZGVmcwogICAgIGlkPSJkZWZzNCIgLz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgaWQ9ImJhc2UiCiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEuMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIgogICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9IjIiCiAgICAgaW5rc2NhcGU6em9vbT0iMC45MDUwOTY2OCIKICAgICBpbmtzY2FwZTpjeD0iMjkzLjg0NDA3IgogICAgIGlua3NjYXBlOmN5PSIxNjguMzMwNDIiCiAgICAgaW5rc2NhcGU6ZG9jdW1lbnQtdW5pdHM9InB4IgogICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9ImxheWVyMSIKICAgICBzaG93Z3JpZD0idHJ1ZSIKICAgICBzaG93Z3VpZGVzPSJmYWxzZSIKICAgICBmaXQtbWFyZ2luLXRvcD0iMCIKICAgICBmaXQtbWFyZ2luLWxlZnQ9IjAiCiAgICAgZml0LW1hcmdpbi1yaWdodD0iMCIKICAgICBmaXQtbWFyZ2luLWJvdHRvbT0iMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjE4NjUiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iMTA1NiIKICAgICBpbmtzY2FwZTp3aW5kb3cteD0iNTUiCiAgICAgaW5rc2NhcGU6d2luZG93LXk9IjI0IgogICAgIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9IjEiCiAgICAgaW5rc2NhcGU6c25hcC1jZW50ZXI9InRydWUiCiAgICAgaW5rc2NhcGU6c25hcC1ncmlkcz0idHJ1ZSIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiCiAgICAgaW5rc2NhcGU6YmJveC1ub2Rlcz0idHJ1ZSIKICAgICBpbmtzY2FwZTpzbmFwLWJib3gtZWRnZS1taWRwb2ludHM9InRydWUiCiAgICAgaW5rc2NhcGU6YmJveC1wYXRocz0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgaWQ9ImdyaWQzMzQwIgogICAgICAgb3JpZ2lueD0iLTEyMS41Mzc3IgogICAgICAgb3JpZ2lueT0iLTE5OS40NTI3NiIgLz4KICA8L3NvZGlwb2RpOm5hbWVkdmlldz4KICA8bWV0YWRhdGEKICAgICBpZD0ibWV0YWRhdGE3Ij4KICAgIDxyZGY6UkRGPgogICAgICA8Y2M6V29yawogICAgICAgICByZGY6YWJvdXQ9IiI+CiAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+CiAgICAgICAgPGRjOnR5cGUKICAgICAgICAgICByZGY6cmVzb3VyY2U9Imh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlIiAvPgogICAgICAgIDxkYzp0aXRsZT48L2RjOnRpdGxlPgogICAgICA8L2NjOldvcms+CiAgICA8L3JkZjpSREY+CiAgPC9tZXRhZGF0YT4KICA8ZwogICAgIGlua3NjYXBlOmxhYmVsPSJFYmVuZSAxIgogICAgIGlua3NjYXBlOmdyb3VwbW9kZT0ibGF5ZXIiCiAgICAgaWQ9ImxheWVyMSIKICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTIxLjUzNzcsLTMzMS41NzE2MikiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjkwLjAwMDAwNzYzO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSA2MTMuNTE2MDUsNDM2LjQzMDAyIDQ5Ni41OTA2Niw2NTQuMjA0NTggMjk4LjU5NTYyLDY4Ny43MzI0NyAyNDYuNDg0LDgwOC4yOTQ0NSAyOTYuOTkxNjUsNjg3LjUyOTQyIDQ5Ni45OTE2OCw2NTcuNTI5NDEgWiIKICAgICAgIGlkPSJwYXRoNDE1MC0zIgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjYyIKICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIxNi44MTg4NzIiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMTYuODE4ODcyIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOiNmZmZmZmY7c3Ryb2tlLXdpZHRoOjQwLjAwMDAwMzgxO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSA2MTMuNTE2MDQsNDM2LjQzMDAzIC0xMTYuOTI1MzksMjE3Ljc3NDU1IC0xOTcuOTk1MDIsMzMuNTI3ODggLTUyLjExMTYyLDEyMC41NjE5OCA1MC41MDc2NSwtMTIwLjc2NTAzIDIwMC4wMDAwMSwtMzAgeiIKICAgICAgIGlkPSJwYXRoNDE1MCIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjY2MiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteGRwaT0iMTYuODE4ODcyIgogICAgICAgaW5rc2NhcGU6ZXhwb3J0LXlkcGk9IjE2LjgxODg3MiIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTojOGE4YThhO3N0cm9rZS13aWR0aDozMC4wMDAwMDE5MTtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNTAzLjUxNjA1LDM0Ni40MzAwMSAzODYuNTkwNjYsNTY0LjIwNDU3IDE4OC41OTU2Myw1OTcuNzMyNDYgMTM2LjQ4NCw3MTguMjk0NDQgMTg2Ljk5MTY2LDU5Ny41Mjk0MSAzODYuOTkxNjgsNTY3LjUyOTQgWiIKICAgICAgIGlkPSJwYXRoNDE1MC01IgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjYyIKICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIxNi44MTg4NzIiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMTYuODE4ODcyIiAvPgogIDwvZz4KPC9zdmc+Cg==\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./img/buffer.svg\n// module id = 107\n// module chunks = 0","import SnapOverlayOp from './SnapOverlayOp';\nimport extend from '../../../../../../extend';\nimport RuntimeException from '../../../../../../java/lang/RuntimeException';\nimport OverlayOp from '../OverlayOp';\nexport default function SnapIfNeededOverlayOp() {\n\tthis._geom = new Array(2).fill(null);\n\tlet g1 = arguments[0], g2 = arguments[1];\n\tthis._geom[0] = g1;\n\tthis._geom[1] = g2;\n}\nextend(SnapIfNeededOverlayOp.prototype, {\n\tgetResultGeometry: function (opCode) {\n\t\tvar result = null;\n\t\tvar isSuccess = false;\n\t\tvar savedException = null;\n\t\ttry {\n\t\t\tresult = OverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);\n\t\t\tvar isValid = true;\n\t\t\tif (isValid) isSuccess = true;\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof RuntimeException) {\n\t\t\t\tsavedException = ex;\n\t\t\t} else throw ex;\n\t\t} finally {}\n\t\tif (!isSuccess) {\n\t\t\ttry {\n\t\t\t\tresult = SnapOverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);\n\t\t\t} catch (ex) {\n\t\t\t\tif (ex instanceof RuntimeException) {\n\t\t\t\t\tthrow savedException;\n\t\t\t\t} else throw ex;\n\t\t\t} finally {}\n\t\t}\n\t\treturn result;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn SnapIfNeededOverlayOp;\n\t}\n});\nSnapIfNeededOverlayOp.overlayOp = function (g0, g1, opCode) {\n\tvar op = new SnapIfNeededOverlayOp(g0, g1);\n\treturn op.getResultGeometry(opCode);\n};\nSnapIfNeededOverlayOp.union = function (g0, g1) {\n\treturn SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.UNION);\n};\nSnapIfNeededOverlayOp.intersection = function (g0, g1) {\n\treturn SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION);\n};\nSnapIfNeededOverlayOp.symDifference = function (g0, g1) {\n\treturn SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE);\n};\nSnapIfNeededOverlayOp.difference = function (g0, g1) {\n\treturn SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/operation/overlay/snap/SnapIfNeededOverlayOp.js\n// module id = 108\n// module chunks = 0","import Location from '../geom/Location';\nimport LineString from '../geom/LineString';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport Point from '../geom/Point';\nimport Polygon from '../geom/Polygon';\nimport PointLocation from './PointLocation';\nimport BoundaryNodeRule from './BoundaryNodeRule';\nimport extend from '../../../../extend';\nimport MultiPolygon from '../geom/MultiPolygon';\nimport GeometryCollectionIterator from '../geom/GeometryCollectionIterator';\nimport GeometryCollection from '../geom/GeometryCollection';\nimport MultiLineString from '../geom/MultiLineString';\nexport default function PointLocator() {\n\tthis._boundaryRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;\n\tthis._isIn = null;\n\tthis._numBoundaries = null;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet boundaryRule = arguments[0];\n\t\tif (boundaryRule === null) throw new IllegalArgumentException(\"Rule must be non-null\");\n\t\tthis._boundaryRule = boundaryRule;\n\t}\n}\nextend(PointLocator.prototype, {\n\tlocateInPolygonRing: function (p, ring) {\n\t\tif (!ring.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;\n\t\treturn PointLocation.locateInRing(p, ring.getCoordinates());\n\t},\n\tintersects: function (p, geom) {\n\t\treturn this.locate(p, geom) !== Location.EXTERIOR;\n\t},\n\tupdateLocationInfo: function (loc) {\n\t\tif (loc === Location.INTERIOR) this._isIn = true;\n\t\tif (loc === Location.BOUNDARY) this._numBoundaries++;\n\t},\n\tcomputeLocation: function (p, geom) {\n\t\tif (geom instanceof Point) {\n\t\t\tthis.updateLocationInfo(this.locateOnPoint(p, geom));\n\t\t}\n\t\tif (geom instanceof LineString) {\n\t\t\tthis.updateLocationInfo(this.locateOnLineString(p, geom));\n\t\t} else if (geom instanceof Polygon) {\n\t\t\tthis.updateLocationInfo(this.locateInPolygon(p, geom));\n\t\t} else if (geom instanceof MultiLineString) {\n\t\t\tvar ml = geom;\n\t\t\tfor (var i = 0; i < ml.getNumGeometries(); i++) {\n\t\t\t\tvar l = ml.getGeometryN(i);\n\t\t\t\tthis.updateLocationInfo(this.locateOnLineString(p, l));\n\t\t\t}\n\t\t} else if (geom instanceof MultiPolygon) {\n\t\t\tvar mpoly = geom;\n\t\t\tfor (var i = 0; i < mpoly.getNumGeometries(); i++) {\n\t\t\t\tvar poly = mpoly.getGeometryN(i);\n\t\t\t\tthis.updateLocationInfo(this.locateInPolygon(p, poly));\n\t\t\t}\n\t\t} else if (geom instanceof GeometryCollection) {\n\t\t\tvar geomi = new GeometryCollectionIterator(geom);\n\t\t\twhile (geomi.hasNext()) {\n\t\t\t\tvar g2 = geomi.next();\n\t\t\t\tif (g2 !== geom) this.computeLocation(p, g2);\n\t\t\t}\n\t\t}\n\t},\n\tlocateOnPoint: function (p, pt) {\n\t\tvar ptCoord = pt.getCoordinate();\n\t\tif (ptCoord.equals2D(p)) return Location.INTERIOR;\n\t\treturn Location.EXTERIOR;\n\t},\n\tlocateOnLineString: function (p, l) {\n\t\tif (!l.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;\n\t\tvar seq = l.getCoordinateSequence();\n\t\tif (!l.isClosed()) {\n\t\t\tif (p.equals(seq.getCoordinate(0)) || p.equals(seq.getCoordinate(seq.size() - 1))) {\n\t\t\t\treturn Location.BOUNDARY;\n\t\t\t}\n\t\t}\n\t\tif (PointLocation.isOnLine(p, seq)) {\n\t\t\treturn Location.INTERIOR;\n\t\t}\n\t\treturn Location.EXTERIOR;\n\t},\n\tlocateInPolygon: function (p, poly) {\n\t\tif (poly.isEmpty()) return Location.EXTERIOR;\n\t\tvar shell = poly.getExteriorRing();\n\t\tvar shellLoc = this.locateInPolygonRing(p, shell);\n\t\tif (shellLoc === Location.EXTERIOR) return Location.EXTERIOR;\n\t\tif (shellLoc === Location.BOUNDARY) return Location.BOUNDARY;\n\t\tfor (var i = 0; i < poly.getNumInteriorRing(); i++) {\n\t\t\tvar hole = poly.getInteriorRingN(i);\n\t\t\tvar holeLoc = this.locateInPolygonRing(p, hole);\n\t\t\tif (holeLoc === Location.INTERIOR) return Location.EXTERIOR;\n\t\t\tif (holeLoc === Location.BOUNDARY) return Location.BOUNDARY;\n\t\t}\n\t\treturn Location.INTERIOR;\n\t},\n\tlocate: function (p, geom) {\n\t\tif (geom.isEmpty()) return Location.EXTERIOR;\n\t\tif (geom instanceof LineString) {\n\t\t\treturn this.locateOnLineString(p, geom);\n\t\t} else if (geom instanceof Polygon) {\n\t\t\treturn this.locateInPolygon(p, geom);\n\t\t}\n\t\tthis._isIn = false;\n\t\tthis._numBoundaries = 0;\n\t\tthis.computeLocation(p, geom);\n\t\tif (this._boundaryRule.isInBoundary(this._numBoundaries)) return Location.BOUNDARY;\n\t\tif (this._numBoundaries > 0 || this._isIn) return Location.INTERIOR;\n\t\treturn Location.EXTERIOR;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn PointLocator;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/algorithm/PointLocator.js\n// module id = 109\n// module chunks = 0","import extend from '../../../../../extend';\nexport default function SegmentIntersector() {\n\tthis._hasIntersection = false;\n\tthis._hasProper = false;\n\tthis._hasProperInterior = false;\n\tthis._properIntersectionPoint = null;\n\tthis._li = null;\n\tthis._includeProper = null;\n\tthis._recordIsolated = null;\n\tthis._isSelfIntersection = null;\n\tthis._numIntersections = 0;\n\tthis.numTests = 0;\n\tthis._bdyNodes = null;\n\tthis._isDone = false;\n\tthis._isDoneWhenProperInt = false;\n\tlet li = arguments[0], includeProper = arguments[1], recordIsolated = arguments[2];\n\tthis._li = li;\n\tthis._includeProper = includeProper;\n\tthis._recordIsolated = recordIsolated;\n}\nextend(SegmentIntersector.prototype, {\n\tisTrivialIntersection: function (e0, segIndex0, e1, segIndex1) {\n\t\tif (e0 === e1) {\n\t\t\tif (this._li.getIntersectionNum() === 1) {\n\t\t\t\tif (SegmentIntersector.isAdjacentSegments(segIndex0, segIndex1)) return true;\n\t\t\t\tif (e0.isClosed()) {\n\t\t\t\t\tvar maxSegIndex = e0.getNumPoints() - 1;\n\t\t\t\t\tif (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetProperIntersectionPoint: function () {\n\t\treturn this._properIntersectionPoint;\n\t},\n\tsetIsDoneIfProperInt: function (isDoneWhenProperInt) {\n\t\tthis._isDoneWhenProperInt = isDoneWhenProperInt;\n\t},\n\thasProperInteriorIntersection: function () {\n\t\treturn this._hasProperInterior;\n\t},\n\tisBoundaryPointInternal: function (li, bdyNodes) {\n\t\tfor (var i = bdyNodes.iterator(); i.hasNext(); ) {\n\t\t\tvar node = i.next();\n\t\t\tvar pt = node.getCoordinate();\n\t\t\tif (li.isIntersection(pt)) return true;\n\t\t}\n\t\treturn false;\n\t},\n\thasProperIntersection: function () {\n\t\treturn this._hasProper;\n\t},\n\thasIntersection: function () {\n\t\treturn this._hasIntersection;\n\t},\n\tisDone: function () {\n\t\treturn this._isDone;\n\t},\n\tisBoundaryPoint: function (li, bdyNodes) {\n\t\tif (bdyNodes === null) return false;\n\t\tif (this.isBoundaryPointInternal(li, bdyNodes[0])) return true;\n\t\tif (this.isBoundaryPointInternal(li, bdyNodes[1])) return true;\n\t\treturn false;\n\t},\n\tsetBoundaryNodes: function (bdyNodes0, bdyNodes1) {\n\t\tthis._bdyNodes = new Array(2).fill(null);\n\t\tthis._bdyNodes[0] = bdyNodes0;\n\t\tthis._bdyNodes[1] = bdyNodes1;\n\t},\n\taddIntersections: function (e0, segIndex0, e1, segIndex1) {\n\t\tif (e0 === e1 && segIndex0 === segIndex1) return null;\n\t\tthis.numTests++;\n\t\tvar p00 = e0.getCoordinates()[segIndex0];\n\t\tvar p01 = e0.getCoordinates()[segIndex0 + 1];\n\t\tvar p10 = e1.getCoordinates()[segIndex1];\n\t\tvar p11 = e1.getCoordinates()[segIndex1 + 1];\n\t\tthis._li.computeIntersection(p00, p01, p10, p11);\n\t\tif (this._li.hasIntersection()) {\n\t\t\tif (this._recordIsolated) {\n\t\t\t\te0.setIsolated(false);\n\t\t\t\te1.setIsolated(false);\n\t\t\t}\n\t\t\tthis._numIntersections++;\n\t\t\tif (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {\n\t\t\t\tthis._hasIntersection = true;\n\t\t\t\tif (this._includeProper || !this._li.isProper()) {\n\t\t\t\t\te0.addIntersections(this._li, segIndex0, 0);\n\t\t\t\t\te1.addIntersections(this._li, segIndex1, 1);\n\t\t\t\t}\n\t\t\t\tif (this._li.isProper()) {\n\t\t\t\t\tthis._properIntersectionPoint = this._li.getIntersection(0).copy();\n\t\t\t\t\tthis._hasProper = true;\n\t\t\t\t\tif (this._isDoneWhenProperInt) {\n\t\t\t\t\t\tthis._isDone = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (!this.isBoundaryPoint(this._li, this._bdyNodes)) this._hasProperInterior = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn SegmentIntersector;\n\t}\n});\nSegmentIntersector.isAdjacentSegments = function (i1, i2) {\n\treturn Math.abs(i1 - i2) === 1;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geomgraph/index/SegmentIntersector.js\n// module id = 110\n// module chunks = 0","import Editor from './editor';\nimport * as control from './control';\n\nexport { control, Editor };\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import Toolbar from './toolbar';\n\n/**\n * Core component of OLE.\n * All controls are added to this class.\n */\nclass Editor {\n  /**\n   * Initialization of the editor.\n   * @param {ol.Map} map The map object.\n   * @param {Object} [options] Editor options.\n   * @param {Boolean} [options.showToolbar] Whether to show the toolbar.\n   *   Default is true.\n   */\n  constructor(map, opts) {\n    /**\n     * @private\n     * @type {ol.Map}\n     */\n    this.map = map;\n\n    /**\n     * @private\n     * @type {ol.Collection<ole.Control>}\n     */\n    this.controls = new ol.Collection();\n\n    /**\n     * @private\n     * @type {ol.Collection<ole.Control>}\n     */\n    this.activeControls = new ol.Collection();\n\n    /**\n     * @private\n     * @type {Object}\n     */\n    this.options = opts || {};\n\n    /**\n     * Feature that is currently edited.\n     * @private\n     * @type {ol.Feature}\n     */\n    this.editFeature = null;\n\n    if (typeof this.options.showToolbar === 'undefined') {\n      this.options.showToolbar = true;\n    }\n\n    if (this.options.showToolbar) {\n      this.toolbar = new Toolbar(this.map, this.controls);\n    }\n  }\n\n  /**\n   * Adds a new control to the editor.\n   * @param {ole.Control} control The control.\n   */\n  addControl(control) {\n    control.setMap(this.map);\n    control.setEditor(this);\n    this.controls.push(control);\n  }\n\n  /**\n   * Adds a collection of controls to the editor.\n   * @param {ol.Collection<ole.Control>} controls Collection of controls.\n   */\n  addControls(controls) {\n    const ctrls = controls instanceof ol.Collection ? controls\n      : new ol.Collection(controls);\n\n    for (let i = 0; i < ctrls.getLength(); i += 1) {\n      this.addControl(ctrls.item(i));\n    }\n  }\n\n  /**\n   * Removes the editor from the map.\n   */\n  remove() {\n    this.controls.forEach((c) => {\n      c.deactivate();\n    });\n\n    this.toolbar.destroy();\n  }\n\n  /**\n   * Returns a list of active controls.\n   * @returns {ol.Collection.<ole.Control>} Active controls.\n   */\n  getActiveControls() {\n    return this.activeControls;\n  }\n\n  /**\n   * Sets an instance of the feature that is edited.\n   * Some controls need information about the feature\n   * that is currently edited (e.g. for not snapping on them).\n   * @param {ol.Feature|null} feature The editfeature (or null if none)\n   * @protected\n   */\n  setEditFeature(feature) {\n    this.editFeature = feature;\n  }\n\n  /**\n   * Returns the feature that is currently edited.\n   * @returns {ol.Feature|null} The edit feature.\n   */\n  getEditFeature() {\n    return this.editFeature;\n  }\n\n  /**\n   * Controls use this function for triggering activity state changes.\n   * @param {ol.control.Control} control Control.\n   * @private\n   */\n  activeStateChange(ctrl) {\n    // deactivate other controls that are not standalone\n    if (ctrl.getActive() && ctrl.standalone) {\n      for (let i = 0; i < this.controls.getLength(); i += 1) {\n        if ((this.controls.item(i) !== ctrl) &&\n          (this.controls.item(i).standalone)) {\n          this.controls.item(i).deactivate();\n        }\n      }\n    }\n\n    const ctrls = this.controls.getArray().filter(c => c.getActive());\n    this.activeControls.clear();\n    this.activeControls.extend(ctrls);\n  }\n}\n\nexport default Editor;\n\n\n\n// WEBPACK FOOTER //\n// ./src/editor.js","import '../style/ole.css';\n\n/**\n * The editor's toolbar.\n * @class\n * @alias ole.Toolbar\n */\nclass Toolbar extends ol.control.Control {\n  /**\n   * Constructor.\n   * @param {ol.Map} map The map object.\n   * @param {ol.Collection.<ol.control.Control>} controls Controls\n   *   to display in the toolbar.\n   */\n  constructor(map, controls) {\n    const element = document.createElement('div');\n    element.setAttribute('id', 'ole-toolbar');\n\n    super({\n      element,\n    });\n\n    /**\n     * @private\n     * @type {ol.Collection.<ol.control.Control>}\n     */\n    this.controls = controls;\n\n    /**\n     * @private\n     * @type {ol.Map}\n     */\n    this.map = map;\n\n    this.map.getTargetElement().appendChild(this.element);\n    this.load();\n    this.controls.on('change:length', this.load, this);\n  }\n\n  /**\n   * Load the toolbar.\n   * @private\n   */\n  load() {\n    for (let i = 0; i < this.controls.getLength(); i += 1) {\n      const btn = this.controls.item(i).getElement();\n      this.element.appendChild(btn);\n    }\n  }\n\n  /**\n   * Destroy the toolbar.\n   * @private\n   */\n  destroy() {\n    for (let i = 0; i < this.controls.getLength(); i += 1) {\n      const btn = this.controls.item(i).getElement();\n      this.element.removeChild(btn);\n    }\n  }\n}\n\nexport default Toolbar;\n\n\n\n// WEBPACK FOOTER //\n// ./src/toolbar.js","\nvar content = require(\"!!../node_modules/css-loader/index.js??ref--6-1!./ole.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../node_modules/css-loader/index.js??ref--6-1!./ole.css\", function() {\n\t\tvar newContent = require(\"!!../node_modules/css-loader/index.js??ref--6-1!./ole.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./style/ole.css\n// module id = 115\n// module chunks = 0","exports = module.exports = require(\"../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \"#ole-toolbar {\\n  position: absolute;\\n  right: 20px;\\n  top: 20px;\\n}\\n\\n#ole-toolbar button.ole-control {\\n  background: #fafafa;\\n  border: 0;\\n  color: #999;\\n  cursor: pointer;\\n  font-size: 14px;\\n  line-height: 36px;\\n  height: 45px;\\n  padding: 0 8px;\\n  transition: all .3s ease-out;\\n}\\n\\n#ole-toolbar button.ole-control:first-child {\\n  border-radius: 4px 0 0 4px;\\n}\\n\\n#ole-toolbar button.ole-control:last-child {\\n  border-radius: 0 4px 4px 0;\\n}\\n\\n#ole-toolbar button.ole-control:hover {\\n  color: #5c5c5c;\\n}\\n\\n#ole-toolbar button.ole-control:focus {\\n  outline: 0;\\n}\\n\\n#ole-toolbar button.ole-control.active {\\n  box-shadow: 0 4px 4px 0 rgba(0,0,0,0.3);\\n  color: #5c5c5c;\\n  filter: brightness(90%);\\n}\\n\\n/* buttons */\\n#ole-toolbar button.ole-control {\\n  padding: 5px;\\n}\\n\\n#ole-toolbar button.ole-control img {\\n  height: 35px;\\n}\\n\\n\\n/* dialog */\\n.ole-dialog {\\n  background: #fafafa;\\n  border-radius: 4px;\\n  right: 20px;\\n  padding: 10px;\\n  position: absolute;\\n  text-align: left;\\n  top: 75px;\\n  width: 330px;\\n  z-index: 2;\\n}\\n\\n/* font */\\n#ole-toolbar, .ole-dialog {\\n  font-family: Arial;\\n  font-size:  14px;\\n}\\n\\n/* shadow */\\n#ole-toolbar button.ole-control, .ole-dialog {\\n  box-shadow: 0 3px 3px 0 rgba(0,0,0,0.2);\\n}\\n\\n#width-input {\\n  width: 50px;\\n}\\n\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/css-loader??ref--6-1!./style/ole.css\n// module id = 116\n// module chunks = 0","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/css-loader/lib/css-base.js\n// module id = 117\n// module chunks = 0","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target) {\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = require(\"./urls\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertInto + \" \" + options.insertAt.before);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\toptions.attrs.type = \"text/css\";\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\toptions.attrs.type = \"text/css\";\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/style-loader/lib/addStyles.js\n// module id = 118\n// module chunks = 0","\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/style-loader/lib/urls.js\n// module id = 119\n// module chunks = 0","import Control from './control';\nimport CAD from './cad';\nimport Rotate from './rotate';\nimport Draw from './draw';\nimport Move from './move';\nimport Modify from './modify';\nimport Delete from './delete';\nimport Buffer from './buffer';\nimport Union from './union';\nimport Intersection from './intersection';\nimport Difference from './difference';\n\nexport {\n  Control,\n  CAD,\n  Rotate,\n  Draw,\n  Move,\n  Modify,\n  Delete,\n  Buffer,\n  Union,\n  Intersection,\n  Difference,\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/control/index.js","import Control from './control';\nimport cadSVG from '../../img/cad.svg';\n\n/**\n * Control with snapping functionality for geometry alignment.\n * @extends {ole.Control}\n * @alias ole.CadControl\n */\nclass CadControl extends Control {\n  /**\n   * @param {Object} options Tool options.\n   * @param {Number} [options.snapTolerance] Snap tolerance in pixel\n   *   for snap lines. Default is 10.\n   * @param {Boolean} [options.showSnapLines] Whether to show\n   *   snap lines (default is true).\n   * @param {Boolean} [options.showSnapPoints] Whether to show\n   *  snap points around the closest feature.\n   * @param {Number} [options.snapPointDist] Distance of the\n   *   snap points (default is 30).\n   * @param {Boolean} [options.useMapUnits] Whether to use map units\n   *   as measurement for point snapping. Default is false (pixel are used).\n   */\n  constructor(options) {\n    super(Object.assign({\n      title: 'CAD control',\n      className: 'ole-control-cad',\n      image: cadSVG,\n    }, options));\n\n    /**\n     * If true, map units are used for point snapping.\n     * The default measurement are pixels.\n     */\n    this.useMapUnits = options.useMapUnits;\n\n    /**\n     * Interaction for handling move events.\n     * @type {ol.interactionPointer}\n     * @private\n     */\n    this.pointerInteraction = new ol.interaction.Pointer({\n      handleMoveEvent: this.onMove.bind(this),\n    });\n\n    /**\n     * Layer for drawing snapping geometries.\n     * @type {ol.layer.Vector}\n     * @private\n     */\n    this.snapLayer = new ol.layer.Vector({\n      source: new ol.source.Vector(),\n      style: [\n        new ol.style.Style({\n          image: new ol.style.RegularShape({\n            fill: new ol.style.Fill({\n              color: '#E8841F',\n            }),\n            stroke: new ol.style.Stroke({\n              width: 1,\n              color: '#618496',\n            }),\n            points: 4,\n            radius: 5,\n            radius2: 0,\n            angle: Math.PI / 4,\n          }),\n          stroke: new ol.style.Stroke({\n            width: 1,\n            lineDash: [5, 10],\n            color: '#618496',\n          }),\n        }),\n      ],\n    });\n\n    /**\n     * Layer for colored lines indicating\n     * intesection point between snapping lines.\n     * @type {ol.layer.Vector}\n     * @private\n     */\n    this.linesLayer = new ol.layer.Vector({\n      source: new ol.source.Vector(),\n      style: [\n        new ol.style.Style({\n          stroke: new ol.style.Stroke({\n            width: 1,\n            lineDash: [5, 10],\n            color: '#FF530D',\n          }),\n        }),\n      ],\n    });\n\n    /**\n     * Snap tolerance in pixel.\n     * @type {Number}\n     * @private\n     */\n    this.snapTolerance = options.snapTolerance || 10;\n\n    /**\n     * Interaction for snapping\n     * @type {ol.interaction.Snap}\n     * @private\n     */\n    this.snapInteraction = new ol.interaction.Snap({\n      pixelTolerance: this.snapTolerance,\n      source: this.snapLayer.getSource(),\n    });\n\n    /**\n     * Whether to show the snap points.\n     * @type {Boolean}\n     * @private\n     */\n    this.showSnapPoints = options.showSnapPoints;\n\n    /**\n     * Initial distance of snap points.\n     * @type {Number}\n     * @private\n     */\n    this.snapPointDist = options.snapPointDist || 30;\n\n    /**\n     * Whether to show snap lines.\n     * @type {Boolean}\n     * @private\n     */\n    this.showSnapLines = options.showSnapLines;\n\n    if (this.showSnapLines === 'undefined') {\n      this.showSnapLines = true;\n    }\n\n    /**\n     * Template for dialog.\n     * @type {string}\n     */\n    const distLabel = this.useMapUnits ? 'map units' : 'px';\n    this.dialogTemplate = `\n      <div>\n        <input\n          id=\"aux-cb\"\n          type=\"radio\"\n          name=\"radioBtn\"\n          ${this.showSnapLines ? 'checked' : ''}\n        >\n        <label>Show snap lines</label>\n      </div>\n      <div>\n        <input\n          id=\"dist-cb\"\n          type=\"radio\"\n          name=\"radioBtn\"\n          ${this.showSnapPoints ? 'checked' : ''}\n        >\n        <label>Show snap points. Distance (${distLabel}):</label>\n        <input type=\"text\" id=\"width-input\" value=\"${this.snapPointDist}\">\n      </div>\n    `;\n\n    this.standalone = false;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  setMap(map) {\n    super.setMap(map);\n    this.map.addLayer(this.snapLayer);\n    this.map.addLayer(this.linesLayer);\n\n    // Ensure that the snap interaction is at the last position\n    // as it must be the first to handle the  pointermove event.\n    this.map.getInteractions().on('change:length', (e) => {\n      const pos = e.target.getArray().indexOf(this.snapInteraction);\n\n      if (this.active && pos > -1 && pos !== e.target.getLength() - 1) {\n        this.deactivate();\n        this.activate();\n      }\n    });\n  }\n\n  /**\n   * Handle move event.\n   * @private\n   * @param {ol.MapBrowserEvent} evt Move event.\n   */\n  onMove(evt) {\n    const features = this.getClosestFeatures(evt.coordinate, 5);\n\n    // Don't snap on the edit feature\n    const editFeature = this.editor.getEditFeature();\n    if (editFeature && features.indexOf(editFeature) > -1) {\n      features.splice(features.indexOf(editFeature), 1);\n    }\n\n    this.linesLayer.getSource().clear();\n    this.snapLayer.getSource().clear();\n\n    if (this.showSnapLines) {\n      this.drawSnapLines(features, evt.coordinate);\n    }\n\n    if (this.showSnapPoints && features.length) {\n      this.drawSnapPoints(evt.coordinate, features[0]);\n    }\n  }\n\n  /**\n   * Returns a list of the {num} closest features\n   * to a given coordinate.\n   * @private\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @param {Number} numFeatures Number of features to search.\n   * @returns {Array.<ol.Feature>} List of closest features.\n   */\n  getClosestFeatures(coordinate, numFeatures) {\n    const num = numFeatures || 1;\n    const ext = [-Infinity, -Infinity, Infinity, Infinity];\n    const featureDict = {};\n\n    this.source.forEachFeatureInExtent(ext, (f) => {\n      const cCoord = f.getGeometry().getClosestPoint(coordinate);\n      const dx = cCoord[0] - coordinate[0];\n      const dy = cCoord[1] - coordinate[1];\n      const dist = (dx * dx) + (dy * dy);\n      featureDict[dist] = f;\n    });\n\n    const dists = Object.keys(featureDict);\n    const features = [];\n    const count = Math.min(dists.length, num);\n\n    dists.sort((a, b) => a - b);\n\n    for (let i = 0; i < count; i += 1) {\n      features.push(featureDict[dists[i]]);\n    }\n\n    return features;\n  }\n\n  /**\n   * Draws snap lines by building the extent for\n   * a pair of features.\n   * @private\n   * @param {Array.<ol.Feature>} features List of features.\n   * @param {ol.Coordinate} coordinate Mouse pointer coordinate.\n   */\n  drawSnapLines(features, coordinate) {\n    let auxCoords = [];\n\n    for (let i = 0; i < features.length; i += 1) {\n      const geom = features[i].getGeometry();\n      const featureCoord = geom.getCoordinates();\n\n      if (geom instanceof ol.geom.Point) {\n        auxCoords.push(featureCoord);\n      } else {\n        // filling snapLayer with features vertex\n        if (geom instanceof ol.geom.LineString) {\n          for (let j = 0; j < featureCoord.length; j += 1) {\n            auxCoords.push(featureCoord[j]);\n          }\n        } else if (geom instanceof ol.geom.Polygon) {\n          for (let j = 0; j < featureCoord[0].length; j += 1) {\n            auxCoords.push(featureCoord[0][j]);\n          }\n        }\n\n        // filling auxCoords\n        const coords = ol.geom.Polygon.fromExtent(geom.getExtent())\n          .getCoordinates()[0];\n        auxCoords = auxCoords.concat(coords);\n      }\n    }\n\n    const px = this.map.getPixelFromCoordinate(coordinate);\n    let lineCoords = null;\n\n    for (let i = 0; i < auxCoords.length; i += 1) {\n      const tol = this.snapTolerance;\n      const auxPx = this.map.getPixelFromCoordinate(auxCoords[i]);\n      const drawVLine = (px[0] > auxPx[0] - (this.snapTolerance / 2)) &&\n        (px[0] < auxPx[0] + (this.snapTolerance / 2));\n      const drawHLine = (px[1] > auxPx[1] - (this.snapTolerance / 2)) &&\n        (px[1] < auxPx[1] + (this.snapTolerance / 2));\n\n      if (drawVLine) {\n        let newY = px[1];\n        newY += (px[1] < auxPx[1]) ? -tol * 2 : tol * 2;\n        const newPt = this.map.getCoordinateFromPixel([auxPx[0], newY]);\n        lineCoords = [[auxCoords[i][0], newPt[1]], auxCoords[i]];\n      } else if (drawHLine) {\n        let newX = px[0];\n        newX += (px[0] < auxPx[0]) ? -tol * 2 : tol * 2;\n        const newPt = this.map.getCoordinateFromPixel([newX, auxPx[1]]);\n        lineCoords = [[newPt[0], auxCoords[i][1]], auxCoords[i]];\n      }\n\n      if (lineCoords) {\n        const g = new ol.geom.LineString(lineCoords);\n        this.snapLayer.getSource().addFeature(new ol.Feature(g));\n      }\n    }\n\n    let vertArray = null;\n    let horiArray = null;\n    const snapFeatures = this.snapLayer.getSource().getFeatures();\n\n    if (snapFeatures.length) {\n      snapFeatures.forEach((feature) => {\n        const featureCoord = feature.getGeometry().getCoordinates();\n        const x0 = featureCoord[0][0];\n        const x1 = featureCoord[1][0];\n        const y0 = featureCoord[0][1];\n        const y1 = featureCoord[1][1];\n\n        if (x0 === x1) {\n          vertArray = x0;\n        }\n        if (y0 === y1) {\n          horiArray = y0;\n        }\n      });\n\n      const snapPt = [];\n\n      if (vertArray && horiArray) {\n        snapPt.push(vertArray);\n        snapPt.push(horiArray);\n        this.linesLayer.getSource().addFeatures(snapFeatures);\n\n        this.snapLayer.getSource().clear();\n        const snapGeom = new ol.geom.Point(snapPt);\n        this.snapLayer.getSource().addFeature(new ol.Feature(snapGeom));\n      }\n    }\n  }\n\n  /**\n   * Adds snap points to the snapping layer.\n   * @private\n   * @param {ol.Coordinate} coordinateMouse cursor coordinate.\n   * @param {ol.eaturee} feature Feature to draw the snap points for.\n   */\n  drawSnapPoints(coordinate, feature) {\n    const featCoord = feature.getGeometry().getClosestPoint(coordinate);\n\n    const px = this.map.getPixelFromCoordinate(featCoord);\n    let snapCoords = [];\n\n    if (this.useMapUnits) {\n      snapCoords = [\n        [featCoord[0] - this.snapPointDist, featCoord[1]],\n        [featCoord[0] + this.snapPointDist, featCoord[1]],\n        [featCoord[0], featCoord[1] - this.snapPointDist],\n        [featCoord[0], featCoord[1] + this.snapPointDist],\n      ];\n    } else {\n      const snapPx = [\n        [px[0] - this.snapPointDist, px[1]],\n        [px[0] + this.snapPointDist, px[1]],\n        [px[0], px[1] - this.snapPointDist],\n        [px[0], px[1] + this.snapPointDist],\n      ];\n\n      for (let j = 0; j < snapPx.length; j += 1) {\n        snapCoords.push(this.map.getCoordinateFromPixel(snapPx[j]));\n      }\n    }\n\n    const snapGeom = new ol.geom.MultiPoint(snapCoords);\n    this.snapLayer.getSource().addFeature(new ol.Feature(snapGeom));\n  }\n\n  /**\n   * @inheritdoc\n   */\n  activate() {\n    super.activate();\n    this.map.addInteraction(this.pointerInteraction);\n    this.map.addInteraction(this.snapInteraction);\n\n    document.getElementById('aux-cb').addEventListener('change', (evt) => {\n      this.showSnapLines = evt.target.checked;\n      this.showSnapPoints = !this.showSnapLines;\n    });\n\n    document.getElementById('dist-cb').addEventListener('change', (evt) => {\n      this.showSnapPoints = evt.target.checked;\n      this.showSnapLines = !this.showSnapPoints;\n    });\n\n    document.getElementById('width-input').addEventListener('keyup', (evt) => {\n      if (parseFloat(evt.target.value)) {\n        this.snapPointDist = parseFloat(evt.target.value);\n      }\n    });\n  }\n\n  /**\n   * @inheritdoc\n   */\n  deactivate() {\n    super.deactivate();\n    this.map.removeInteraction(this.pointerInteraction);\n    this.map.removeInteraction(this.snapInteraction);\n  }\n}\n\nexport default CadControl;\n\n\n\n// WEBPACK FOOTER //\n// ./src/control/cad.js","module.exports = \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiCiAgIHhtbG5zOmlua3NjYXBlPSJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlIgogICB3aWR0aD0iMTI2LjQxMDcyIgogICBoZWlnaHQ9IjEyNi41MTAyNSIKICAgaWQ9InN2ZzIiCiAgIHZlcnNpb249IjEuMSIKICAgaW5rc2NhcGU6dmVyc2lvbj0iMC45MSByMTM3MjUiCiAgIGlua3NjYXBlOmV4cG9ydC1maWxlbmFtZT0iL2hvbWUvbWFyaW8vcmVwb3NpdG9yaWVzL29sZTQvaW1nL2NhZC5wbmciCiAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIyOC40NTYxOSIKICAgaW5rc2NhcGU6ZXhwb3J0LXlkcGk9IjI4LjQ1NjE5IgogICBzb2RpcG9kaTpkb2NuYW1lPSJjYWQuc3ZnIj4KICA8ZGVmcwogICAgIGlkPSJkZWZzNCIgLz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgaWQ9ImJhc2UiCiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEuMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIgogICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9IjIiCiAgICAgaW5rc2NhcGU6em9vbT0iMS40IgogICAgIGlua3NjYXBlOmN4PSItNTEuMTc1NTQ2IgogICAgIGlua3NjYXBlOmN5PSItMTQwLjcwMDAxIgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6c25hcC1ncmlkcz0idHJ1ZSIKICAgICBpbmtzY2FwZTpzbmFwLWNlbnRlcj0idHJ1ZSIKICAgICBpbmtzY2FwZTpzbmFwLW9iamVjdC1taWRwb2ludHM9ImZhbHNlIgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSIKICAgICBmaXQtbWFyZ2luLXRvcD0iMCIKICAgICBmaXQtbWFyZ2luLWxlZnQ9IjAiCiAgICAgZml0LW1hcmdpbi1yaWdodD0iMCIKICAgICBmaXQtbWFyZ2luLWJvdHRvbT0iMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9Ijk2MSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSIxMDI4IgogICAgIGlua3NjYXBlOndpbmRvdy14PSI2NSIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMjQiCiAgICAgaW5rc2NhcGU6d2luZG93LW1heGltaXplZD0iMCIKICAgICBzaG93Z3VpZGVzPSJmYWxzZSIKICAgICBpbmtzY2FwZTpzbmFwLW90aGVycz0idHJ1ZSIKICAgICBpbmtzY2FwZTpiYm94LW5vZGVzPSJ0cnVlIgogICAgIGlua3NjYXBlOmJib3gtcGF0aHM9ImZhbHNlIj4KICAgIDxpbmtzY2FwZTpncmlkCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBpZD0iZ3JpZDI5ODUiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiCiAgICAgICBzbmFwdmlzaWJsZWdyaWRsaW5lc29ubHk9InRydWUiCiAgICAgICBvcmlnaW54PSItMTEzLjU4OTI4IgogICAgICAgb3JpZ2lueT0iLTgzMCIgLz4KICA8L3NvZGlwb2RpOm5hbWVkdmlldz4KICA8bWV0YWRhdGEKICAgICBpZD0ibWV0YWRhdGE3Ij4KICAgIDxyZGY6UkRGPgogICAgICA8Y2M6V29yawogICAgICAgICByZGY6YWJvdXQ9IiI+CiAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+CiAgICAgICAgPGRjOnR5cGUKICAgICAgICAgICByZGY6cmVzb3VyY2U9Imh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlIiAvPgogICAgICAgIDxkYzp0aXRsZT48L2RjOnRpdGxlPgogICAgICA8L2NjOldvcms+CiAgICA8L3JkZjpSREY+CiAgPC9tZXRhZGF0YT4KICA8ZwogICAgIGlua3NjYXBlOmxhYmVsPSJMYXllciAxIgogICAgIGlua3NjYXBlOmdyb3VwbW9kZT0ibGF5ZXIiCiAgICAgaWQ9ImxheWVyMSIKICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTEzLjU4OTI4LC05NS44NTE4ODkpIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxOC4zOTk5OTk2MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAxMzUuNzkyNzksMjEzLjE0NDY2IDk0LjkyNTE3LC05NS4wNzQ3NyAwLjA3NDgsOTQuOTk5OTcgeiIKICAgICAgIGlkPSJwYXRoNjA1NiIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteGRwaT0iMzUiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMzUiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6I2ZmZmZmZjtzdHJva2Utd2lkdGg6Ny4xOTk5OTk4MTtzdHJva2UtbGluZWNhcDpzcXVhcmU7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDE3NS4zMzgyNiwxNTIuMDM1OTUgMTAuNjA2NjEsMTAuNjA2NiIKICAgICAgIGlkPSJwYXRoNjA5MCIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteGRwaT0iMjguNDU2MTkiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMjguNDU2MTkiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6I2ZmZmZmZjtzdHJva2Utd2lkdGg6Ny4xOTk5OTk4MTtzdHJva2UtbGluZWNhcDpzcXVhcmU7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDE4OS40ODA0LDEzNy44OTM4MiA3LjA3MTA3LDcuMDcxMDYiCiAgICAgICBpZD0icGF0aDYwOTIiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgaW5rc2NhcGU6ZXhwb3J0LXhkcGk9IjI4LjQ1NjE5IgogICAgICAgaW5rc2NhcGU6ZXhwb3J0LXlkcGk9IjI4LjQ1NjE5IiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOiNmZmZmZmY7c3Ryb2tlLXdpZHRoOjcuMTk5OTk5ODE7c3Ryb2tlLWxpbmVjYXA6c3F1YXJlO3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAxNjEuMTk2MTMsMTY2LjE3ODA5IDcuMDcxMDcsNy4wNzEwNyIKICAgICAgIGlkPSJwYXRoNjA5NCIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteGRwaT0iMjguNDU2MTkiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMjguNDU2MTkiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6I2ZmZmZmZjtzdHJva2Utd2lkdGg6Ny4xOTk5OTk4MTtzdHJva2UtbGluZWNhcDpzcXVhcmU7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDE0Ny4wNTM5OSwxODAuMzIwMjIgNy4wNzEwNyw3LjA3MTA3IgogICAgICAgaWQ9InBhdGg2MDk2IgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIyOC40NTYxOSIKICAgICAgIGlua3NjYXBlOmV4cG9ydC15ZHBpPSIyOC40NTYxOSIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTojZmZmZmZmO3N0cm9rZS13aWR0aDo3LjE5OTk5OTgxO3N0cm9rZS1saW5lY2FwOnNxdWFyZTtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMjAzLjYyMjU0LDEyMy43NTE2OCA3LjA3MTA2LDcuMDcxMDciCiAgICAgICBpZD0icGF0aDYwOTgiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgaW5rc2NhcGU6ZXhwb3J0LXhkcGk9IjI4LjQ1NjE5IgogICAgICAgaW5rc2NhcGU6ZXhwb3J0LXlkcGk9IjI4LjQ1NjE5IiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOiNmZmZmZmY7c3Ryb2tlLXdpZHRoOjcuMTk5OTk5ODE7c3Ryb2tlLWxpbmVjYXA6c3F1YXJlO3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAyMTcuNzY0NjcsMTA5LjYwOTU1IDcuMDcxMDcsNy4wNzEwNiIKICAgICAgIGlkPSJwYXRoNjEwMCIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteGRwaT0iMjguNDU2MTkiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMjguNDU2MTkiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6I2ZmZmZmZjtzdHJva2Utd2lkdGg6Ny4xOTk5OTk4MTtzdHJva2UtbGluZWNhcDpzcXVhcmU7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDEzMi45MTE4NiwxOTQuNDYyMzYgNy4wNzEwNyw3LjA3MTA3IgogICAgICAgaWQ9InBhdGg2MTAyIgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIyOC40NTYxOSIKICAgICAgIGlua3NjYXBlOmV4cG9ydC15ZHBpPSIyOC40NTYxOSIgLz4KICA8L2c+Cjwvc3ZnPgo=\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./img/cad.svg\n// module id = 122\n// module chunks = 0","import Control from './control';\nimport rotateSVG from '../../img/rotate.svg';\nimport rotateMapSVG from '../../img/rotate_map.svg';\n\n/**\n * Tool with for rotating geometries.\n * @extends {ole.Control}\n * @alias ole.RotateControl\n */\nclass RotateControl extends Control {\n  /**\n   * @param {string} [options.rotateAttribute] Name of a feature attribute\n   *   that is used for storing the rotation in rad.\n   */\n  constructor(options) {\n    super(Object.assign({\n      title: 'Rotate',\n      className: 'icon-rotate',\n      image: rotateSVG,\n    }, options));\n\n    /**\n     * @type {ol.interaction.Pointer}\n     * @private\n     */\n    this.pointerInteraction = new ol.interaction.Pointer({\n      handleDownEvent: this.onDown.bind(this),\n      handleDragEvent: this.onDrag.bind(this),\n      handleUpEvent: this.onUp.bind(this),\n    });\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.rotateAttribute = options.rotateAttribute || 'ole_rotation';\n\n    /**\n     * Layer for rotation feature.\n     * @type {ol.layer.Vector}\n     * @private\n     */\n    this.rotateLayer = new ol.layer.Vector({\n      source: new ol.source.Vector(),\n      style: (f) => {\n        const rotation = f.get(this.rotateAttribute);\n        return [\n          new ol.style.Style({\n            geometry: new ol.geom.Point(this.center),\n            image: new ol.style.Icon({\n              rotation,\n              src: rotateMapSVG,\n            }),\n          }),\n        ];\n      },\n    });\n  }\n\n  /**\n   * Handle a pointer down event.\n   * @param {ol.MapBrowserEvent} event Down event\n   * @private\n   */\n  onDown(evt) {\n    this.dragging = false;\n    this.feature = this.map.forEachFeatureAtPixel(evt.pixel, (f) => {\n      if (this.source.getFeatures().indexOf(f) > -1) {\n        return f;\n      }\n\n      return null;\n    });\n\n    if (this.center && this.feature) {\n      this.feature.set(\n        this.rotateAttribute,\n        this.feature.get(this.rotateAttribute) || 0,\n      );\n\n      // rotation between clicked coordinate and feature center\n      this.initialRotation =\n        Math.atan2(\n          evt.coordinate[1] - this.center[1],\n          evt.coordinate[0] - this.center[0],\n        ) + this.feature.get(this.rotateAttribute);\n    }\n\n    if (this.feature) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Handle a pointer drag event.\n   * @param {ol.MapBrowserEvent} event Down event\n   * @private\n   */\n  onDrag(evt) {\n    this.dragging = true;\n\n    if (this.feature && this.center) {\n      const rotation = Math.atan2(\n        evt.coordinate[1] - this.center[1],\n        evt.coordinate[0] - this.center[0],\n      );\n\n      const rotationDiff = this.initialRotation - rotation;\n      const geomRotation = rotationDiff - this.feature.get(this.rotateAttribute);\n\n      this.feature.getGeometry().rotate(-geomRotation, this.center);\n      this.rotateFeature.getGeometry().rotate(-geomRotation, this.center);\n\n      this.feature.set(this.rotateAttribute, rotationDiff);\n      this.rotateFeature.set(this.rotateAttribute, rotationDiff);\n    }\n  }\n\n  /**\n   * Handle a pointer up event.\n   * @param {ol.MapBrowserEvent} event Down event\n   * @private\n   */\n  onUp(evt) {\n    if (!this.dragging) {\n      if (this.feature) {\n        this.rotateFeature = this.feature;\n        this.center = evt.coordinate;\n        this.rotateLayer.getSource().clear();\n        this.rotateLayer.getSource().addFeature(this.rotateFeature);\n      } else {\n        this.rotateLayer.getSource().clear();\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc\n   */\n  activate() {\n    this.map.addInteraction(this.pointerInteraction);\n    this.map.addLayer(this.rotateLayer);\n    super.activate();\n  }\n\n  /**\n   * @inheritdoc\n   */\n  deactivate() {\n    this.rotateLayer.getSource().clear();\n    this.map.removeLayer(this.rotateLayer);\n    this.map.removeInteraction(this.pointerInteraction);\n    super.deactivate();\n  }\n}\n\nexport default RotateControl;\n\n\n\n// WEBPACK FOOTER //\n// ./src/control/rotate.js","module.exports = \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiCiAgIHhtbG5zOmlua3NjYXBlPSJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlIgogICB3aWR0aD0iMTEzLjU5MjE5IgogICBoZWlnaHQ9IjExMy45MDgwMiIKICAgaWQ9InN2ZzIiCiAgIHZlcnNpb249IjEuMSIKICAgaW5rc2NhcGU6dmVyc2lvbj0iMC45MSByMTM3MjUiCiAgIGlua3NjYXBlOmV4cG9ydC1maWxlbmFtZT0iL2hvbWUvbWFyaW8vcmVwb3NpdG9yaWVzL29sZTQvaW1nL3JvdGF0ZS5wbmciCiAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIzMS42MDQ0NDUiCiAgIGlua3NjYXBlOmV4cG9ydC15ZHBpPSIzMS42MDQ0NDUiCiAgIHNvZGlwb2RpOmRvY25hbWU9InJvdGF0ZS5zdmciPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0IiAvPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0iYmFzZSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSIyLjgiCiAgICAgaW5rc2NhcGU6Y3g9IjcuMDM0MDQ3OCIKICAgICBpbmtzY2FwZTpjeT0iLTEwLjYyNTkzIgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6c25hcC1ncmlkcz0idHJ1ZSIKICAgICBpbmtzY2FwZTpzbmFwLWNlbnRlcj0idHJ1ZSIKICAgICBpbmtzY2FwZTpzbmFwLW9iamVjdC1taWRwb2ludHM9InRydWUiCiAgICAgaW5rc2NhcGU6c25hcC1iYm94PSJ0cnVlIgogICAgIGZpdC1tYXJnaW4tdG9wPSIwIgogICAgIGZpdC1tYXJnaW4tbGVmdD0iMCIKICAgICBmaXQtbWFyZ2luLXJpZ2h0PSIwIgogICAgIGZpdC1tYXJnaW4tYm90dG9tPSIwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTg2NSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSIxMDU2IgogICAgIGlua3NjYXBlOndpbmRvdy14PSI1NSIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMjQiCiAgICAgaW5rc2NhcGU6d2luZG93LW1heGltaXplZD0iMSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgaWQ9ImdyaWQyOTg1IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIgogICAgICAgc25hcHZpc2libGVncmlkbGluZXNvbmx5PSJ0cnVlIgogICAgICAgb3JpZ2lueD0iLTEyOS42NjgzMyIKICAgICAgIG9yaWdpbnk9Ii04MzYuNzY5NjYiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgICA8ZGM6dGl0bGU+PC9kYzp0aXRsZT4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiCiAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEyOS42NjgzMywtMTAxLjY4NDQ3KSI+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MDtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MTEuNzQ0OTk5ODk7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1kYXNob2Zmc2V0OjA7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMjM3LjM3NzU5LDE2NC43MjcxNCBjIC0xLjM4MTk0LDExLjU2OTA2IC02LjcwNTQ5LDIyLjczMDAzIC0xNS44OTQyNCwzMS4yOTgwMyAtMjAuNjQ4MTEsMTkuMjUzMiAtNTIuOTk0NSwxOC4xMjI0MSAtNzIuMjQ3NjksLTIuNTI1NjkgLTE5LjI1MzIsLTIwLjY0ODEgLTE4LjEyMjQyLC01Mi45OTQ0OSAyLjUyNTY4LC03Mi4yNDc2OSAyMC42NDgxLC0xOS4yNTMyIDUyLjk5NDUsLTE4LjEyMjQxIDcyLjI0NzY5LDIuNTI1NjkiCiAgICAgICBpZD0icGF0aDI5OTQiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjc3NzYyIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo0LjEyNDQ4MTI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMjMzLjA1NTk4LDExNy42MTQ3NyAtMTYuNjM4OTUsMTIuNzc3OTEgMTYuMzA1NjYsNC4wMTAzOCB6IgogICAgICAgaWQ9InBhdGg0NTg4IgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozLjE5OTMzNjUzO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAxODYuNDQwODUsMTQyLjkwNDA0IDAsMTUuNzM0NDQgMTUuNzM0NDQsMCIKICAgICAgIGlkPSJwYXRoNDY3MCIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6My4xOTkzMzY1MztzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMTg2LjQ0MDg1LDE3NC4zNzI5MiAwLC0xNS43MzQ0NCAtMTUuNzM0NDQsMCIKICAgICAgIGlkPSJwYXRoNDY3MiIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjYyIgLz4KICA8L2c+Cjwvc3ZnPgo=\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./img/rotate.svg\n// module id = 124\n// module chunks = 0","module.exports = \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiCiAgIHhtbG5zOmlua3NjYXBlPSJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlIgogICB3aWR0aD0iMTEwLjAwNDY2IgogICBoZWlnaHQ9IjExMC4wMDA1OCIKICAgaWQ9InN2ZzIiCiAgIHZlcnNpb249IjEuMSIKICAgaW5rc2NhcGU6dmVyc2lvbj0iMC45MSByMTM3MjUiCiAgIGlua3NjYXBlOmV4cG9ydC1maWxlbmFtZT0iL2hvbWUvbWFyaW8vcmVwb3NpdG9yaWVzL29sZTQvaW1nL3JvdGF0ZV9tYXAucG5nIgogICBpbmtzY2FwZTpleHBvcnQteGRwaT0iNjMuMDIiCiAgIGlua3NjYXBlOmV4cG9ydC15ZHBpPSI2My4wMiIKICAgc29kaXBvZGk6ZG9jbmFtZT0icm90YXRlX21hcC5zdmciPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0IiAvPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0iYmFzZSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSIxLjk3OTg5OSIKICAgICBpbmtzY2FwZTpjeD0iMTAyLjU3NTU1IgogICAgIGlua3NjYXBlOmN5PSItMjAuNjU2NTY5IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6c25hcC1ncmlkcz0idHJ1ZSIKICAgICBpbmtzY2FwZTpzbmFwLWNlbnRlcj0idHJ1ZSIKICAgICBpbmtzY2FwZTpzbmFwLW9iamVjdC1taWRwb2ludHM9InRydWUiCiAgICAgaW5rc2NhcGU6c25hcC1iYm94PSJ0cnVlIgogICAgIGZpdC1tYXJnaW4tdG9wPSIwIgogICAgIGZpdC1tYXJnaW4tbGVmdD0iMCIKICAgICBmaXQtbWFyZ2luLXJpZ2h0PSIwIgogICAgIGZpdC1tYXJnaW4tYm90dG9tPSIwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTg2NSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSIxMDU2IgogICAgIGlua3NjYXBlOndpbmRvdy14PSI1NSIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMjQiCiAgICAgaW5rc2NhcGU6d2luZG93LW1heGltaXplZD0iMSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgaWQ9ImdyaWQyOTg1IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIgogICAgICAgc25hcHZpc2libGVncmlkbGluZXNvbmx5PSJ0cnVlIgogICAgICAgb3JpZ2lueD0iLTEzMCIKICAgICAgIG9yaWdpbnk9Ii04MzkuOTk5NDMiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgICA8ZGM6dGl0bGU+PC9kYzp0aXRsZT4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiCiAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEzMCwtMTAyLjM2MjEzKSI+CiAgICA8cmVjdAogICAgICAgc3R5bGU9Im9wYWNpdHk6MC4wMTAwMDAwMTtmaWxsOiNmZmZmZjA7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjA7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGlkPSJyZWN0NzQ4NCIKICAgICAgIHdpZHRoPSIxMTAiCiAgICAgICBoZWlnaHQ9IjExMC4wMDAwMiIKICAgICAgIHg9IjEzMCIKICAgICAgIHk9IjEwMi4zNjIxNCIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eTowO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1LjI0NDgxMzkyO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNob2Zmc2V0OjA7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMjM3LjM3NzU5LDE2NC43MjcxNCBjIC0xLjM4MTk0LDExLjU2OTA2IC02LjcwNTQ5LDIyLjczMDAzIC0xNS44OTQyNCwzMS4yOTgwMyAtMjAuNjQ4MTEsMTkuMjUzMiAtNTIuOTk0NSwxOC4xMjI0MSAtNzIuMjQ3NjksLTIuNTI1NjkgLTE5LjI1MzIsLTIwLjY0ODEgLTE4LjEyMjQyLC01Mi45OTQ0OSAyLjUyNTY4LC03Mi4yNDc2OSAyMC42NDgxLC0xOS4yNTMyIDUyLjk5NDUsLTE4LjEyMjQxIDcyLjI0NzY5LDIuNTI1NjkiCiAgICAgICBpZD0icGF0aDI5OTQiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjc3NzYyIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDowLjUyNDQ4MTQycHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMjMzLjA1NTk4LDExNy42MTQ3NyAtMTYuNjM4OTUsMTIuNzc3OTEgMTYuMzA1NjYsNC4wMTAzOCB6IgogICAgICAgaWQ9InBhdGg0NTg4IgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozLjE5OTMzNjUzO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAxODYuNDQwODUsMTQyLjkwNDA0IDAsMTUuNzM0NDQgMTUuNzM0NDQsMCIKICAgICAgIGlkPSJwYXRoNDY3MCIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6My4xOTkzMzY1MztzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMTg2LjQ0MDg1LDE3NC4zNzI5MiAwLC0xNS43MzQ0NCAtMTUuNzM0NDQsMCIKICAgICAgIGlkPSJwYXRoNDY3MiIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjYyIgLz4KICA8L2c+Cjwvc3ZnPgo=\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./img/rotate_map.svg\n// module id = 125\n// module chunks = 0","import Control from './control';\nimport drawPointSVG from '../../img/draw_point.svg';\nimport drawPolygonSVG from '../../img/draw_polygon.svg';\nimport drawLineSVG from '../../img/draw_line.svg';\n\n/**\n * Control for drawing features.\n * @extends {ole.Control}\n * @alias ole.DrawControl\n */\nclass DrawControl extends Control {\n  /**\n   * @param {Object} options Tool options.\n   * @param {string} [type] Geometry type ('Point', 'LineString', 'Polygon',\n   *   'MultiPoint', 'MultiLineString', 'MultiPolygon' or 'Circle').\n   *   Default is 'Point'.\n   */\n  constructor(options) {\n    let image = null;\n\n    switch (options.type) {\n      case 'Polygon':\n        image = drawPolygonSVG;\n        break;\n      case 'LineString':\n        image = drawLineSVG;\n        break;\n      default:\n        image = drawPointSVG;\n    }\n\n    super(Object.assign({\n      title: `Draw ${(options.type || 'Point')}`,\n      className: 'ole-control-draw',\n      image,\n    }, options));\n\n    /**\n     * @type {ol.interaction.Draw}\n     * @private\n     */\n    this.drawInteraction = new ol.interaction.Draw({\n      type: options.type || 'Point',\n      features: options.features,\n      source: options.source,\n    });\n  }\n\n  /**\n   * @inheritdoc\n   */\n  activate() {\n    this.map.addInteraction(this.drawInteraction);\n    super.activate();\n  }\n\n  /**\n   * @inheritdoc\n   */\n  deactivate() {\n    this.map.removeInteraction(this.drawInteraction);\n    super.deactivate();\n  }\n}\n\nexport default DrawControl;\n\n\n\n// WEBPACK FOOTER //\n// ./src/control/draw.js","module.exports = \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiCiAgIHhtbG5zOmlua3NjYXBlPSJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlIgogICB3aWR0aD0iMTIwLjMwMTA5bW0iCiAgIGhlaWdodD0iMTIwbW0iCiAgIHZpZXdCb3g9IjAgMCA0MjYuMjYzNzIgNDI1LjE5Njg4IgogICBpZD0ic3ZnMiIKICAgdmVyc2lvbj0iMS4xIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjkxIHIxMzcyNSIKICAgc29kaXBvZGk6ZG9jbmFtZT0iZHJhd19wb2ludC5zdmciCiAgIGlua3NjYXBlOmV4cG9ydC1maWxlbmFtZT0iL2hvbWUvbWFyaW8vcmVwb3NpdG9yaWVzL29sZTQvaW1nL3JvdGF0ZS5wbmciCiAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIxNi44MTg4NzIiCiAgIGlua3NjYXBlOmV4cG9ydC15ZHBpPSIxNi44MTg4NzIiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0IiAvPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0iYmFzZSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSIwLjk4OTk0OTQ5IgogICAgIGlua3NjYXBlOmN4PSIzODIuMTQ4MDIiCiAgICAgaW5rc2NhcGU6Y3k9IjE2OC44MDk4OSIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIHNob3dndWlkZXM9ImZhbHNlIgogICAgIGZpdC1tYXJnaW4tdG9wPSIwIgogICAgIGZpdC1tYXJnaW4tbGVmdD0iMCIKICAgICBmaXQtbWFyZ2luLXJpZ2h0PSIwIgogICAgIGZpdC1tYXJnaW4tYm90dG9tPSIwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTg2NSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSIxMDU2IgogICAgIGlua3NjYXBlOndpbmRvdy14PSI1NSIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMjQiCiAgICAgaW5rc2NhcGU6d2luZG93LW1heGltaXplZD0iMSIKICAgICBpbmtzY2FwZTpzbmFwLWNlbnRlcj0idHJ1ZSIKICAgICBpbmtzY2FwZTpzbmFwLWdyaWRzPSJmYWxzZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgaWQ9ImdyaWQzMzQwIgogICAgICAgb3JpZ2lueD0iLTE2My43MzYyOSIKICAgICAgIG9yaWdpbnk9Ii0yNjkuODg5ODYiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgICA8ZGM6dGl0bGUgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iRWJlbmUgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiCiAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTE2My43MzYyOSwtMzU3LjI3NTUxKSI+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MzA7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNTMwLjAwMDAzLDY1Ny4zNjIyMiAwLDEyMCIKICAgICAgIGlkPSJwYXRoMzM0NCIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteGRwaT0iMTYiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMTYiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MzA7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNDcwLjAwMDAzLDcxNy4zNjIyMiAxMjAsMCIKICAgICAgIGlkPSJwYXRoMzM0NC0zIgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIxNiIKICAgICAgIGlua3NjYXBlOmV4cG9ydC15ZHBpPSIxNiIgLz4KICAgIDxjaXJjbGUKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI4LjUxMDE4NTI0O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgaWQ9InBhdGg0MTM3IgogICAgICAgY3g9IjMxMS43MjM2MyIKICAgICAgIGN5PSI1NDAuNTQwNzciCiAgICAgICByPSI5Ni42ODY1MzkiIC8+CiAgPC9nPgo8L3N2Zz4K\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./img/draw_point.svg\n// module id = 127\n// module chunks = 0","module.exports = \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiCiAgIHhtbG5zOmlua3NjYXBlPSJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlIgogICB3aWR0aD0iMTIwLjMwMTA5bW0iCiAgIGhlaWdodD0iMTIwbW0iCiAgIHZpZXdCb3g9IjAgMCA0MjYuMjYzNzIgNDI1LjE5Njg4IgogICBpZD0ic3ZnMiIKICAgdmVyc2lvbj0iMS4xIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjkxIHIxMzcyNSIKICAgc29kaXBvZGk6ZG9jbmFtZT0iZHJhd19wb2x5Z29uLnN2ZyIKICAgaW5rc2NhcGU6ZXhwb3J0LWZpbGVuYW1lPSIvaG9tZS9tYXJpby9yZXBvc2l0b3JpZXMvb2xlNC9pbWcvcm90YXRlLnBuZyIKICAgaW5rc2NhcGU6ZXhwb3J0LXhkcGk9IjE2LjgxODg3MiIKICAgaW5rc2NhcGU6ZXhwb3J0LXlkcGk9IjE2LjgxODg3MiI+CiAgPGRlZnMKICAgICBpZD0iZGVmczQiIC8+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjIuOCIKICAgICBpbmtzY2FwZTpjeD0iMzc0LjI0OTAzIgogICAgIGlua3NjYXBlOmN5PSI5LjAyNTk0MyIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIHNob3dndWlkZXM9ImZhbHNlIgogICAgIGZpdC1tYXJnaW4tdG9wPSIwIgogICAgIGZpdC1tYXJnaW4tbGVmdD0iMCIKICAgICBmaXQtbWFyZ2luLXJpZ2h0PSIwIgogICAgIGZpdC1tYXJnaW4tYm90dG9tPSIwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iOTYxIgogICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9IjEwMjgiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjY1IgogICAgIGlua3NjYXBlOndpbmRvdy15PSIyNCIKICAgICBpbmtzY2FwZTp3aW5kb3ctbWF4aW1pemVkPSIwIgogICAgIGlua3NjYXBlOnNuYXAtY2VudGVyPSJ0cnVlIgogICAgIGlua3NjYXBlOnNuYXAtZ3JpZHM9ImZhbHNlIj4KICAgIDxpbmtzY2FwZTpncmlkCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBpZD0iZ3JpZDMzNDAiCiAgICAgICBvcmlnaW54PSItMTYzLjczNjI5IgogICAgICAgb3JpZ2lueT0iLTI2OS44ODk4NiIgLz4KICA8L3NvZGlwb2RpOm5hbWVkdmlldz4KICA8bWV0YWRhdGEKICAgICBpZD0ibWV0YWRhdGE3Ij4KICAgIDxyZGY6UkRGPgogICAgICA8Y2M6V29yawogICAgICAgICByZGY6YWJvdXQ9IiI+CiAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+CiAgICAgICAgPGRjOnR5cGUKICAgICAgICAgICByZGY6cmVzb3VyY2U9Imh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlIiAvPgogICAgICAgIDxkYzp0aXRsZT48L2RjOnRpdGxlPgogICAgICA8L2NjOldvcms+CiAgICA8L3JkZjpSREY+CiAgPC9tZXRhZGF0YT4KICA8ZwogICAgIGlua3NjYXBlOmxhYmVsPSJFYmVuZSAxIgogICAgIGlua3NjYXBlOmdyb3VwbW9kZT0ibGF5ZXIiCiAgICAgaWQ9ImxheWVyMSIKICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTYzLjczNjI5LC0zNTcuMjc1NTEpIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozMDtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSA1MzAuMDAwMDMsNjU3LjM2MjIyIDAsMTIwIgogICAgICAgaWQ9InBhdGgzMzQ0IgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIxNiIKICAgICAgIGlua3NjYXBlOmV4cG9ydC15ZHBpPSIxNiIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyMDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzQwLDc3Mi4zNjIyIDUwOC4yODQyNyw1NjcuOTE1NDkgNDM0LjU0ODI0LDM2OS43MzI3NCAyMzQuMjg1NzEsNDMzLjc5MDc3IDE3My43MzYwMyw1OTQuOTkxNjYgMzQwLDc3Mi4zNjIyIgogICAgICAgaWQ9InBhdGg0MTUwIgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2NjIgogICAgICAgaW5rc2NhcGU6ZXhwb3J0LXhkcGk9IjE2LjgxODg3MiIKICAgICAgIGlua3NjYXBlOmV4cG9ydC15ZHBpPSIxNi44MTg4NzIiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MzA7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNDcwLjAwMDAzLDcxNy4zNjIyMiAxMjAsMCIKICAgICAgIGlkPSJwYXRoMzM0NC0zIgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIxNiIKICAgICAgIGlua3NjYXBlOmV4cG9ydC15ZHBpPSIxNiIgLz4KICA8L2c+Cjwvc3ZnPgo=\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./img/draw_polygon.svg\n// module id = 128\n// module chunks = 0","module.exports = \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiCiAgIHhtbG5zOmlua3NjYXBlPSJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlIgogICB3aWR0aD0iMTIwLjMwMTA5bW0iCiAgIGhlaWdodD0iMTIwbW0iCiAgIHZpZXdCb3g9IjAgMCA0MjYuMjYzNzIgNDI1LjE5Njg4IgogICBpZD0ic3ZnMiIKICAgdmVyc2lvbj0iMS4xIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjkxIHIxMzcyNSIKICAgc29kaXBvZGk6ZG9jbmFtZT0iZHJhd19saW5lLnN2ZyIKICAgaW5rc2NhcGU6ZXhwb3J0LWZpbGVuYW1lPSIvaG9tZS9tYXJpby9yZXBvc2l0b3JpZXMvb2xlNC9pbWcvcm90YXRlLnBuZyIKICAgaW5rc2NhcGU6ZXhwb3J0LXhkcGk9IjE2LjgxODg3MiIKICAgaW5rc2NhcGU6ZXhwb3J0LXlkcGk9IjE2LjgxODg3MiI+CiAgPGRlZnMKICAgICBpZD0iZGVmczQiIC8+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjAuOTg5OTQ5NDkiCiAgICAgaW5rc2NhcGU6Y3g9IjEyNy4yMDM1NiIKICAgICBpbmtzY2FwZTpjeT0iMTY2Ljk1NTEyIgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgc2hvd2d1aWRlcz0iZmFsc2UiCiAgICAgZml0LW1hcmdpbi10b3A9IjAiCiAgICAgZml0LW1hcmdpbi1sZWZ0PSIwIgogICAgIGZpdC1tYXJnaW4tcmlnaHQ9IjAiCiAgICAgZml0LW1hcmdpbi1ib3R0b209IjAiCiAgICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPSI5NjEiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iMTAyOCIKICAgICBpbmtzY2FwZTp3aW5kb3cteD0iNjUiCiAgICAgaW5rc2NhcGU6d2luZG93LXk9IjI0IgogICAgIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9IjAiCiAgICAgaW5rc2NhcGU6c25hcC1jZW50ZXI9InRydWUiCiAgICAgaW5rc2NhcGU6c25hcC1ncmlkcz0idHJ1ZSIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiCiAgICAgaW5rc2NhcGU6YmJveC1ub2Rlcz0idHJ1ZSIKICAgICBpbmtzY2FwZTpzbmFwLWJib3gtZWRnZS1taWRwb2ludHM9InRydWUiCiAgICAgaW5rc2NhcGU6YmJveC1wYXRocz0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgaWQ9ImdyaWQzMzQwIgogICAgICAgb3JpZ2lueD0iLTE2My43MzYyOSIKICAgICAgIG9yaWdpbnk9Ii0yNjkuODg5ODYiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgICA8ZGM6dGl0bGU+PC9kYzp0aXRsZT4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iRWJlbmUgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiCiAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTE2My43MzYyOSwtMzU3LjI3NTUxKSI+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MzA7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNTMwLjAwMDAzLDY1Ny4zNjIyMiAwLDEyMCIKICAgICAgIGlkPSJwYXRoMzM0NCIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteGRwaT0iMTYiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMTYiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjA7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDE4OS40OTIzNiw3NTMuMTI3MjQgMjQxLjYwMzk4LDYzMi41NjUyNiA0MzkuNTk5LDU5OS4wMzczOCA1NTYuNTI0MzksMzgxLjI2MjgzIgogICAgICAgaWQ9InBhdGg0MTUwIgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjYyIKICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIxNi44MTg4NzIiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMTYuODE4ODcyIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjMwO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDQ3MC4wMDAwMyw3MTcuMzYyMjIgMTIwLDAiCiAgICAgICBpZD0icGF0aDMzNDQtMyIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteGRwaT0iMTYiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMTYiIC8+CiAgICA8Y2lyY2xlCiAgICAgICBzdHlsZT0ic3Ryb2tlLXdpZHRoOjMwO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZSIKICAgICAgIGlkPSJwYXRoNDE4NiIKICAgICAgIGN4PSIxOTAuMDAwMDIiCiAgICAgICBjeT0iNzUyLjM2MjI0IgogICAgICAgcj0iMjUiIC8+CiAgICA8Y2lyY2xlCiAgICAgICBzdHlsZT0ic3Ryb2tlLXdpZHRoOjMwO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZSIKICAgICAgIGlkPSJwYXRoNDE4Ni02IgogICAgICAgY3g9IjU1NSIKICAgICAgIGN5PSIzODIuMzYyMjEiCiAgICAgICByPSIyNS4wMDAwMDIiIC8+CiAgPC9nPgo8L3N2Zz4K\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./img/draw_line.svg\n// module id = 129\n// module chunks = 0","import Control from './control';\nimport image from '../../img/move.svg';\n\n/**\n * Control for moving geometries.\n * @extends {ole.Control}\n * @alias ole.MoveControl\n */\nclass MoveControl extends Control {\n  /**\n   * Control for moving geometries,\n   * @param {Object} options Tool options.\n   */\n  constructor(options) {\n    super(Object.assign({\n      title: 'Move geometries',\n      className: 'icon-move',\n      image,\n    }, options));\n\n    /**\n     * @type {ol.Coordinate}\n     * @private\n     */\n    this.coordinate = null;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.cursor = 'pointer';\n    this.previousCursor = null;\n\n    /**\n     * @type {ol.Feature}\n     * @private\n     */\n    this.feature = null;\n\n    /**\n     * @type {ol.interaction.Pointer}\n     * @private\n     */\n    this.pointerInteraction = new ol.interaction.Pointer({\n      handleDownEvent: this.handleDownEvent.bind(this),\n      handleDragEvent: this.handleDragEvent.bind(this),\n      handleMoveEvent: this.handleMoveEvent.bind(this),\n      handleUpEvent: this.handleUpEvent.bind(this),\n    });\n  }\n\n  /**\n   * Handle the down event of the pointer interaction.\n   * @param {ol.MapBrowserEvent} evt Event.\n   * @private\n   */\n  handleDownEvent(evt) {\n    const feature = evt.map.forEachFeatureAtPixel(evt.pixel, (f) => {\n      if (this.source.getFeatures().indexOf(f) > -1) {\n        return f;\n      }\n      return null;\n    });\n\n    if (feature) {\n      if (feature.getGeometry() instanceof ol.geom.Point) {\n        this.coordinate = ol.extent.getCenter(feature\n          .getGeometry().getExtent());\n      } else {\n        this.coordinate = evt.coordinate;\n      }\n\n      this.feature = feature;\n      this.editor.setEditFeature(feature);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Handle the drag event of the pointer interaction.\n   * @param {ol.MapBrowserEvent} evt Event.\n   * @private\n   */\n  handleDragEvent(evt) {\n    const deltaX = evt.coordinate[0] - this.coordinate[0];\n    const deltaY = evt.coordinate[1] - this.coordinate[1];\n\n    this.feature.getGeometry().translate(deltaX, deltaY);\n    this.coordinate = evt.coordinate;\n  }\n\n  /**\n   * Handle the move event of the pointer interaction.\n   * @param {ol.MapBrowserEvent} evt Event.\n   * @private\n   */\n  handleMoveEvent(evt) {\n    if (this.cursor) {\n      const element = evt.map.getTargetElement();\n      const feature = evt.map.forEachFeatureAtPixel(evt.pixel, f => f);\n\n      if (feature) {\n        if (element.style.cursor !== this.cursor) {\n          this.previousCursor = element.style.cursor;\n          element.style.cursor = this.cursor;\n        }\n      } else if (this.previousCursor !== null) {\n        element.style.cursor = this.previousCursor;\n        this.previousCursor = null;\n      }\n    }\n  }\n\n  /**\n   * Handle the up event of the pointer interaction.\n   * @param {ol.MapBrowserEvent} evt Event.\n   * @private\n   */\n  handleUpEvent() {\n    this.coordinate = null;\n    this.feature = null;\n    this.editor.setEditFeature(null);\n    return false;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  activate() {\n    this.map.addInteraction(this.pointerInteraction);\n    super.activate();\n  }\n\n  /**\n   * @inheritdoc\n   */\n  deactivate() {\n    this.map.removeInteraction(this.pointerInteraction);\n    super.deactivate();\n  }\n}\n\nexport default MoveControl;\n\n\n\n// WEBPACK FOOTER //\n// ./src/control/move.js","module.exports = \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiCiAgIHhtbG5zOmlua3NjYXBlPSJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlIgogICB3aWR0aD0iMTQ1LjA0NjQzIgogICBoZWlnaHQ9IjE0NS4wMDQ2NCIKICAgaWQ9InN2ZzIiCiAgIHZlcnNpb249IjEuMSIKICAgaW5rc2NhcGU6dmVyc2lvbj0iMC45MSByMTM3MjUiCiAgIGlua3NjYXBlOmV4cG9ydC1maWxlbmFtZT0iL2hvbWUvbWFyaW8vcmVwb3NpdG9yaWVzL29sZTQvaW1nL3JvdGF0ZS5wbmciCiAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIzMS42MDQ0NDUiCiAgIGlua3NjYXBlOmV4cG9ydC15ZHBpPSIzMS42MDQ0NDUiCiAgIHNvZGlwb2RpOmRvY25hbWU9Im1vdmUuc3ZnIj4KICA8ZGVmcwogICAgIGlkPSJkZWZzNCI+CiAgICA8bWFya2VyCiAgICAgICBpbmtzY2FwZTpzdG9ja2lkPSJUcmlhbmdsZU91dE0iCiAgICAgICBvcmllbnQ9ImF1dG8iCiAgICAgICByZWZZPSIwIgogICAgICAgcmVmWD0iMCIKICAgICAgIGlkPSJUcmlhbmdsZU91dE0iCiAgICAgICBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlkPSJwYXRoMzkzMyIKICAgICAgICAgZD0ibSA1Ljc3LDAgLTguNjUsNSAwLC0xMCA4LjY1LDUgeiIKICAgICAgICAgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxcHQiCiAgICAgICAgIHRyYW5zZm9ybT0ic2NhbGUoMC40LDAuNCkiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+CiAgICA8L21hcmtlcj4KICAgIDxtYXJrZXIKICAgICAgIGlua3NjYXBlOnN0b2NraWQ9IlRyaWFuZ2xlSW5NIgogICAgICAgb3JpZW50PSJhdXRvIgogICAgICAgcmVmWT0iMCIKICAgICAgIHJlZlg9IjAiCiAgICAgICBpZD0iVHJpYW5nbGVJbk0iCiAgICAgICBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlkPSJwYXRoMzkyNCIKICAgICAgICAgZD0ibSA1Ljc3LDAgLTguNjUsNSAwLC0xMCA4LjY1LDUgeiIKICAgICAgICAgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxcHQiCiAgICAgICAgIHRyYW5zZm9ybT0ic2NhbGUoLTAuNCwtMC40KSIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz4KICAgIDwvbWFya2VyPgogICAgPG1hcmtlcgogICAgICAgaW5rc2NhcGU6c3RvY2tpZD0iVHJpYW5nbGVPdXRMIgogICAgICAgb3JpZW50PSJhdXRvIgogICAgICAgcmVmWT0iMCIKICAgICAgIHJlZlg9IjAiCiAgICAgICBpZD0iVHJpYW5nbGVPdXRMIgogICAgICAgc3R5bGU9Im92ZXJmbG93OnZpc2libGUiPgogICAgICA8cGF0aAogICAgICAgICBpZD0icGF0aDM5MzAiCiAgICAgICAgIGQ9Im0gNS43NywwIC04LjY1LDUgMCwtMTAgOC42NSw1IHoiCiAgICAgICAgIHN0eWxlPSJmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MXB0IgogICAgICAgICB0cmFuc2Zvcm09InNjYWxlKDAuOCwwLjgpIgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPgogICAgPC9tYXJrZXI+CiAgICA8bWFya2VyCiAgICAgICBpbmtzY2FwZTpzdG9ja2lkPSJUcmlhbmdsZUluTCIKICAgICAgIG9yaWVudD0iYXV0byIKICAgICAgIHJlZlk9IjAiCiAgICAgICByZWZYPSIwIgogICAgICAgaWQ9IlRyaWFuZ2xlSW5MIgogICAgICAgc3R5bGU9Im92ZXJmbG93OnZpc2libGUiPgogICAgICA8cGF0aAogICAgICAgICBpZD0icGF0aDM5MjEiCiAgICAgICAgIGQ9Im0gNS43NywwIC04LjY1LDUgMCwtMTAgOC42NSw1IHoiCiAgICAgICAgIHN0eWxlPSJmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MXB0IgogICAgICAgICB0cmFuc2Zvcm09InNjYWxlKC0wLjgsLTAuOCkiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+CiAgICA8L21hcmtlcj4KICAgIDxtYXJrZXIKICAgICAgIGlua3NjYXBlOnN0b2NraWQ9IkFycm93MkxzdGFydCIKICAgICAgIG9yaWVudD0iYXV0byIKICAgICAgIHJlZlk9IjAiCiAgICAgICByZWZYPSIwIgogICAgICAgaWQ9IkFycm93MkxzdGFydCIKICAgICAgIHN0eWxlPSJvdmVyZmxvdzp2aXNpYmxlIj4KICAgICAgPHBhdGgKICAgICAgICAgaWQ9InBhdGgzODA2IgogICAgICAgICBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLXdpZHRoOjAuNjI1O3N0cm9rZS1saW5lam9pbjpyb3VuZCIKICAgICAgICAgZD0iTSA4LjcxODU4NzgsNC4wMzM3MzUyIC0yLjIwNzI4OTUsMC4wMTYwMTMyNiA4LjcxODU4ODQsLTQuMDAxNzA3OCBjIC0xLjc0NTQ5ODQsMi4zNzIwNjA5IC0xLjczNTQ0MDgsNS42MTc0NTE5IC02ZS03LDguMDM1NDQzIHoiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuMSwwLDAsMS4xLDEuMSwwKSIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz4KICAgIDwvbWFya2VyPgogICAgPG1hcmtlcgogICAgICAgaW5rc2NhcGU6c3RvY2tpZD0iQXJyb3cxTXN0YXJ0IgogICAgICAgb3JpZW50PSJhdXRvIgogICAgICAgcmVmWT0iMCIKICAgICAgIHJlZlg9IjAiCiAgICAgICBpZD0iQXJyb3cxTXN0YXJ0IgogICAgICAgc3R5bGU9Im92ZXJmbG93OnZpc2libGUiPgogICAgICA8cGF0aAogICAgICAgICBpZD0icGF0aDM3OTQiCiAgICAgICAgIGQ9Ik0gMCwwIDUsLTUgLTEyLjUsMCA1LDUgMCwwIFoiCiAgICAgICAgIHN0eWxlPSJmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MXB0IgogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgwLjQsMCwwLDAuNCw0LDApIgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPgogICAgPC9tYXJrZXI+CiAgPC9kZWZzPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0iYmFzZSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSIzLjk1OTc5OCIKICAgICBpbmtzY2FwZTpjeD0iNzYuMDgxMDE1IgogICAgIGlua3NjYXBlOmN5PSI2NC45Njk1NDMiCiAgICAgaW5rc2NhcGU6ZG9jdW1lbnQtdW5pdHM9InB4IgogICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9ImxheWVyMSIKICAgICBzaG93Z3JpZD0idHJ1ZSIKICAgICBpbmtzY2FwZTpzbmFwLWdyaWRzPSJ0cnVlIgogICAgIGlua3NjYXBlOnNuYXAtY2VudGVyPSJ0cnVlIgogICAgIGlua3NjYXBlOnNuYXAtb2JqZWN0LW1pZHBvaW50cz0idHJ1ZSIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiCiAgICAgZml0LW1hcmdpbi10b3A9IjAiCiAgICAgZml0LW1hcmdpbi1sZWZ0PSIwIgogICAgIGZpdC1tYXJnaW4tcmlnaHQ9IjAiCiAgICAgZml0LW1hcmdpbi1ib3R0b209IjAiCiAgICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPSIxODY1IgogICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9IjEwNTYiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjU1IgogICAgIGlua3NjYXBlOndpbmRvdy15PSIyNCIKICAgICBpbmtzY2FwZTp3aW5kb3ctbWF4aW1pemVkPSIxIj4KICAgIDxpbmtzY2FwZTpncmlkCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBpZD0iZ3JpZDI5ODUiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiCiAgICAgICBzbmFwdmlzaWJsZWdyaWRsaW5lc29ubHk9InRydWUiCiAgICAgICBvcmlnaW54PSItMTEyLjUzOTU1IgogICAgICAgb3JpZ2lueT0iLTgyMi40NTU4MSIgLz4KICA8L3NvZGlwb2RpOm5hbWVkdmlldz4KICA8bWV0YWRhdGEKICAgICBpZD0ibWV0YWRhdGE3Ij4KICAgIDxyZGY6UkRGPgogICAgICA8Y2M6V29yawogICAgICAgICByZGY6YWJvdXQ9IiI+CiAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+CiAgICAgICAgPGRjOnR5cGUKICAgICAgICAgICByZGY6cmVzb3VyY2U9Imh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlIiAvPgogICAgICAgIDxkYzp0aXRsZT48L2RjOnRpdGxlPgogICAgICA8L2NjOldvcms+CiAgICA8L3JkZjpSREY+CiAgPC9tZXRhZGF0YT4KICA8ZwogICAgIGlua3NjYXBlOmxhYmVsPSJMYXllciAxIgogICAgIGlua3NjYXBlOmdyb3VwbW9kZT0ibGF5ZXIiCiAgICAgaWQ9ImxheWVyMSIKICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTEyLjUzOTU1LC04NC45MDE2OTgpIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjE7bWFya2VyLXN0YXJ0OnVybCgjVHJpYW5nbGVJbk0pO21hcmtlci1taWQ6bm9uZTttYXJrZXItZW5kOnVybCgjVHJpYW5nbGVPdXRNKSIKICAgICAgIGQ9Im0gMi4xMDY2MSw1Mi40NTc1OTcgMTAwLjEyNTUzLDAiCiAgICAgICBpZD0icGF0aDMwMTAiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTMyLjg5MzM5LDEwNC45MDQ1NSkiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6ODtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxO21hcmtlci1zdGFydDp1cmwoI1RyaWFuZ2xlSW5NKTttYXJrZXItZW5kOnVybCgjVHJpYW5nbGVPdXRNKSIKICAgICAgIGQ9Im0gNTIuMTA2NjEsMi40NTc1OTY5IDAsMTAwLjA4Mzc0MzEiCiAgICAgICBpZD0icGF0aDMwMTIiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTMyLjg5MzM5LDEwNC45MDQ1NSkiIC8+CiAgICA8Y2lyY2xlCiAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgaWQ9InBhdGgzMDA2IgogICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMC41MjM4MDk0OSwwLDAsMC41MjM4MDk0OSwxNTYuMzk2NTQsMTI4LjU3NDg0KSIKICAgICAgIGN4PSI1NC42MDY2MDkiCiAgICAgICBjeT0iNTQuOTU3NTk2IgogICAgICAgcj0iNTIuNSIgLz4KICAgIDxjaXJjbGUKICAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI3Ljk5OTk5NDI4O3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBpZD0icGF0aDMwMDYtMyIKICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAuMjg1NzE0MzUsMCwwLDAuMjg1NzE0MzUsMTY5LjM5ODExLDE0MS42NTk5NykiCiAgICAgICBjeD0iNTQuNjA2NjA5IgogICAgICAgY3k9IjU0Ljk1NzU5NiIKICAgICAgIHI9IjUyLjUiIC8+CiAgPC9nPgo8L3N2Zz4K\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./img/move.svg\n// module id = 131\n// module chunks = 0","import Control from './control';\nimport image from '../../img/modify_geometry.svg';\n\n/**\n * Control for modifying geometries.\n * @extends {ole.Control}\n * @alias ole.ModifyControl\n */\nclass ModifyControl extends Control {\n  /**\n   * @param {Object} options Tool options.\n   * @param {string} [type] Geometry type ('Point', 'LineString', 'Polygon',\n   *   'MultiPoint', 'MultiLineString', 'MultiPolygon' or 'Circle').\n   *   Default is 'Point'.\n   * @param {ol.Collection<ol.Feature>} [features] Destination for drawing.\n   * @param {ol.source.Vector} [source] Destination for drawing.\n   */\n  constructor(options) {\n    super(Object.assign({\n      title: 'Modify geometry',\n      className: 'ole-control-modify',\n      image,\n    }, options));\n\n    /**\n     * @type {ol.interaction.Select}\n     * @private\n     */\n    this.selectInteraction = new ol.interaction.Select({\n      source: this.source,\n      features: this.features,\n    });\n\n    /**\n     * @type {ol.interaction.Modify}\n     * @private\n     */\n    this.modifyInteraction = new ol.interaction.Modify({\n      features: this.selectInteraction.getFeatures(),\n    });\n  }\n\n  /**\n   * @inheritdoc\n   */\n  activate() {\n    this.map.addInteraction(this.selectInteraction);\n    this.map.addInteraction(this.modifyInteraction);\n    super.activate();\n  }\n\n  /**\n   * @inheritdoc\n   */\n  deactivate() {\n    this.map.removeInteraction(this.selectInteraction);\n    this.map.removeInteraction(this.modifyInteraction);\n    super.deactivate();\n  }\n}\n\nexport default ModifyControl;\n\n\n\n// WEBPACK FOOTER //\n// ./src/control/modify.js","module.exports = \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0NTQuNjgxIiBoZWlnaHQ9IjEyMG1tIiB2aWV3Qm94PSIwIDAgNDI2LjI2NCA0MjUuMTk3Ij48cGF0aCBkPSJNMTg0LjEyIDQwNC4zNzJMMzIwLjkwOCA5Ny42NjdsLTUwLjA5NS04NS4yMUw3MC41NDkgNzYuNTE1IDEwIDIzNy43MTZsMTc0LjEyMiAxNjYuNjU2IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMjAiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjxwYXRoIHN0eWxlPSJsaW5lLWhlaWdodDpub3JtYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBY3F1YWludGFuY2U7dGV4dC1pbmRlbnQ6MDt0ZXh0LWFsaWduOnN0YXJ0O3RleHQtZGVjb3JhdGlvbi1saW5lOm5vbmU7dGV4dC10cmFuc2Zvcm06bm9uZTtibG9jay1wcm9ncmVzc2lvbjp0YjttYXJrZXI6bm9uZSIgZD0iTTMwNS4yMjQgMjAyLjQ1N2MtLjA0NiAyLjk0My0uMDYgNS44ODMtLjA4MiA4LjgyOGwtLjAxNiAxLjIzOC0xLjIzOC4wNDljLTIuOTM3LjA5Ni01Ljg4OC4xMy04Ljg0NC4xNDYtLjE2IDI5LjkwNS0uMDcyIDU5Ljc5Ny0uMDgyIDg5LjY5NnYxLjI4NmwtMS4yODYuMDE3Yy0yLjQ4Mi4wMjYtNC45OC4wNDktNy40NzYuMTE0bC0xLjM1Mi4wMzIuMDE2LTEuMzUyYy4wNTEtMi45MjIuMDMtNS44NDEtLjAzMi04Ljc0Ni0xMC4xNDQtLjA4NS0yMC4yOTgtLjEzNy0zMC40NDIuMDMzLjAxMyAxMC4xMDQtLjAyIDIwLjIwNiAwIDMwLjMxIDIuOTQuMDU3IDUuOTE2LjE5NSA4Ljg5My0uMDE2bDEuNjI5LS4xMTQtLjI0NCAxLjYxM2MtLjQyNiAyLjkxOC0uMTQyIDUuODctLjEzIDguNzk1IDIuODA2LjE0NyA1LjYzMi4xNzUgOC40NjkuMThoMS4yMDVsLjA5OCAxLjIwNGMuNDcgNi4yNDcuMjM4IDEyLjUyLjM0MiAxOC43OTYgMi45MTUuMTIgNS44NS4xNjcgOC43NzkuMTk2bDEuMjcuMDE2LjAxNyAxLjI3Yy4wNDcgNi4yNjcuMDMyIDEyLjUzLjEzIDE4Ljc5NiAyLjk0Mi4wNDcgNS45MDUuMTk2IDguODc3LjAxN2wxLjQ5OC0uMDgyLS4xMTQgMS40ODJjLS40OTUgNi4yNjQtLjA2NiAxMi41OC0uMTE0IDE4Ljg2MSAyLjg2Ni4wNTcgNS43MjguMDk3IDguNi4xMTRoMS4yODdsLjAxNiAxLjI4N2MuMTI2IDkuNjc2LjA2NCAxOS4zNi4xOTUgMjkuMDQgMTYuNzA1LjI0MiAzMy40MjIuMjY0IDUwLjEzMy4yNDUgMTcuMTA5LS4wMjYgMzQuMjE0LjExNyA1MS4zMjItLjI5My0uMjczLTkuNjUyLjU5MS0xOS4yOTkuMTk2LTI4Ljk0M2wtLjA1LTEuMzg1IDEuMzg1LjAzM2MyLjg3Mi4wOCA1Ljc0OC4wMjQgOC42LS4wNjUuMTA2LTkuNi4xMTgtMTkuMjEzLjEzLTI4LjgxM3YtMS4xODlsMS4xNzMtLjExNGMyLjkxNi0uMjc5IDUuODU3LS4zIDguODEyLS4yNzcuMDcxLTEwLjc1Mi0uMTMtMjEuNDk3LjE5NS0zMi4yNDl2LS4wNjVjLS4zNTctMTIuOTE1LS4xMDQtMjUuODQzLS4yNi0zOC43NjRhMzg4LjAxIDM4OC4wMSAwIDAgMS04LjY2NS0uMDVsLTEuMjU1LS4wMTYtLjAzMi0xLjI1NGMtLjA1OC0yLjg1LS4wOTUtNS43MTYtLjA0OS04LjU4My0yLjk3NC0uMDg3LTUuOTI5LjAwNi04Ljg3Ny0uMTYzbC0xLjE0LS4wNjUtLjA4MS0xLjE0Yy0uMjEtMi45NjMtLjEwNi01Ljk1Ni0uMTQ3LTguOTU5LTYuMzAzLS4wMjQtMTIuNjAxLjAyNy0xOC44OTMtLjA2NWwtMS4yNy0uMDE2LS4wMTctMS4yN2MtLjA0OS0yLjg0Ni0uMDgzLTUuNjkyLS4wNDktOC41NTEtOS42Ny0uNTEyLTE5LjM2Ni0uMTgxLTI5LjA0LS4yOTRsLTEuMjM4LS4wMTYtLjA1LTEuMjIyYy0uMTMyLTIuOTMtLjE4NS01Ljg2OC0uMTc4LTguODI3LTYuMjkxLS4wMy0xMi41OC4wMi0xOC44NjEtLjExNGwtMS4yNTUtLjAzMy0uMDE2LTEuMjU0Yy0uMTI0LTEzLjAxNy0uMDUzLTI2LjAzOS0uMDk4LTM5LjA1OGE2NDguNDUgNjQ4LjQ1IDAgMCAwLTUuMDMzLS4wMzJjLTEuMjUtLjAwMi0yLjQ5Ni4wMDMtMy43NDYuMDE2bC0xLjMzNS4wMTcuMDE2LTEuMzM2Yy4wNDUtMi45ODguMDQtNS45NzctLjI0NC04Ljk0Mi02LjY1Mi4wMi0xMy4zLjA0LTE5Ljk1MiAweiIgY29sb3I9IiMwMDAiIGZvbnQtd2VpZ2h0PSI0MDAiIGZvbnQtZmFtaWx5PSJBY3F1YWludGFuY2UiIG92ZXJmbG93PSJ2aXNpYmxlIiBmaWxsPSIjZmZmIi8+PHBhdGggZD0iTTMwNS4yNDMgMjAyLjM2YzYuNjUyLjAzOSAxMy4zMDQuMDI2IDE5Ljk1Ni4wMDYuMzE5IDMuMzM2LjMwNiA2LjY5LjI0IDEwLjAzMy02Ljc2Mi4wNjUtMTMuNTE4LS4wMi0yMC4yOC4wNjUuMDI2LTMuMzY4LjAzMi02LjczNi4wODQtMTAuMTA1ek0yOTUuMDY3IDIxMi42MmMzLjM2Mi0uMDE5IDYuNzMtLjAxMiAxMC4wOTItLjE1Ni4wMDYgMzcuMTk0LjA2NSA3NC4zODkuMDI2IDExMS41ODMtMy4zODguMDc4LTYuNzc2LjA3OC0xMC4xNjQuMDA2YTMwMC43NSAzMDAuNzUgMCAwIDEtLjAyLTEwYy0zLjM2OC0uMTMtNi43MzYtLjExMS0xMC4xMDQtLjA5OC0uMTEtMy40LS4xMzctNi44MDgtLjAwNy0xMC4yMDkgMy4zNjItLjEyNCA2LjczLS4wODUgMTAuMDk5LS4xMzcuMDEzLTMwLjMyNy0uMDg1LTYwLjY1NS4wNzgtOTAuOTg4ek0zMjUuNDc5IDIxMi42MzRjMy4zNTUtLjA0NiA2LjcxLS4wMjYgMTAuMDY2LjAwNi4wNDUgMTMuNDQ3LS4wNDYgMjYuOS4wOTcgNDAuMzQ4IDYuNzEuMTc1IDEzLjQyMS4wNzggMjAuMTMyLjExLS4wMDcgMy4zNTYgMCA2LjcxLjE5NSAxMC4wNjYgMTAuMDk4LjE2MyAyMC4yMTYtLjI0MSAzMC4zMDguMjkzLS4wNCAzLjI3Ny0uMDIgNi41NTQuMDUyIDkuODMxIDYuNzIzLjEyNCAxMy40NTMuMDQ2IDIwLjE4My4wNzIuMDQ2IDMuMzY4LS4xNjkgNi43NTYuMTkgMTAuMTExIDMuMzQyLjI5MyA2LjY5Ny4xMTggMTAuMDQ2LjIxNS0uMDUzIDMuMjg0LS4wMjcgNi41NjcuMDU4IDkuODUxIDMuMzEuMDU5IDYuNjI2LjA4NSA5Ljk0OS4wNTkuMTU2IDEyLjkzMi0uMDk4IDI1Ljg2NC4yNiAzOC43OS0uMzI2IDEwLjc2My0uMTMgMjEuNTI2LS4yMDIgMzIuMjg4LTMuMzM2LS4wMjYtNi42NzEtLjAzOS05Ljk4LjM3Mi0uMDE0IDEwLS4wMiAyMC4wMDctLjEzMSAzMC4wMDgtMy4zMjMuMTA0LTYuNjUyLjIxNS05Ljk2OC4wNTItLjM3OC0xMC4xNzctLjIwMi0yMC4zNjYtLjEwNC0zMC41NDkgMy4zNDIuMDMzIDYuNjkuMDMzIDEwLjA0LjAwNi4wMDYtMjMuNjQ5LjAyNS00Ny4yOTIuMDM4LTcwLjk0MS0zLjM0Mi0uMDQ2LTYuNjg0LS4wNC0xMC4wMjYgMC0uMTktMy4yOS4wMjYtNi42LS4yNDEtOS44ODQtMy4zMTYtLjYzOC02LjcwNC0uMjQ3LTEwLjA1My0uMjYtLjA3MiAxMC4xNDQuMTE3IDIwLjI4Ny0uMDg1IDMwLjQzOC0zLjMxLjAwNi02LjYyNS4wMDYtOS45MzUuMDEzLS4yMjgtMTMuNTMyLjAwNi0yNy4wNjQtLjA3OC00MC41OTUtNi43ODItLjA0LTEzLjU2NC0uMDItMjAuMzQgMCAwIDEwLjEzNy4xMDQgMjAuMjc1LS4wMTMgMzAuNDA1LTMuMzYyLjA3Mi02LjcxNy4wNzItMTAuMDcyLjAwNy0uMDY1LTEzLjUxOS0uMDc4LTI3LjA0NC4wODQtNDAuNTYzLTYuNzg4LS4wMzItMTMuNTctLjAzOS0yMC4zNTkuMDQtLjA3MiAxMy41MDUuMDUyIDI3LjAxIDAgNDAuNTE2LTMuMzk0LjA5OC02Ljc5NS4xMDQtMTAuMTkuMDA3IDAtMzAuMzY3LjAyLTYwLjc0LjA3OS05MS4xMTN6IiBmaWxsPSIjMWMxYzFjIi8+PHBhdGggZD0iTTI1NC40MiAyOTMuN2MxMC4xNDQtLjE3IDIwLjI5NC0uMTE3IDMwLjQzOC0uMDMzLjA3MSAzLjM2Mi4xMyA2LjcxNy4wMzIgMTAuMDgtNi43My4xNTUtMTMuNDYuMDM4LTIwLjE4My4wOS0uMjQ4IDYuNjk4LjM1OCAxMy40MTUtLjA5OCAyMC4xMDYtMy4zODguMzktNi44MDIuMTMtMTAuMTk2LjA2NS0uMDItMTAuMTA1LjAyLTIwLjIwMy4wMDctMzAuMzA4ek0yNjQuODgzIDMyNC4xN2MzLjI1Ny0uNTAxIDYuNTY3LS4zMTIgOS44NS0uMjIuMDcyIDMuMzguMDc5IDYuNzY4LjA0NiAxMC4xNTYgMy4zODguMDIgNi43Ny4wMTMgMTAuMTU3LjA1OS4wNzggNi43NDMgMCAxMy40ODYuMDM5IDIwLjIyOSAzLjM0Mi0uMDIgNi42OS0uMDEzIDEwLjA0LjAzMi0uMDQ2IDYuNzYzLjQzNiAxMy41NzctLjI1NCAyMC4zMDctMy4yOTcuMy02LjYuMDY2LTkuODkuMDE0LS4xMDQtNi42ODUtLjA5MS0xMy4zNy0uMTUtMjAuMDU0LTMuMzQ5LS4wMi02LjY5OC0uMDc4LTEwLjA0Ni0uMjE1LS4xMTEtNi42NTguMjE1LTEzLjMzLS4zOTEtMTkuOTY4LTMuMjM4LjAxMy02LjQ4My0uMDQ2LTkuNzE0LS4yMTUtLjAxMy0zLjM3NS0uNDU2LTYuODAyLjMxMy0xMC4xMjR6TTI5NS4yMjMgMzc0Ljc4YzMuMzEtLjI2MSA2LjYzOS0uMTA1IDkuOTYyLS4wODYuMDkgNi43My4wMDYgMTMuNDYuMDI2IDIwLjE4NCAzLjM3NC0uMDEzIDYuNzYyLS4wMTMgMTAuMTQ0LjEwNC4wNjUgNi43My0uMDYgMTMuNDY3LjAzOSAyMC4xOTcgMjYuOTc4LjA2NSA1My45NTcuMDUyIDgwLjkzNS4wMzkuMTA1LTYuNzM3LS4wMjYtMTMuNDczLjA0Ni0yMC4yMTYgMy40NTMtLjA0NiA2LjkwNi0uMDkyIDEwLjM1OS4xMDQuNTQ3IDEwLjA5OC0uNDQzIDIwLjIwMy0uMTU2IDMwLjMxNC0xNy4xMDkuNDEtMzQuMjE3LjI2LTUxLjMyNi4yODctMTYuNzEuMDItMzMuNDIyIDAtNTAuMTI2LS4yNDEtLjEzNy0xMC4xMDUtLjA2NS0yMC4yMS0uMjE1LTMwLjMwOGE1NTQuOTQzIDU1NC45NDMgMCAwIDEtOS44OS0uMTI0Yy4wNTItNi43NS0uNDg5LTEzLjU0NC4yMDItMjAuMjU1eiIgZmlsbD0iIzFjMWMxYyIvPjwvc3ZnPg==\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./img/modify_geometry.svg\n// module id = 133\n// module chunks = 0","import Control from './control';\nimport delSVG from '../../img/delete.svg';\n\n/**\n * Control for deleting geometries.\n * @extends {ole.Control}\n * @alias ole.DeleteControl\n */\nclass DeleteControl extends Control {\n  /**\n   * @inheritdoc\n   * @prram {Object} [options] Control options.\n   * @param {ol.source.Vector} [source] vector to delete.\n   * @param {boolean} [multi] select multiple if set to true\n   *   (default is false).\n   */\n  constructor(options) {\n    super(Object.assign({\n      title: 'Delete geometry',\n      className: 'ole-control-delete',\n      image: delSVG,\n    }, options));\n\n    /**\n     * @type {ol.interaction.Select}\n     * @private\n     */\n    this.selectInteraction = new ol.interaction.Select({\n      source: this.source,\n      multi: options.multi || false,\n    });\n\n    /**\n     * Select Interaction to clear and remove features\n     * @private\n     */\n    this.selectInteraction.on('select', (evt) => {\n      evt.selected.forEach((f) => {\n        this.source.removeFeature(f);\n        this.selectInteraction.getFeatures().clear();\n      });\n    });\n  }\n\n  /**\n   * @inheritdoc\n   */\n  activate() {\n    this.map.addInteraction(this.selectInteraction);\n    super.activate();\n  }\n\n  /**\n   * @inheritdoc\n   */\n  deactivate() {\n    this.map.removeInteraction(this.selectInteraction);\n    super.deactivate();\n  }\n}\n\nexport default DeleteControl;\n\n\n\n// WEBPACK FOOTER //\n// ./src/control/delete.js","module.exports = \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIKICAgeG1sbnM6c29kaXBvZGk9Imh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgaWQ9InN2ZzM3MjMiCiAgIHZlcnNpb249IjEuMSIKICAgaW5rc2NhcGU6dmVyc2lvbj0iMC45MSByMTM3MjUiCiAgIHdpZHRoPSIxODcuNSIKICAgaGVpZ2h0PSIxODcuNSIKICAgdmlld0JveD0iMCAwIDE4Ny41IDE4Ny41IgogICBzb2RpcG9kaTpkb2NuYW1lPSJkZWxldGUuc3ZnIj4KICA8bWV0YWRhdGEKICAgICBpZD0ibWV0YWRhdGEzNzI5Ij4KICAgIDxyZGY6UkRGPgogICAgICA8Y2M6V29yawogICAgICAgICByZGY6YWJvdXQ9IiI+CiAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+CiAgICAgICAgPGRjOnR5cGUKICAgICAgICAgICByZGY6cmVzb3VyY2U9Imh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlIiAvPgogICAgICAgIDxkYzp0aXRsZT48L2RjOnRpdGxlPgogICAgICA8L2NjOldvcms+CiAgICA8L3JkZjpSREY+CiAgPC9tZXRhZGF0YT4KICA8ZGVmcwogICAgIGlkPSJkZWZzMzcyNyIgLz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEiCiAgICAgb2JqZWN0dG9sZXJhbmNlPSIxMCIKICAgICBncmlkdG9sZXJhbmNlPSIxMCIKICAgICBndWlkZXRvbGVyYW5jZT0iMTAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjE4NjUiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iMTA1NiIKICAgICBpZD0ibmFtZWR2aWV3MzcyNSIKICAgICBzaG93Z3JpZD0iZmFsc2UiCiAgICAgaW5rc2NhcGU6em9vbT0iMC45Nzk1Nzg2IgogICAgIGlua3NjYXBlOmN4PSI3Ny41NTMwMDUiCiAgICAgaW5rc2NhcGU6Y3k9Ii0xNTUuMzYzODYiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjU1IgogICAgIGlua3NjYXBlOndpbmRvdy15PSIyNCIKICAgICBpbmtzY2FwZTp3aW5kb3ctbWF4aW1pemVkPSIxIgogICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9InN2ZzM3MjMiCiAgICAgZml0LW1hcmdpbi10b3A9IjAiCiAgICAgZml0LW1hcmdpbi1sZWZ0PSIwIgogICAgIGZpdC1tYXJnaW4tcmlnaHQ9IjAiCiAgICAgZml0LW1hcmdpbi1ib3R0b209IjAiIC8+CiAgPGltYWdlCiAgICAgd2lkdGg9IjE4Ny41IgogICAgIGhlaWdodD0iMTg3LjUiCiAgICAgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIKICAgICB4bGluazpocmVmPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUpZQUFBQ1dDQVlBQUFBOEFYSGlBQUFBQm1KTFIwUUEvd0QvQVArZ3ZhZVRBQUFBQ1hCSSBXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUFCM1JKVFVVSDRRY0tEQ1VDdzdZV1hBQUFEbEZKUkVGVWVOcnRuV3VNbHNVVngzL0FYZ1FWIFhGYnVWZ0VSRVFTcGlZblZZUEZTNVdhcVRkdkVnT0l0dmRoR0E2eTJNYTAzcEcyTXFiV2ZhaFVFUmFrVXJHQzlvU0MyYXNWcXJJaGkgRzBXYkttaFd0Qmh4MlYxZysySG1UVGNMNzF5ZTk3bk16RFAvWk1LSDVYbWVNK2VjZC80elo4NmNnWWlJaUlpSWlGS2pWMG43M1FnYyBJbHRmWURRd0RqZ2UrQW93RkJnR05NdS8xL1Y0ZmkvUUJ1d0VkZ0FmQWY4Qi9nbHNCZDZUZjk4alczdDBySEQ3T1FrNEVaZ0FqSkhPIGRDeHdSRWJmL0F6WUJyd0x2QU84QmJ3aFcxY2MwL3pHaGNERGNsVDVUSTRjWFFXMWRpbkREbUExY0VFMGp6LzBOaGlZQVR4ZW9BUFogdHNlQTZWTDJobWhHZDlBRXpBVld5TGxPbDZmdEkrQkI0SklNNlRuQ0FDT0FKVUFyME9HeFEvVnNIYkpQOThnRlJFUU9hSkFUN21VQiBPWkt1M1NzWEdsN1JwRStyd3BuQTVjQzNNbHpGN1FBK0JuYko5cm1jZEhmS0VBTXk5RkF2NTNUOWdRR3lEWkZoaW9FWnliY2FXQXc4IEVSMHJIVXdHN3BaaGdyNHB2Zk5MNERuZ1JlQUZHUkpvbHpSVWNhSjk4dDh1aGU3cWdEN2RuSzFCT3R3WTRIVGdOT0RyS2NyZEpzTVYgVjhwL0l4SmdJUENiRktoa3Q1d1lid0N1bGxTYU44YkliejhyWmRtZFFyOXVsd3VYQ0VQMEFWb2tKZFdpK0w4Q3R3RFRNcVNucEQrWSA2Y0JDNFBrYSs3Z0RtQS8wam02anhpVGdiV0IvUWtYdkFXNEFSZ0tIZTlEZnc0RlJ3RTBrRDk3dVIwVDF4MGYzT1JEOWdHc1RLdlpMIDRIVVovL0VkbHdLYlpaK1M2R0oraXZNNTczR3lYT2trY2FpbGt1cEN3d3daVW1sTG9KYy9BeWVWM2FubUlqSUViSlczWE1aMjZnTFcgVFoxY2FLeElvSjlXWUhZWkhhb1IrS21sc2pxQmx4RHBMV1hEZUdDVDFJR056bG9vMGY3akNPQlJTd1c5WE5aZllJKzQyY1hBSzVhNiBXME1KdG9hR0lwTGhiQlR6YytLbWJIYzBBVGRiNm5Bck1DaFVoWnhvdWRyWkJudzErbEZWbkFLOGoxMmdPTGlReERUZ0MreWl5bkhaIGJCYW11Y05DcjU4RDU0YlMrVE1SZ1V2VGxKSFRLRzh1ZnRLNTF4VCt2NitwYTIySS9VdnZuY3IwMS9SYXlQT0FuT2F2bXkzMDdhMXogVGJNWXFaYkZDWHBxRS92N01ROHdlMGVMSjFyTXFSWWdOcDRqMGtFZGNKM0ZuT3NFbjRaa2s2MklkbUJlOUlQTXNBQ3psTzB2ZkppQyBqTUE4VHZXRGFQdk1jWldoTGQ3QzRTQnFJK1lSOWVuUjVybGhocUZOSHNIUjdSK1R2Yi8yT0ZJVk5uS1owR0tMYTRMUE5meFZ4RGxWIGNXZ3h0TkVjVndRK0diUFVsd1hSdG9YRFpMWFlpZ1A1WFAwd1M5SmJGa01Lem9RaWxtTjI3TC9RTFRXVGRPSi9FSU9mTHFFSnN3ajkgL0tJRW5HUTRXWS9iTk81aEtHWkpnN2xuUS9SQm5LYlJDWFphdEtHem1JSlpmQ3ZYbzJVdDZJOW8zVTdNVW5BWnZkQ24zT3pMY3lVLyBFUDFoMG0zRWZDb2YwQTlSMWxKbHkrM2tkT0xhNU5oN3pQejBCNmNZMlBPMnJJV1lqRm1PZW9SZk1NbWhuNWlsQUg5SGY1b21oaGI4IERFRzhxckh0UzFsOWZDYnF3eENkeENOYVB1TVNUUWhpTnhtY09tOUVGUDRxeEtNamNsc2x2cXl4OFVwU3pvQTQxb0NEaXppaFBGYU8gcE1NRE12QlJ3Q3pndUFLK1BjSEF6cVBTL0tDdTV1Y0RCY3dKMXZTUVlZa2NXWDFGSXdmbXE2OHVZTTY2VW1QcnhXbDlhQVQ2cFB6UiBPWGQrVFJWWm5zR3RJbXVtYUVaVSt6dFluMWJsTE1zWTlLbmxxV1NiTHRGOFpDbjVWbjBacTVIbkdVUTlVRjlRcjNDcVRPaEhnenJnIFBvMDh2MCtEY2xvMW8xWGU5YWxtR3N3RG52TEV1ZXFCOVFiOU9hOEFIYXNpQUsySWl0R0pNUmQxU3V2ckJSaGpPR2Faa0s3VFlyUEIgU0ZWcGd3dVFUNVZhMDRHb2ZKTjRNcWtyK2xWVWVjWWxGczVWNytoSVplcFV2eXRJeHNzTUZteUpRZytEVWQ5TnM2ZmdGZFF6aG9aeCBqUlpONmE4TFdGZndTbGZGVnR0Sm1HdW5PelowZ3dOVXN0NWk1R3IyalA3V1VYd2RkOTBlWXFLNW4rNXF0cEdPL1ByWEdScHFmY0VqIGx3MzlQZTdJS0R0S0krZWpTVjZxSzg3dlNoMTFXMnFwanpJYTQzREVsVEFxZWExd29lWmx0emk0d2xwdk1YSTE1eXliVC9UWEU3ZHEgWkQ3ZjVtVVBrL011ZDZDMDZDUDkyY2EwVnBxK3FCZmlqaGJWVGFDdXhvZGNvaHdiV1o3RzNZRHVrYWhUMGJlYnZ1Z2t4TjE5MVY2MCBBYmZSTEdVME1laUdqR2pSaHY2ZXh2Mzl6WTBLK1Q5RjFFUFRZamJxQzRPdXhuM1VTNE9aT2xkOXl0LzJuZjU2WWg3cXM2TVhtYnprIEZ4cGxISXNmcUxjWXVkS2lvbERvcnllTzEvVGxWdDBMR2xIbjQrekdMK1JKaTZIUlgwK29KdkIvUUxPOU13RDFsUnFQNHgveW9NVVEgNmE4bm5rUjlpR2FBNnVFaG1vbjd6L0FUV2RKaXFQVFhFemNxK3ZVSm1nd01YUWovVFB4RkZyUVlPdjExeHptYS9oMmpldmdzemNOSCA0emZxTWMrSzBOR2lEZjA5NGZGSVZjSFJtajZlb1hyNEtrMjhZZ2ordzRZV3ErVnpsWVgrYktaSjMxYzlmS2Zpd1RkeGJ4K3JDRm9zIEUvMTFSeE9pckZHMXZ0NmhldmhoallJUEl4elkwbUtEYkdXaXYrNDRUTlAzUDZvZWZsSHg0SitBUXdnTE5yVDRLT0lpYjU5VG9tdkIgSVloYThLcFVxcXBRMVVwYUdxQ3liS2t0aEVNY3Rmd0lWUWVYMytuK24zc2ZSTW5WOERuaVRyelFzQk54QzFZYW0rdFBJVzdkK0RSQSBQZTJUUGxBTlI2b2NTMVdGcjdJeEhTSTZFVGxtRzJ0NHgzcEUwbHRub0RyYUwzMmdHdnFxSEt0T28veVEwUWw4TzZGenJRZStXeElkIFZVT0R5ckZVMkV2NDJJazRlZktZeFROckVDZWFQaTJCZm94L09MMkppTWdBTm81VlZ3SjlOTXNKK0V5TFo3Nkp5RmdZV0FMOTFDZDEgckwxcHZOUmpwYTBDcGlaNDlteEVIbHQ5aVIyclErVlliWW9IR3duM1FvQjZSTDdSMUJyZWNUWWlnQnFxYy9WR2ZkeS9UZVZZT3hVUCA5ZytVRHBzUkozYk9TdUZkNXlLMmNrS2t4VDZvay9rK1VUbldEc1dEQXdqdmFqZ2IrbHNqVzFscHNRL3FtbGdxM3luZEpyUk5VWkhLIEpyVHB4dlU2d3R1RTNrakNUZWd5cGMwOFM3Szl2NEVXenBYM2NmNHMwUVJzSldIYWpDclJieWZoSlBxWk90V1RWRS8wZXdvL3F0eWsgQlYyaTMvZFVENTlKK0tuSk52U25TMDB1RXkwZVF3MnB5U00xRDUvbHNXSnFvYjlxS0JNdGZvTWFEbE1NUWV4NWhYYXpWNVlISDhwQyBpemRSdy9FdjNZSFZKd0tudjZRSEgyeG8wZGZERmFvZnp5Wk5LSUpHNENIVWRkMURwYjlhRHo3WTBHSldWVzZ5aE9xMmloVVlWRkJlIHBGSEttRWgvcWREaUJvOUdybkhVV0JRRXdpbGpWTlM1dnhCcGNUNHBsREdhcElsWFBCdnByM1MwK0J3cEZGN3p2VlNrSzFWZlFxSEYgUWFSVUtoTFV0Nm51UnB4RWlmU1hMaTI2ZWhaUlY5ejJJWnVYWGFCUndzSklmNldoUmQxaWJwYnRDMVV2ZXg2M0xoQnd2ZWlacjdUWSBIL1hwK0VUSEFSL0RuY3NaZmFLL2tHaHh0RWJPdFVsZXFydWs2VWFQNkcrZEl3c08zMmh4SVJsYzBxUzdWcTY5d0E0MzRtL05UMXRhIExQSmF1VTZGYkIrUzhGcTVCdUJCVGNjdkxhakQ5K04zdW9vTkxTNHRTTVlyTkhMZFQ4S0xNRUhjb0txNkRIRnpBUjAreXNLcFhNNTQgdGFIRjRRWEk5d2JxcTN0bjEvTHlJOUJmTmo0ajV3N1BJcHlTMTZhME9MTUFIYXMybld1K2JCemdIazJubDVIdnNiRGpDQ3RiMDRRVyBSK2NvVHgyd1hDUFBYV2w4YUpqbUkyM2tmdzNLYWsvcEx3a3Ryc3BabHJHSSs3NVZOaCthMXNmdTFYeG9SYzZkUDRJRGo2cmRYY3RrIDBnRTBIa1RQcTJSZjg4UXFqYTN2eVROUTFnV01MeWlBTnkzTlg1QURHQ2I3VkVRQWVwS0JuVWVtK2NFR0EwL2VSTGkxSGNxQTNxalQgMGlzYnpxbXp3blRVdTl5ZHdKeG9IMjl4S2VxQTZHNUViWXBNc0VuajBhOFVNQ2VJU0dmeDhKckd0aTltS2NCRUF3NitLZHJKT3l3eSBzT3VFcklXNDNVQ0lVNkt0dk1HcEJ2YjhWUjZDTktGT1hlNEMzZ2Y2UlpzNWowT2xyVlMyL0FETkpaZHBZajZpN3JkS29EdmlLdEZwIDlFSmRYYWdMY1duQU5Ya3ZUYmNhREtGblJQczVpNmtHOXR0U2hHQVREQVRySkl6U1I2Rmh1QUhqZENGdXJ5OEU4dzJFMjB3NEJkdEMgQ1Mxc01iRGJOVVVLMlJkOWJud2xLYXd1MnJSdzFLRlAzcXprc2hkK2hlQmtSQmtibmJEWFJyc1dqdXNON05TS2lGYzZnVG1ZWlVJdSBpTFl0REQ4eHRORkZyZ25lWWlCMEIvRERhT1BjOFNQVUtlYVZOczlGNFJzUWRkQk5maFV6b3ExencweERtNnpHNFh5MllaakZ0N29RIEZab2pzc1dQRFcyeEJROXkyZ1lqVWl4TWFMRWwyajR6WEdkSWY3dm9jZTJ1eXhpUHVEL1k1TmR5WFF4RnBCNVN1TjVROTdzb01BaWEgRk9laFBrTFV2UzBuQmxIVHdFRE00bFNWbzN2bitOclJxWWFkckVUbzQvWlBjZ3hIWEV0anF1OHB2bmQ0cXNYSTFTazdITE1pek5GTCA2bmcvNWlQVmxGQTZmNjdGbktzTCtEVXhuOHNFaHdLL3RkRHJMcC9wcnhwT0FMNndVTUo3eEV4VUZVNUZuNlRuL1VUZEZJT0F0eXlVIDBRWGNIQ2YyQjB6UUYxbnFjSXRQSVlXa0dBWThZcW1ZVnhHVmI4bzg5K3FOT0tMMW1xWHVWaFBXZ1Y0bEdqRGJXK3c1c1grWkhFNkwgT0loSmlLTjFleTExTmcrL3l3NGt4aHpNVW00T2RpSjNER0VIVnVzUWxYVldKZEJQS3c1bUtlU055WmdsQ3g2c3lzMTk1Rjg3S2cvTSBRZ1NOOXlUUXkxb2N5cWNxR24weFMzT3VGcGZaREZ3V2dCNnVRRlRTYTB1b2kydHdJUFBUUll5WHE4YjlDUlhiSVZlUm8zQ25EcjBLIC9SRVZjeFppdG1GYzdZaldHeUdIRXRKYy9jeEQzTkhTVlVON0FYSGQyUXpIbHRxREpIMHZRbCtjWDljK3dJL2IySnhDRTNCYmpZcXYgVU9YSHdFYnBzRVg4c3NkSnFuOU95dkpsQ3YzNkpRNFhZUEVoTGpRUlVhMXZJdWx0ODdRQmZ3SCtKa2UyZnlIcTFuZklzTVplU1RINyBKQzFYRzFuN3lGYUhxQ1hhSU9jNFk0SFRnYThoRHUybU5lK3B6Q2V2Ukd3NEV4MnJka3dETGdlK2s5SDcvNHVvU2ZFeFl2dGpGMkovIHMxMDZXNmY4Zi9XeU5TSnFHdlNYSThjUVJDQXlxMUZrSmJBWVVXYzFJbVUweUluNTRoU294SmQyTjZJOFkwTTBmejRZSnBYZVdzT0sgeXNYV0lmdDBGeVhhaW5FUkE0Q0xnUWRTV0VrVzJUNUVuQmlmVFFyRitTUFNwY2xCaUpUb3RSNDUxRnBFdnRxZ1NIZis0SHc1NmQyTyB1RUM5dlVBSGFrZGN6TDBkc2RjNUsyVEZseWtOWlNMaXR2VUppQTNzMGJKbGRTZmdUdUJkWUp2ODkwMUVoSHhMR1pSZDF2eW1Cc1QrIFpLUDg5eGhFaHVzNHhPMWlRK1hpNEVqNTk1NFUxU0ZqWVovSUVNVkhpQ2o0VnVCdDROL3k3M3RrNjRqa0VSRVJFUkVSVVNyOEQ3R00gTUdqWGFBZXRBQUFBQUVsRlRrU3VRbUNDICIKICAgICBpZD0iaW1hZ2UzNzMxIgogICAgIHg9IjAiCiAgICAgeT0iMCIgLz4KPC9zdmc+Cg==\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./img/delete.svg\n// module id = 135\n// module chunks = 0","import OL3Parser from '../../node_modules/jsts/org/locationtech/jts/io/OL3Parser';\nimport { BufferOp } from '../../node_modules/jsts/org/locationtech/jts/operation/buffer';\nimport Control from './control';\nimport bufferSVG from '../../img/buffer.svg';\n\n/**\n * Control for creating buffers.\n * @extends {ole.Control}\n * @alias ole.BufferControl\n */\nclass BufferControl extends Control {\n  /**\n   * @inheritdoc\n   * @param {Object} [options] Control options.\n   * @param {number} [options.hitTolerance] Select tolerance in pixels\n   *   (default is 10)\n   * @param {boolean} [options.multi] Allow selection of multiple geometries\n   *   (default is false).\n   */\n  constructor(options) {\n    super(Object.assign({\n      title: 'Buffer geometry',\n      className: 'ole-control-buffer',\n      image: bufferSVG,\n    }, options));\n\n    /**\n     * @type {ol.interaction.Select}\n     * @private\n     */\n    this.selectInteraction = new ol.interaction.Select({\n      source: this.source,\n      hitTolerance: options.hitTolerance || 10,\n      multi: typeof (options.multi) === 'undefined' ? true : options.multi,\n    });\n\n    this.dialogTemplate = `\n      <label>Buffer width: &nbsp;<input type=\"text\" id=\"buffer-width\"/></label>\n      <input type=\"button\" value=\"OK\" id=\"buffer-btn\" />\n    `;\n  }\n\n  /**\n   * Apply a buffer for seleted features.\n   * @param {Number} width Buffer width in map units.\n   */\n  buffer(width) {\n    const parser = new OL3Parser();\n    const features = this.selectInteraction.getFeatures().getArray();\n    for (let i = 0; i < features.length; i += 1) {\n      const jstsGeom = parser.read(features[i].getGeometry());\n      const bo = new BufferOp(jstsGeom);\n      const buffered = bo.getResultGeometry(width);\n      features[i].setGeometry(parser.write(buffered));\n    }\n  }\n\n  /**\n   * @inheritdoc\n   */\n  activate() {\n    this.map.addInteraction(this.selectInteraction);\n    super.activate();\n\n    document.getElementById('buffer-btn').addEventListener('click', () => {\n      const input = document.getElementById('buffer-width');\n      const width = parseInt(input.value, 10);\n\n      if (width) {\n        this.buffer(width);\n      }\n    });\n  }\n\n  /**\n   * @inheritdoc\n   */\n  deactivate() {\n    this.map.removeInteraction(this.selectInteraction);\n    super.deactivate();\n  }\n}\n\nexport default BufferControl;\n\n\n\n// WEBPACK FOOTER //\n// ./src/control/buffer.js","import extend from '../../../../extend';\nexport default function NumberUtil() {}\nextend(NumberUtil.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn NumberUtil;\n\t}\n});\nNumberUtil.equalsWithTolerance = function (x1, x2, tolerance) {\n\treturn Math.abs(x1 - x2) <= tolerance;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/util/NumberUtil.js\n// module id = 137\n// module chunks = 0","import extend from '../../../../extend';\nimport RuntimeException from '../../../../java/lang/RuntimeException';\nimport inherits from '../../../../inherits';\nexport default function AssertionFailedException() {\n\tif (arguments.length === 0) {\n\t\tRuntimeException.call(this);\n\t} else if (arguments.length === 1) {\n\t\tlet message = arguments[0];\n\t\tRuntimeException.call(this, message);\n\t}\n}\ninherits(AssertionFailedException, RuntimeException);\nextend(AssertionFailedException.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn AssertionFailedException;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/util/AssertionFailedException.js\n// module id = 138\n// module chunks = 0","/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nexport default function IndexOutOfBoundsException(message) {\n  this.message = message || '';\n};\nIndexOutOfBoundsException.prototype = new Error();\n\n/**\n * @type {string}\n */\nIndexOutOfBoundsException.prototype.name = 'IndexOutOfBoundsException';\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/util/IndexOutOfBoundsException.js\n// module id = 139\n// module chunks = 0","import Map from './Map'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedMap.html\n *\n * @extends {Map}\n * @constructor\n * @private\n */\nexport default function SortedMap() {};\nSortedMap.prototype = new Map();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/util/SortedMap.js\n// module id = 140\n// module chunks = 0","import Set from './Set'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedSet.html\n *\n * @extends {Set}\n * @constructor\n * @private\n */\nexport default function SortedSet() {};\nSortedSet.prototype = new Set();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/util/SortedSet.js\n// module id = 141\n// module chunks = 0","import Coordinate from '../geom/Coordinate';\nimport extend from '../../../../extend';\nexport default function Length() {}\nextend(Length.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Length;\n\t}\n});\nLength.ofLine = function (pts) {\n\tvar n = pts.size();\n\tif (n <= 1) return 0.0;\n\tvar len = 0.0;\n\tvar p = new Coordinate();\n\tpts.getCoordinate(0, p);\n\tvar x0 = p.x;\n\tvar y0 = p.y;\n\tfor (var i = 1; i < n; i++) {\n\t\tpts.getCoordinate(i, p);\n\t\tvar x1 = p.x;\n\t\tvar y1 = p.y;\n\t\tvar dx = x1 - x0;\n\t\tvar dy = y1 - y0;\n\t\tlen += Math.sqrt(dx * dx + dy * dy);\n\t\tx0 = x1;\n\t\ty0 = y1;\n\t}\n\treturn len;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/algorithm/Length.js\n// module id = 142\n// module chunks = 0","import PrintStream from '../../../../java/io/PrintStream';\nimport StringReader from '../../../../java/io/StringReader';\nimport DecimalFormat from '../../../../java/text/DecimalFormat';\nimport extend from '../../../../extend';\nimport System from '../../../../java/lang/System';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport ByteArrayOutputStream from '../../../../java/io/ByteArrayOutputStream';\nimport Assert from './Assert';\nimport IOException from '../../../../java/io/IOException';\nimport LineNumberReader from '../../../../java/io/LineNumberReader';\nexport default function StringUtil() {}\nextend(StringUtil.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn StringUtil;\n\t}\n});\nStringUtil.chars = function (c, n) {\n\tvar ch = new Array(n).fill(null);\n\tfor (var i = 0; i < n; i++) {\n\t\tch[i] = c;\n\t}\n\treturn new String(ch);\n};\nStringUtil.getStackTrace = function () {\n\tif (arguments.length === 1) {\n\t\tlet t = arguments[0];\n\t\tvar os = new ByteArrayOutputStream();\n\t\tvar ps = new PrintStream(os);\n\t\tt.printStackTrace(ps);\n\t\treturn os.toString();\n\t} else if (arguments.length === 2) {\n\t\tlet t = arguments[0], depth = arguments[1];\n\t\tvar stackTrace = \"\";\n\t\tvar stringReader = new StringReader(StringUtil.getStackTrace(t));\n\t\tvar lineNumberReader = new LineNumberReader(stringReader);\n\t\tfor (var i = 0; i < depth; i++) {\n\t\t\ttry {\n\t\t\t\tstackTrace += lineNumberReader.readLine() + StringUtil.NEWLINE;\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof IOException) {\n\t\t\t\t\tAssert.shouldNeverReachHere();\n\t\t\t\t} else throw e;\n\t\t\t} finally {}\n\t\t}\n\t\treturn stackTrace;\n\t}\n};\nStringUtil.split = function (s, separator) {\n\tvar separatorlen = separator.length;\n\tvar tokenList = new ArrayList();\n\tvar tmpString = \"\" + s;\n\tvar pos = tmpString.indexOf(separator);\n\twhile (pos >= 0) {\n\t\tvar token = tmpString.substring(0, pos);\n\t\ttokenList.add(token);\n\t\ttmpString = tmpString.substring(pos + separatorlen);\n\t\tpos = tmpString.indexOf(separator);\n\t}\n\tif (tmpString.length > 0) tokenList.add(tmpString);\n\tvar res = new Array(tokenList.size()).fill(null);\n\tfor (var i = 0; i < res.length; i++) {\n\t\tres[i] = tokenList.get(i);\n\t}\n\treturn res;\n};\nStringUtil.toString = function () {\n\tif (arguments.length === 1 && typeof arguments[0] === \"number\") {\n\t\tlet d = arguments[0];\n\t\treturn StringUtil.SIMPLE_ORDINATE_FORMAT.format(d);\n\t}\n};\nStringUtil.spaces = function (n) {\n\treturn StringUtil.chars(' ', n);\n};\nStringUtil.NEWLINE = System.getProperty(\"line.separator\");\nStringUtil.SIMPLE_ORDINATE_FORMAT = new DecimalFormat(\"0.#\");\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/util/StringUtil.js\n// module id = 143\n// module chunks = 0","export default function PrintStream () {}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/io/PrintStream.js\n// module id = 144\n// module chunks = 0","export default function StringReader () {}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/io/StringReader.js\n// module id = 145\n// module chunks = 0","export default function DecimalFormat () {}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/text/DecimalFormat.js\n// module id = 146\n// module chunks = 0","export default function ByteArrayOutputStream () {}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/io/ByteArrayOutputStream.js\n// module id = 147\n// module chunks = 0","export default function IOException () {}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/io/IOException.js\n// module id = 148\n// module chunks = 0","export default function LineNumberReader () {}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/io/LineNumberReader.js\n// module id = 149\n// module chunks = 0","import hasInterface from '../../../../hasInterface';\nimport Coordinate from '../geom/Coordinate';\nimport extend from '../../../../extend';\nimport CoordinateSequence from '../geom/CoordinateSequence';\nexport default function Area() {}\nextend(Area.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Area;\n\t}\n});\nArea.ofRing = function () {\n\tif (arguments[0] instanceof Array) {\n\t\tlet ring = arguments[0];\n\t\treturn Math.abs(Area.ofRingSigned(ring));\n\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\tlet ring = arguments[0];\n\t\treturn Math.abs(Area.ofRingSigned(ring));\n\t}\n};\nArea.ofRingSigned = function () {\n\tif (arguments[0] instanceof Array) {\n\t\tlet ring = arguments[0];\n\t\tif (ring.length < 3) return 0.0;\n\t\tvar sum = 0.0;\n\t\tvar x0 = ring[0].x;\n\t\tfor (var i = 1; i < ring.length - 1; i++) {\n\t\t\tvar x = ring[i].x - x0;\n\t\t\tvar y1 = ring[i + 1].y;\n\t\t\tvar y2 = ring[i - 1].y;\n\t\t\tsum += x * (y2 - y1);\n\t\t}\n\t\treturn sum / 2.0;\n\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\tlet ring = arguments[0];\n\t\tvar n = ring.size();\n\t\tif (n < 3) return 0.0;\n\t\tvar p0 = new Coordinate();\n\t\tvar p1 = new Coordinate();\n\t\tvar p2 = new Coordinate();\n\t\tring.getCoordinate(0, p1);\n\t\tring.getCoordinate(1, p2);\n\t\tvar x0 = p1.x;\n\t\tp2.x -= x0;\n\t\tvar sum = 0.0;\n\t\tfor (var i = 1; i < n - 1; i++) {\n\t\t\tp0.y = p1.y;\n\t\t\tp1.x = p2.x;\n\t\t\tp1.y = p2.y;\n\t\t\tring.getCoordinate(i + 1, p2);\n\t\t\tp2.x -= x0;\n\t\t\tsum += p1.x * (p0.y - p2.y);\n\t\t}\n\t\treturn sum / 2.0;\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/algorithm/Area.js\n// module id = 150\n// module chunks = 0","import StringBuffer from '../../../../java/lang/StringBuffer';\nimport Double from '../../../../java/lang/Double';\nimport extend from '../../../../extend';\nimport Integer from '../../../../java/lang/Integer';\nimport Character from '../../../../java/lang/Character';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Cloneable from '../../../../java/lang/Cloneable';\nimport Serializable from '../../../../java/io/Serializable';\nexport default function DD() {\n\tthis._hi = 0.0;\n\tthis._lo = 0.0;\n\tif (arguments.length === 0) {\n\t\tthis.init(0.0);\n\t} else if (arguments.length === 1) {\n\t\tif (typeof arguments[0] === \"number\") {\n\t\t\tlet x = arguments[0];\n\t\t\tthis.init(x);\n\t\t} else if (arguments[0] instanceof DD) {\n\t\t\tlet dd = arguments[0];\n\t\t\tthis.init(dd);\n\t\t} else if (typeof arguments[0] === \"string\") {\n\t\t\tlet str = arguments[0];\n\t\t\tDD.call(this, DD.parse(str));\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tlet hi = arguments[0], lo = arguments[1];\n\t\tthis.init(hi, lo);\n\t}\n}\nextend(DD.prototype, {\n\tle: function (y) {\n\t\treturn this._hi < y._hi || this._hi === y._hi && this._lo <= y._lo;\n\t},\n\textractSignificantDigits: function (insertDecimalPoint, magnitude) {\n\t\tvar y = this.abs();\n\t\tvar mag = DD.magnitude(y._hi);\n\t\tvar scale = DD.TEN.pow(mag);\n\t\ty = y.divide(scale);\n\t\tif (y.gt(DD.TEN)) {\n\t\t\ty = y.divide(DD.TEN);\n\t\t\tmag += 1;\n\t\t} else if (y.lt(DD.ONE)) {\n\t\t\ty = y.multiply(DD.TEN);\n\t\t\tmag -= 1;\n\t\t}\n\t\tvar decimalPointPos = mag + 1;\n\t\tvar buf = new StringBuffer();\n\t\tvar numDigits = DD.MAX_PRINT_DIGITS - 1;\n\t\tfor (var i = 0; i <= numDigits; i++) {\n\t\t\tif (insertDecimalPoint && i === decimalPointPos) {\n\t\t\t\tbuf.append('.');\n\t\t\t}\n\t\t\tvar digit = Math.trunc(y._hi);\n\t\t\tif (digit < 0 || digit > 9) {}\n\t\t\tif (digit < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar rebiasBy10 = false;\n\t\t\tvar digitChar = 0;\n\t\t\tif (digit > 9) {\n\t\t\t\trebiasBy10 = true;\n\t\t\t\tdigitChar = '9';\n\t\t\t} else {\n\t\t\t\tdigitChar = '0' + digit;\n\t\t\t}\n\t\t\tbuf.append(digitChar);\n\t\t\ty = y.subtract(DD.valueOf(digit)).multiply(DD.TEN);\n\t\t\tif (rebiasBy10) y.selfAdd(DD.TEN);\n\t\t\tvar continueExtractingDigits = true;\n\t\t\tvar remMag = DD.magnitude(y._hi);\n\t\t\tif (remMag < 0 && Math.abs(remMag) >= numDigits - i) continueExtractingDigits = false;\n\t\t\tif (!continueExtractingDigits) break;\n\t\t}\n\t\tmagnitude[0] = mag;\n\t\treturn buf.toString();\n\t},\n\tsqr: function () {\n\t\treturn this.multiply(this);\n\t},\n\tdoubleValue: function () {\n\t\treturn this._hi + this._lo;\n\t},\n\tsubtract: function () {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\treturn this.add(y.negate());\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet y = arguments[0];\n\t\t\treturn this.add(-y);\n\t\t}\n\t},\n\tequals: function () {\n\t\tif (arguments.length === 1 && arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\treturn this._hi === y._hi && this._lo === y._lo;\n\t\t}\n\t},\n\tisZero: function () {\n\t\treturn this._hi === 0.0 && this._lo === 0.0;\n\t},\n\tselfSubtract: function () {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\tif (this.isNaN()) return this;\n\t\t\treturn this.selfAdd(-y._hi, -y._lo);\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet y = arguments[0];\n\t\t\tif (this.isNaN()) return this;\n\t\t\treturn this.selfAdd(-y, 0.0);\n\t\t}\n\t},\n\tgetSpecialNumberString: function () {\n\t\tif (this.isZero()) return \"0.0\";\n\t\tif (this.isNaN()) return \"NaN \";\n\t\treturn null;\n\t},\n\tmin: function (x) {\n\t\tif (this.le(x)) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn x;\n\t\t}\n\t},\n\tselfDivide: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof DD) {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\treturn this.selfDivide(y._hi, y._lo);\n\t\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\treturn this.selfDivide(y, 0.0);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet yhi = arguments[0], ylo = arguments[1];\n\t\t\tvar hc = null, tc = null, hy = null, ty = null, C = null, c = null, U = null, u = null;\n\t\t\tC = this._hi / yhi;\n\t\t\tc = DD.SPLIT * C;\n\t\t\thc = c - C;\n\t\t\tu = DD.SPLIT * yhi;\n\t\t\thc = c - hc;\n\t\t\ttc = C - hc;\n\t\t\thy = u - yhi;\n\t\t\tU = C * yhi;\n\t\t\thy = u - hy;\n\t\t\tty = yhi - hy;\n\t\t\tu = hc * hy - U + hc * ty + tc * hy + tc * ty;\n\t\t\tc = (this._hi - U - u + this._lo - C * ylo) / yhi;\n\t\t\tu = C + c;\n\t\t\tthis._hi = u;\n\t\t\tthis._lo = C - u + c;\n\t\t\treturn this;\n\t\t}\n\t},\n\tdump: function () {\n\t\treturn \"DD<\" + this._hi + \", \" + this._lo + \">\";\n\t},\n\tdivide: function () {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\tvar hc = null, tc = null, hy = null, ty = null, C = null, c = null, U = null, u = null;\n\t\t\tC = this._hi / y._hi;\n\t\t\tc = DD.SPLIT * C;\n\t\t\thc = c - C;\n\t\t\tu = DD.SPLIT * y._hi;\n\t\t\thc = c - hc;\n\t\t\ttc = C - hc;\n\t\t\thy = u - y._hi;\n\t\t\tU = C * y._hi;\n\t\t\thy = u - hy;\n\t\t\tty = y._hi - hy;\n\t\t\tu = hc * hy - U + hc * ty + tc * hy + tc * ty;\n\t\t\tc = (this._hi - U - u + this._lo - C * y._lo) / y._hi;\n\t\t\tu = C + c;\n\t\t\tvar zhi = u;\n\t\t\tvar zlo = C - u + c;\n\t\t\treturn new DD(zhi, zlo);\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet y = arguments[0];\n\t\t\tif (Double.isNaN(y)) return DD.createNaN();\n\t\t\treturn DD.copy(this).selfDivide(y, 0.0);\n\t\t}\n\t},\n\tge: function (y) {\n\t\treturn this._hi > y._hi || this._hi === y._hi && this._lo >= y._lo;\n\t},\n\tpow: function (exp) {\n\t\tif (exp === 0.0) return DD.valueOf(1.0);\n\t\tvar r = new DD(this);\n\t\tvar s = DD.valueOf(1.0);\n\t\tvar n = Math.abs(exp);\n\t\tif (n > 1) {\n\t\t\twhile (n > 0) {\n\t\t\t\tif (n % 2 === 1) {\n\t\t\t\t\ts.selfMultiply(r);\n\t\t\t\t}\n\t\t\t\tn /= 2;\n\t\t\t\tif (n > 0) r = r.sqr();\n\t\t\t}\n\t\t} else {\n\t\t\ts = r;\n\t\t}\n\t\tif (exp < 0) return s.reciprocal();\n\t\treturn s;\n\t},\n\tceil: function () {\n\t\tif (this.isNaN()) return DD.NaN;\n\t\tvar fhi = Math.ceil(this._hi);\n\t\tvar flo = 0.0;\n\t\tif (fhi === this._hi) {\n\t\t\tflo = Math.ceil(this._lo);\n\t\t}\n\t\treturn new DD(fhi, flo);\n\t},\n\tcompareTo: function (o) {\n\t\tvar other = o;\n\t\tif (this._hi < other._hi) return -1;\n\t\tif (this._hi > other._hi) return 1;\n\t\tif (this._lo < other._lo) return -1;\n\t\tif (this._lo > other._lo) return 1;\n\t\treturn 0;\n\t},\n\trint: function () {\n\t\tif (this.isNaN()) return this;\n\t\tvar plus5 = this.add(0.5);\n\t\treturn plus5.floor();\n\t},\n\tsetValue: function () {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet value = arguments[0];\n\t\t\tthis.init(value);\n\t\t\treturn this;\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet value = arguments[0];\n\t\t\tthis.init(value);\n\t\t\treturn this;\n\t\t}\n\t},\n\tmax: function (x) {\n\t\tif (this.ge(x)) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn x;\n\t\t}\n\t},\n\tsqrt: function () {\n\t\tif (this.isZero()) return DD.valueOf(0.0);\n\t\tif (this.isNegative()) {\n\t\t\treturn DD.NaN;\n\t\t}\n\t\tvar x = 1.0 / Math.sqrt(this._hi);\n\t\tvar ax = this._hi * x;\n\t\tvar axdd = DD.valueOf(ax);\n\t\tvar diffSq = this.subtract(axdd.sqr());\n\t\tvar d2 = diffSq._hi * (x * 0.5);\n\t\treturn axdd.add(d2);\n\t},\n\tselfAdd: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof DD) {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\treturn this.selfAdd(y._hi, y._lo);\n\t\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\tvar H = null, h = null, S = null, s = null, e = null, f = null;\n\t\t\t\tS = this._hi + y;\n\t\t\t\te = S - this._hi;\n\t\t\t\ts = S - e;\n\t\t\t\ts = y - e + (this._hi - s);\n\t\t\t\tf = s + this._lo;\n\t\t\t\tH = S + f;\n\t\t\t\th = f + (S - H);\n\t\t\t\tthis._hi = H + h;\n\t\t\t\tthis._lo = h + (H - this._hi);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet yhi = arguments[0], ylo = arguments[1];\n\t\t\tvar H = null, h = null, T = null, t = null, S = null, s = null, e = null, f = null;\n\t\t\tS = this._hi + yhi;\n\t\t\tT = this._lo + ylo;\n\t\t\te = S - this._hi;\n\t\t\tf = T - this._lo;\n\t\t\ts = S - e;\n\t\t\tt = T - f;\n\t\t\ts = yhi - e + (this._hi - s);\n\t\t\tt = ylo - f + (this._lo - t);\n\t\t\te = s + T;\n\t\t\tH = S + e;\n\t\t\th = e + (S - H);\n\t\t\te = t + h;\n\t\t\tvar zhi = H + e;\n\t\t\tvar zlo = e + (H - zhi);\n\t\t\tthis._hi = zhi;\n\t\t\tthis._lo = zlo;\n\t\t\treturn this;\n\t\t}\n\t},\n\tselfMultiply: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof DD) {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\treturn this.selfMultiply(y._hi, y._lo);\n\t\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\treturn this.selfMultiply(y, 0.0);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet yhi = arguments[0], ylo = arguments[1];\n\t\t\tvar hx = null, tx = null, hy = null, ty = null, C = null, c = null;\n\t\t\tC = DD.SPLIT * this._hi;\n\t\t\thx = C - this._hi;\n\t\t\tc = DD.SPLIT * yhi;\n\t\t\thx = C - hx;\n\t\t\ttx = this._hi - hx;\n\t\t\thy = c - yhi;\n\t\t\tC = this._hi * yhi;\n\t\t\thy = c - hy;\n\t\t\tty = yhi - hy;\n\t\t\tc = hx * hy - C + hx * ty + tx * hy + tx * ty + (this._hi * ylo + this._lo * yhi);\n\t\t\tvar zhi = C + c;\n\t\t\thx = C - zhi;\n\t\t\tvar zlo = c + hx;\n\t\t\tthis._hi = zhi;\n\t\t\tthis._lo = zlo;\n\t\t\treturn this;\n\t\t}\n\t},\n\tselfSqr: function () {\n\t\treturn this.selfMultiply(this);\n\t},\n\tfloor: function () {\n\t\tif (this.isNaN()) return DD.NaN;\n\t\tvar fhi = Math.floor(this._hi);\n\t\tvar flo = 0.0;\n\t\tif (fhi === this._hi) {\n\t\t\tflo = Math.floor(this._lo);\n\t\t}\n\t\treturn new DD(fhi, flo);\n\t},\n\tnegate: function () {\n\t\tif (this.isNaN()) return this;\n\t\treturn new DD(-this._hi, -this._lo);\n\t},\n\tclone: function () {\n\t\ttry {\n\t\t\treturn null;\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof CloneNotSupportedException) {\n\t\t\t\treturn null;\n\t\t\t} else throw ex;\n\t\t} finally {}\n\t},\n\tmultiply: function () {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\tif (y.isNaN()) return DD.createNaN();\n\t\t\treturn DD.copy(this).selfMultiply(y);\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet y = arguments[0];\n\t\t\tif (Double.isNaN(y)) return DD.createNaN();\n\t\t\treturn DD.copy(this).selfMultiply(y, 0.0);\n\t\t}\n\t},\n\tisNaN: function () {\n\t\treturn Double.isNaN(this._hi);\n\t},\n\tintValue: function () {\n\t\treturn Math.trunc(this._hi);\n\t},\n\ttoString: function () {\n\t\tvar mag = DD.magnitude(this._hi);\n\t\tif (mag >= -3 && mag <= 20) return this.toStandardNotation();\n\t\treturn this.toSciNotation();\n\t},\n\ttoStandardNotation: function () {\n\t\tvar specialStr = this.getSpecialNumberString();\n\t\tif (specialStr !== null) return specialStr;\n\t\tvar magnitude = new Array(1).fill(null);\n\t\tvar sigDigits = this.extractSignificantDigits(true, magnitude);\n\t\tvar decimalPointPos = magnitude[0] + 1;\n\t\tvar num = sigDigits;\n\t\tif (sigDigits.charAt(0) === '.') {\n\t\t\tnum = \"0\" + sigDigits;\n\t\t} else if (decimalPointPos < 0) {\n\t\t\tnum = \"0.\" + DD.stringOfChar('0', -decimalPointPos) + sigDigits;\n\t\t} else if (sigDigits.indexOf('.') === -1) {\n\t\t\tvar numZeroes = decimalPointPos - sigDigits.length;\n\t\t\tvar zeroes = DD.stringOfChar('0', numZeroes);\n\t\t\tnum = sigDigits + zeroes + \".0\";\n\t\t}\n\t\tif (this.isNegative()) return \"-\" + num;\n\t\treturn num;\n\t},\n\treciprocal: function () {\n\t\tvar hc = null, tc = null, hy = null, ty = null, C = null, c = null, U = null, u = null;\n\t\tC = 1.0 / this._hi;\n\t\tc = DD.SPLIT * C;\n\t\thc = c - C;\n\t\tu = DD.SPLIT * this._hi;\n\t\thc = c - hc;\n\t\ttc = C - hc;\n\t\thy = u - this._hi;\n\t\tU = C * this._hi;\n\t\thy = u - hy;\n\t\tty = this._hi - hy;\n\t\tu = hc * hy - U + hc * ty + tc * hy + tc * ty;\n\t\tc = (1.0 - U - u - C * this._lo) / this._hi;\n\t\tvar zhi = C + c;\n\t\tvar zlo = C - zhi + c;\n\t\treturn new DD(zhi, zlo);\n\t},\n\ttoSciNotation: function () {\n\t\tif (this.isZero()) return DD.SCI_NOT_ZERO;\n\t\tvar specialStr = this.getSpecialNumberString();\n\t\tif (specialStr !== null) return specialStr;\n\t\tvar magnitude = new Array(1).fill(null);\n\t\tvar digits = this.extractSignificantDigits(false, magnitude);\n\t\tvar expStr = DD.SCI_NOT_EXPONENT_CHAR + magnitude[0];\n\t\tif (digits.charAt(0) === '0') {\n\t\t\tthrow new IllegalStateException(\"Found leading zero: \" + digits);\n\t\t}\n\t\tvar trailingDigits = \"\";\n\t\tif (digits.length > 1) trailingDigits = digits.substring(1);\n\t\tvar digitsWithDecimal = digits.charAt(0) + \".\" + trailingDigits;\n\t\tif (this.isNegative()) return \"-\" + digitsWithDecimal + expStr;\n\t\treturn digitsWithDecimal + expStr;\n\t},\n\tabs: function () {\n\t\tif (this.isNaN()) return DD.NaN;\n\t\tif (this.isNegative()) return this.negate();\n\t\treturn new DD(this);\n\t},\n\tisPositive: function () {\n\t\treturn this._hi > 0.0 || this._hi === 0.0 && this._lo > 0.0;\n\t},\n\tlt: function (y) {\n\t\treturn this._hi < y._hi || this._hi === y._hi && this._lo < y._lo;\n\t},\n\tadd: function () {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\treturn DD.copy(this).selfAdd(y);\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet y = arguments[0];\n\t\t\treturn DD.copy(this).selfAdd(y);\n\t\t}\n\t},\n\tinit: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tif (typeof arguments[0] === \"number\") {\n\t\t\t\tlet x = arguments[0];\n\t\t\t\tthis._hi = x;\n\t\t\t\tthis._lo = 0.0;\n\t\t\t} else if (arguments[0] instanceof DD) {\n\t\t\t\tlet dd = arguments[0];\n\t\t\t\tthis._hi = dd._hi;\n\t\t\t\tthis._lo = dd._lo;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet hi = arguments[0], lo = arguments[1];\n\t\t\tthis._hi = hi;\n\t\t\tthis._lo = lo;\n\t\t}\n\t},\n\tgt: function (y) {\n\t\treturn this._hi > y._hi || this._hi === y._hi && this._lo > y._lo;\n\t},\n\tisNegative: function () {\n\t\treturn this._hi < 0.0 || this._hi === 0.0 && this._lo < 0.0;\n\t},\n\ttrunc: function () {\n\t\tif (this.isNaN()) return DD.NaN;\n\t\tif (this.isPositive()) return this.floor(); else return this.ceil();\n\t},\n\tsignum: function () {\n\t\tif (this._hi > 0) return 1;\n\t\tif (this._hi < 0) return -1;\n\t\tif (this._lo > 0) return 1;\n\t\tif (this._lo < 0) return -1;\n\t\treturn 0;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Serializable, Comparable, Cloneable];\n\t},\n\tgetClass: function () {\n\t\treturn DD;\n\t}\n});\nDD.sqr = function (x) {\n\treturn DD.valueOf(x).selfMultiply(x);\n};\nDD.valueOf = function () {\n\tif (typeof arguments[0] === \"string\") {\n\t\tlet str = arguments[0];\n\t\treturn DD.parse(str);\n\t} else if (typeof arguments[0] === \"number\") {\n\t\tlet x = arguments[0];\n\t\treturn new DD(x);\n\t}\n};\nDD.sqrt = function (x) {\n\treturn DD.valueOf(x).sqrt();\n};\nDD.parse = function (str) {\n\tvar i = 0;\n\tvar strlen = str.length;\n\twhile (Character.isWhitespace(str.charAt(i))) i++;\n\tvar isNegative = false;\n\tif (i < strlen) {\n\t\tvar signCh = str.charAt(i);\n\t\tif (signCh === '-' || signCh === '+') {\n\t\t\ti++;\n\t\t\tif (signCh === '-') isNegative = true;\n\t\t}\n\t}\n\tvar val = new DD();\n\tvar numDigits = 0;\n\tvar numBeforeDec = 0;\n\tvar exp = 0;\n\twhile (true) {\n\t\tif (i >= strlen) break;\n\t\tvar ch = str.charAt(i);\n\t\ti++;\n\t\tif (Character.isDigit(ch)) {\n\t\t\tvar d = ch - '0';\n\t\t\tval.selfMultiply(DD.TEN);\n\t\t\tval.selfAdd(d);\n\t\t\tnumDigits++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch === '.') {\n\t\t\tnumBeforeDec = numDigits;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch === 'e' || ch === 'E') {\n\t\t\tvar expStr = str.substring(i);\n\t\t\ttry {\n\t\t\t\texp = Integer.parseInt(expStr);\n\t\t\t} catch (ex) {\n\t\t\t\tif (ex instanceof NumberFormatException) {\n\t\t\t\t\tthrow new NumberFormatException(\"Invalid exponent \" + expStr + \" in string \" + str);\n\t\t\t\t} else throw ex;\n\t\t\t} finally {}\n\t\t\tbreak;\n\t\t}\n\t\tthrow new NumberFormatException(\"Unexpected character '\" + ch + \"' at position \" + i + \" in string \" + str);\n\t}\n\tvar val2 = val;\n\tvar numDecPlaces = numDigits - numBeforeDec - exp;\n\tif (numDecPlaces === 0) {\n\t\tval2 = val;\n\t} else if (numDecPlaces > 0) {\n\t\tvar scale = DD.TEN.pow(numDecPlaces);\n\t\tval2 = val.divide(scale);\n\t} else if (numDecPlaces < 0) {\n\t\tvar scale = DD.TEN.pow(-numDecPlaces);\n\t\tval2 = val.multiply(scale);\n\t}\n\tif (isNegative) {\n\t\treturn val2.negate();\n\t}\n\treturn val2;\n};\nDD.createNaN = function () {\n\treturn new DD(Double.NaN, Double.NaN);\n};\nDD.copy = function (dd) {\n\treturn new DD(dd);\n};\nDD.magnitude = function (x) {\n\tvar xAbs = Math.abs(x);\n\tvar xLog10 = Math.log(xAbs) / Math.log(10);\n\tvar xMag = Math.trunc(Math.floor(xLog10));\n\tvar xApprox = Math.pow(10, xMag);\n\tif (xApprox * 10 <= xAbs) xMag += 1;\n\treturn xMag;\n};\nDD.stringOfChar = function (ch, len) {\n\tvar buf = new StringBuffer();\n\tfor (var i = 0; i < len; i++) {\n\t\tbuf.append(ch);\n\t}\n\treturn buf.toString();\n};\nDD.PI = new DD(3.141592653589793116e+00, 1.224646799147353207e-16);\nDD.TWO_PI = new DD(6.283185307179586232e+00, 2.449293598294706414e-16);\nDD.PI_2 = new DD(1.570796326794896558e+00, 6.123233995736766036e-17);\nDD.E = new DD(2.718281828459045091e+00, 1.445646891729250158e-16);\nDD.NaN = new DD(Double.NaN, Double.NaN);\nDD.EPS = 1.23259516440783e-32;\nDD.SPLIT = 134217729.0;\nDD.MAX_PRINT_DIGITS = 32;\nDD.TEN = DD.valueOf(10.0);\nDD.ONE = DD.valueOf(1.0);\nDD.SCI_NOT_EXPONENT_CHAR = \"E\";\nDD.SCI_NOT_ZERO = \"0.0E0\";\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/math/DD.js\n// module id = 151\n// module chunks = 0","import LineString from '../LineString';\nimport Point from '../Point';\nimport Polygon from '../Polygon';\nimport MultiPoint from '../MultiPoint';\nimport LinearRing from '../LinearRing';\nimport extend from '../../../../../extend';\nimport MultiPolygon from '../MultiPolygon';\nimport GeometryCollection from '../GeometryCollection';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Assert from '../../util/Assert';\nimport MultiLineString from '../MultiLineString';\nexport default function GeometryEditor() {\n\tthis._factory = null;\n\tthis._isUserDataCopied = false;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet factory = arguments[0];\n\t\tthis._factory = factory;\n\t}\n}\nextend(GeometryEditor.prototype, {\n\tsetCopyUserData: function (isUserDataCopied) {\n\t\tthis._isUserDataCopied = isUserDataCopied;\n\t},\n\tedit: function (geometry, operation) {\n\t\tif (geometry === null) return null;\n\t\tvar result = this.editInternal(geometry, operation);\n\t\tif (this._isUserDataCopied) {\n\t\t\tresult.setUserData(geometry.getUserData());\n\t\t}\n\t\treturn result;\n\t},\n\teditInternal: function (geometry, operation) {\n\t\tif (this._factory === null) this._factory = geometry.getFactory();\n\t\tif (geometry instanceof GeometryCollection) {\n\t\t\treturn this.editGeometryCollection(geometry, operation);\n\t\t}\n\t\tif (geometry instanceof Polygon) {\n\t\t\treturn this.editPolygon(geometry, operation);\n\t\t}\n\t\tif (geometry instanceof Point) {\n\t\t\treturn operation.edit(geometry, this._factory);\n\t\t}\n\t\tif (geometry instanceof LineString) {\n\t\t\treturn operation.edit(geometry, this._factory);\n\t\t}\n\t\tAssert.shouldNeverReachHere(\"Unsupported Geometry class: \" + geometry.getClass().getName());\n\t\treturn null;\n\t},\n\teditGeometryCollection: function (collection, operation) {\n\t\tvar collectionForType = operation.edit(collection, this._factory);\n\t\tvar geometries = new ArrayList();\n\t\tfor (var i = 0; i < collectionForType.getNumGeometries(); i++) {\n\t\t\tvar geometry = this.edit(collectionForType.getGeometryN(i), operation);\n\t\t\tif (geometry === null || geometry.isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgeometries.add(geometry);\n\t\t}\n\t\tif (collectionForType.getClass() === MultiPoint) {\n\t\t\treturn this._factory.createMultiPoint(geometries.toArray([]));\n\t\t}\n\t\tif (collectionForType.getClass() === MultiLineString) {\n\t\t\treturn this._factory.createMultiLineString(geometries.toArray([]));\n\t\t}\n\t\tif (collectionForType.getClass() === MultiPolygon) {\n\t\t\treturn this._factory.createMultiPolygon(geometries.toArray([]));\n\t\t}\n\t\treturn this._factory.createGeometryCollection(geometries.toArray([]));\n\t},\n\teditPolygon: function (polygon, operation) {\n\t\tvar newPolygon = operation.edit(polygon, this._factory);\n\t\tif (newPolygon === null) newPolygon = this._factory.createPolygon();\n\t\tif (newPolygon.isEmpty()) {\n\t\t\treturn newPolygon;\n\t\t}\n\t\tvar shell = this.edit(newPolygon.getExteriorRing(), operation);\n\t\tif (shell === null || shell.isEmpty()) {\n\t\t\treturn this._factory.createPolygon();\n\t\t}\n\t\tvar holes = new ArrayList();\n\t\tfor (var i = 0; i < newPolygon.getNumInteriorRing(); i++) {\n\t\t\tvar hole = this.edit(newPolygon.getInteriorRingN(i), operation);\n\t\t\tif (hole === null || hole.isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tholes.add(hole);\n\t\t}\n\t\treturn this._factory.createPolygon(shell, holes.toArray([]));\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn GeometryEditor;\n\t}\n});\nfunction GeometryEditorOperation() {}\nGeometryEditor.GeometryEditorOperation = GeometryEditorOperation;\nfunction NoOpGeometryOperation() {}\nextend(NoOpGeometryOperation.prototype, {\n\tedit: function (geometry, factory) {\n\t\treturn geometry;\n\t},\n\tinterfaces_: function () {\n\t\treturn [GeometryEditorOperation];\n\t},\n\tgetClass: function () {\n\t\treturn NoOpGeometryOperation;\n\t}\n});\nfunction CoordinateOperation() {}\nextend(CoordinateOperation.prototype, {\n\tedit: function (geometry, factory) {\n\t\tvar coordinates = this.edit(geometry.getCoordinates(), geometry);\n\t\tif (geometry instanceof LinearRing) {\n\t\t\tif (coordinates === null) return factory.createLinearRing(); else return factory.createLinearRing(coordinates);\n\t\t}\n\t\tif (geometry instanceof LineString) {\n\t\t\tif (coordinates === null) return factory.createLineString(); else return factory.createLineString(coordinates);\n\t\t}\n\t\tif (geometry instanceof Point) {\n\t\t\tif (coordinates === null || coordinates.length === 0) return factory.createPoint(); else return factory.createPoint(coordinates[0]);\n\t\t}\n\t\treturn geometry;\n\t},\n\tinterfaces_: function () {\n\t\treturn [GeometryEditorOperation];\n\t},\n\tgetClass: function () {\n\t\treturn CoordinateOperation;\n\t}\n});\nfunction CoordinateSequenceOperation() {}\nextend(CoordinateSequenceOperation.prototype, {\n\tedit: function (geometry, factory) {\n\t\tif (geometry instanceof LinearRing) {\n\t\t\treturn factory.createLinearRing(this.edit(geometry.getCoordinateSequence(), geometry));\n\t\t}\n\t\tif (geometry instanceof LineString) {\n\t\t\treturn factory.createLineString(this.edit(geometry.getCoordinateSequence(), geometry));\n\t\t}\n\t\tif (geometry instanceof Point) {\n\t\t\treturn factory.createPoint(this.edit(geometry.getCoordinateSequence(), geometry));\n\t\t}\n\t\treturn geometry;\n\t},\n\tinterfaces_: function () {\n\t\treturn [GeometryEditorOperation];\n\t},\n\tgetClass: function () {\n\t\treturn CoordinateSequenceOperation;\n\t}\n});\nGeometryEditor.NoOpGeometryOperation = NoOpGeometryOperation;\nGeometryEditor.CoordinateOperation = CoordinateOperation;\nGeometryEditor.CoordinateSequenceOperation = CoordinateSequenceOperation;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/util/GeometryEditor.js\n// module id = 152\n// module chunks = 0","import CoordinateSequenceFactory from '../CoordinateSequenceFactory';\nimport hasInterface from '../../../../../hasInterface';\nimport CoordinateArraySequence from './CoordinateArraySequence';\nimport extend from '../../../../../extend';\nimport CoordinateSequence from '../CoordinateSequence';\nimport Serializable from '../../../../../java/io/Serializable';\nexport default function CoordinateArraySequenceFactory() {}\nextend(CoordinateArraySequenceFactory.prototype, {\n\treadResolve: function () {\n\t\treturn CoordinateArraySequenceFactory.instance();\n\t},\n\tcreate: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn new CoordinateArraySequence(coordinates);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordSeq = arguments[0];\n\t\t\t\treturn new CoordinateArraySequence(coordSeq);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet size = arguments[0], dimension = arguments[1];\n\t\t\tif (dimension > 3) dimension = 3;\n\t\t\tif (dimension < 2) return new CoordinateArraySequence(size);\n\t\t\treturn new CoordinateArraySequence(size, dimension);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [CoordinateSequenceFactory, Serializable];\n\t},\n\tgetClass: function () {\n\t\treturn CoordinateArraySequenceFactory;\n\t}\n});\nCoordinateArraySequenceFactory.instance = function () {\n\treturn CoordinateArraySequenceFactory.instanceObject;\n};\nCoordinateArraySequenceFactory.serialVersionUID = -4099577099607551657;\nCoordinateArraySequenceFactory.instanceObject = new CoordinateArraySequenceFactory();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/impl/CoordinateArraySequenceFactory.js\n// module id = 153\n// module chunks = 0","// shared pointer\nvar i\n// shortcuts\nvar defineProperty = Object.defineProperty\nfunction is (a, b) { return (a === b) || (a !== a && b !== b) } // eslint-disable-line\n\nexport default createCollection({\n  // WeakMap#delete(key:void*):boolean\n  'delete': sharedDelete,\n  // :was Map#get(key:void*[, d3fault:void*]):void*\n  // Map#has(key:void*):boolean\n  has: mapHas,\n  // Map#get(key:void*):boolean\n  get: sharedGet,\n  // Map#set(key:void*, value:void*):void\n  set: sharedSet,\n  // Map#keys(void):Iterator\n  keys: sharedKeys,\n  // Map#values(void):Iterator\n  values: sharedValues,\n  // Map#entries(void):Iterator\n  entries: mapEntries,\n  // Map#forEach(callback:Function, context:void*):void ==> callback.call(context, key, value, mapObject) === not in specs`\n  forEach: sharedForEach,\n  // Map#clear():\n  clear: sharedClear\n})\n\nfunction createCollection (proto, objectOnly) {\n  function Collection (a) {\n    if (!this || this.constructor !== Collection) return new Collection(a)\n    this._keys = []\n    this._values = []\n    this._itp = [] // iteration pointers\n    this.objectOnly = objectOnly\n\n    // parse initial iterable argument passed\n    if (a) init.call(this, a)\n  }\n\n  // define size for non object-only collections\n  if (!objectOnly) {\n    defineProperty(proto, 'size', {\n      get: sharedSize\n    })\n  }\n\n  // set prototype\n  proto.constructor = Collection\n  Collection.prototype = proto\n\n  return Collection\n}\n\nfunction init (a) {\n  // init Set argument, like `[1,2,3,{}]`\n  if (this.add) a.forEach(this.add, this)\n  // init Map argument like `[[1,2], [{}, 4]]`\n  else a.forEach(function (a) { this.set(a[0], a[1]) }, this)\n}\n\nfunction sharedDelete (key) {\n  if (this.has(key)) {\n    this._keys.splice(i, 1)\n    this._values.splice(i, 1)\n    // update iteration pointers\n    this._itp.forEach(function (p) { if (i < p[0]) p[0]-- })\n  }\n  // Aurora here does it while Canary doesn't\n  return i > -1\n}\n\nfunction sharedGet (key) {\n  return this.has(key) ? this._values[i] : undefined\n}\n\nfunction has (list, key) {\n  if (this.objectOnly && key !== Object(key)) throw new TypeError('Invalid value used as weak collection key')\n  // NaN or 0 passed\n  if (key !== key || key === 0) for (i = list.length; i-- && !is(list[i], key);) {} // eslint-disable-line\n  else i = list.indexOf(key)\n  return i > -1\n}\n\nfunction mapHas (value) {\n  return has.call(this, this._keys, value)\n}\n\nfunction sharedSet (key, value) {\n  this.has(key) ? this._values[i] = value : this._values[this._keys.push(key) - 1] = value\n  return this\n}\n\nfunction sharedClear () {\n  (this._keys || 0).length =\n    this._values.length = 0\n}\n\nfunction sharedKeys () {\n  return sharedIterator(this._itp, this._keys)\n}\n\nfunction sharedValues () {\n  return sharedIterator(this._itp, this._values)\n}\n\nfunction mapEntries () {\n  return sharedIterator(this._itp, this._keys, this._values)\n}\n\nfunction sharedIterator (itp, array, array2) {\n  var p = [0]\n  var done = false\n  itp.push(p)\n  return {\n    next: function () {\n      var v\n      var k = p[0]\n      if (!done && k < array.length) {\n        v = array2 ? [array[k], array2[k]] : array[k]\n        p[0]++\n      } else {\n        done = true\n        itp.splice(itp.indexOf(p), 1)\n      }\n      return { done: done, value: v }\n    }\n  }\n}\n\nfunction sharedSize () {\n  return this._values.length\n}\n\nfunction sharedForEach (callback, context) {\n  var it = this.entries()\n  for (;;) {\n    var r = it.next()\n    if (r.done) break\n    callback.call(context, r.value[1], r.value[0], this)\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/Map.js\n// module id = 154\n// module chunks = 0","import BufferOp from './buffer/BufferOp'\nimport BufferParameters from './buffer/BufferParameters'\n\nexport {\n  BufferOp,\n  BufferParameters\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/operation/buffer.js\n// module id = 155\n// module chunks = 0","import BufferParameters from './BufferParameters';\nimport Geometry from '../../geom/Geometry';\nimport BufferBuilder from './BufferBuilder';\nimport ScaledNoder from '../../noding/ScaledNoder';\nimport TopologyException from '../../geom/TopologyException';\nimport extend from '../../../../../extend';\nimport MathUtil from '../../math/MathUtil';\nimport PrecisionModel from '../../geom/PrecisionModel';\nimport RuntimeException from '../../../../../java/lang/RuntimeException';\nimport MCIndexSnapRounder from '../../noding/snapround/MCIndexSnapRounder';\nexport default function BufferOp() {\n\tthis._argGeom = null;\n\tthis._distance = null;\n\tthis._bufParams = new BufferParameters();\n\tthis._resultGeometry = null;\n\tthis._saveException = null;\n\tif (arguments.length === 1) {\n\t\tlet g = arguments[0];\n\t\tthis._argGeom = g;\n\t} else if (arguments.length === 2) {\n\t\tlet g = arguments[0], bufParams = arguments[1];\n\t\tthis._argGeom = g;\n\t\tthis._bufParams = bufParams;\n\t}\n}\nextend(BufferOp.prototype, {\n\tbufferFixedPrecision: function (fixedPM) {\n\t\tvar noder = new ScaledNoder(new MCIndexSnapRounder(new PrecisionModel(1.0)), fixedPM.getScale());\n\t\tvar bufBuilder = new BufferBuilder(this._bufParams);\n\t\tbufBuilder.setWorkingPrecisionModel(fixedPM);\n\t\tbufBuilder.setNoder(noder);\n\t\tthis._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);\n\t},\n\tbufferReducedPrecision: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tfor (var precDigits = BufferOp.MAX_PRECISION_DIGITS; precDigits >= 0; precDigits--) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.bufferReducedPrecision(precDigits);\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tif (ex instanceof TopologyException) {\n\t\t\t\t\t\tthis._saveException = ex;\n\t\t\t\t\t} else throw ex;\n\t\t\t\t} finally {}\n\t\t\t\tif (this._resultGeometry !== null) return null;\n\t\t\t}\n\t\t\tthrow this._saveException;\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet precisionDigits = arguments[0];\n\t\t\tvar sizeBasedScaleFactor = BufferOp.precisionScaleFactor(this._argGeom, this._distance, precisionDigits);\n\t\t\tvar fixedPM = new PrecisionModel(sizeBasedScaleFactor);\n\t\t\tthis.bufferFixedPrecision(fixedPM);\n\t\t}\n\t},\n\tcomputeGeometry: function () {\n\t\tthis.bufferOriginalPrecision();\n\t\tif (this._resultGeometry !== null) return null;\n\t\tvar argPM = this._argGeom.getFactory().getPrecisionModel();\n\t\tif (argPM.getType() === PrecisionModel.FIXED) this.bufferFixedPrecision(argPM); else this.bufferReducedPrecision();\n\t},\n\tsetQuadrantSegments: function (quadrantSegments) {\n\t\tthis._bufParams.setQuadrantSegments(quadrantSegments);\n\t},\n\tbufferOriginalPrecision: function () {\n\t\ttry {\n\t\t\tvar bufBuilder = new BufferBuilder(this._bufParams);\n\t\t\tthis._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof RuntimeException) {\n\t\t\t\tthis._saveException = ex;\n\t\t\t} else throw ex;\n\t\t} finally {}\n\t},\n\tgetResultGeometry: function (distance) {\n\t\tthis._distance = distance;\n\t\tthis.computeGeometry();\n\t\treturn this._resultGeometry;\n\t},\n\tsetEndCapStyle: function (endCapStyle) {\n\t\tthis._bufParams.setEndCapStyle(endCapStyle);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn BufferOp;\n\t}\n});\nBufferOp.bufferOp = function () {\n\tif (arguments.length === 2) {\n\t\tlet g = arguments[0], distance = arguments[1];\n\t\tvar gBuf = new BufferOp(g);\n\t\tvar geomBuf = gBuf.getResultGeometry(distance);\n\t\treturn geomBuf;\n\t} else if (arguments.length === 3) {\n\t\tif (Number.isInteger(arguments[2]) && (arguments[0] instanceof Geometry && typeof arguments[1] === \"number\")) {\n\t\t\tlet g = arguments[0], distance = arguments[1], quadrantSegments = arguments[2];\n\t\t\tvar bufOp = new BufferOp(g);\n\t\t\tbufOp.setQuadrantSegments(quadrantSegments);\n\t\t\tvar geomBuf = bufOp.getResultGeometry(distance);\n\t\t\treturn geomBuf;\n\t\t} else if (arguments[2] instanceof BufferParameters && (arguments[0] instanceof Geometry && typeof arguments[1] === \"number\")) {\n\t\t\tlet g = arguments[0], distance = arguments[1], params = arguments[2];\n\t\t\tvar bufOp = new BufferOp(g, params);\n\t\t\tvar geomBuf = bufOp.getResultGeometry(distance);\n\t\t\treturn geomBuf;\n\t\t}\n\t} else if (arguments.length === 4) {\n\t\tlet g = arguments[0], distance = arguments[1], quadrantSegments = arguments[2], endCapStyle = arguments[3];\n\t\tvar bufOp = new BufferOp(g);\n\t\tbufOp.setQuadrantSegments(quadrantSegments);\n\t\tbufOp.setEndCapStyle(endCapStyle);\n\t\tvar geomBuf = bufOp.getResultGeometry(distance);\n\t\treturn geomBuf;\n\t}\n};\nBufferOp.precisionScaleFactor = function (g, distance, maxPrecisionDigits) {\n\tvar env = g.getEnvelopeInternal();\n\tvar envMax = MathUtil.max(Math.abs(env.getMaxX()), Math.abs(env.getMaxY()), Math.abs(env.getMinX()), Math.abs(env.getMinY()));\n\tvar expandByDistance = distance > 0.0 ? distance : 0.0;\n\tvar bufEnvMax = envMax + 2 * expandByDistance;\n\tvar bufEnvPrecisionDigits = Math.trunc(Math.log(bufEnvMax) / Math.log(10) + 1.0);\n\tvar minUnitLog10 = maxPrecisionDigits - bufEnvPrecisionDigits;\n\tvar scaleFactor = Math.pow(10.0, minUnitLog10);\n\treturn scaleFactor;\n};\nBufferOp.CAP_ROUND = BufferParameters.CAP_ROUND;\nBufferOp.CAP_BUTT = BufferParameters.CAP_FLAT;\nBufferOp.CAP_FLAT = BufferParameters.CAP_FLAT;\nBufferOp.CAP_SQUARE = BufferParameters.CAP_SQUARE;\nBufferOp.MAX_PRECISION_DIGITS = 12;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/operation/buffer/BufferOp.js\n// module id = 156\n// module chunks = 0","import Location from '../../geom/Location';\nimport BufferSubgraph from './BufferSubgraph';\nimport PolygonBuilder from '../overlay/PolygonBuilder';\nimport GeometryFactory from '../../geom/GeometryFactory';\nimport Position from '../../geomgraph/Position';\nimport MCIndexNoder from '../../noding/MCIndexNoder';\nimport OffsetCurveBuilder from './OffsetCurveBuilder';\nimport extend from '../../../../../extend';\nimport Collections from '../../../../../java/util/Collections';\nimport SubgraphDepthLocater from './SubgraphDepthLocater';\nimport OffsetCurveSetBuilder from './OffsetCurveSetBuilder';\nimport Label from '../../geomgraph/Label';\nimport OverlayNodeFactory from '../overlay/OverlayNodeFactory';\nimport EdgeList from '../../geomgraph/EdgeList';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport RobustLineIntersector from '../../algorithm/RobustLineIntersector';\nimport IntersectionAdder from '../../noding/IntersectionAdder';\nimport Edge from '../../geomgraph/Edge';\nimport PlanarGraph from '../../geomgraph/PlanarGraph';\nexport default function BufferBuilder() {\n\tthis._bufParams = null;\n\tthis._workingPrecisionModel = null;\n\tthis._workingNoder = null;\n\tthis._geomFact = null;\n\tthis._graph = null;\n\tthis._edgeList = new EdgeList();\n\tlet bufParams = arguments[0];\n\tthis._bufParams = bufParams;\n}\nextend(BufferBuilder.prototype, {\n\tsetWorkingPrecisionModel: function (pm) {\n\t\tthis._workingPrecisionModel = pm;\n\t},\n\tinsertUniqueEdge: function (e) {\n\t\tvar existingEdge = this._edgeList.findEqualEdge(e);\n\t\tif (existingEdge !== null) {\n\t\t\tvar existingLabel = existingEdge.getLabel();\n\t\t\tvar labelToMerge = e.getLabel();\n\t\t\tif (!existingEdge.isPointwiseEqual(e)) {\n\t\t\t\tlabelToMerge = new Label(e.getLabel());\n\t\t\t\tlabelToMerge.flip();\n\t\t\t}\n\t\t\texistingLabel.merge(labelToMerge);\n\t\t\tvar mergeDelta = BufferBuilder.depthDelta(labelToMerge);\n\t\t\tvar existingDelta = existingEdge.getDepthDelta();\n\t\t\tvar newDelta = existingDelta + mergeDelta;\n\t\t\texistingEdge.setDepthDelta(newDelta);\n\t\t} else {\n\t\t\tthis._edgeList.add(e);\n\t\t\te.setDepthDelta(BufferBuilder.depthDelta(e.getLabel()));\n\t\t}\n\t},\n\tbuildSubgraphs: function (subgraphList, polyBuilder) {\n\t\tvar processedGraphs = new ArrayList();\n\t\tfor (var i = subgraphList.iterator(); i.hasNext(); ) {\n\t\t\tvar subgraph = i.next();\n\t\t\tvar p = subgraph.getRightmostCoordinate();\n\t\t\tvar locater = new SubgraphDepthLocater(processedGraphs);\n\t\t\tvar outsideDepth = locater.getDepth(p);\n\t\t\tsubgraph.computeDepth(outsideDepth);\n\t\t\tsubgraph.findResultEdges();\n\t\t\tprocessedGraphs.add(subgraph);\n\t\t\tpolyBuilder.add(subgraph.getDirectedEdges(), subgraph.getNodes());\n\t\t}\n\t},\n\tcreateSubgraphs: function (graph) {\n\t\tvar subgraphList = new ArrayList();\n\t\tfor (var i = graph.getNodes().iterator(); i.hasNext(); ) {\n\t\t\tvar node = i.next();\n\t\t\tif (!node.isVisited()) {\n\t\t\t\tvar subgraph = new BufferSubgraph();\n\t\t\t\tsubgraph.create(node);\n\t\t\t\tsubgraphList.add(subgraph);\n\t\t\t}\n\t\t}\n\t\tCollections.sort(subgraphList, Collections.reverseOrder());\n\t\treturn subgraphList;\n\t},\n\tcreateEmptyResultGeometry: function () {\n\t\tvar emptyGeom = this._geomFact.createPolygon();\n\t\treturn emptyGeom;\n\t},\n\tgetNoder: function (precisionModel) {\n\t\tif (this._workingNoder !== null) return this._workingNoder;\n\t\tvar noder = new MCIndexNoder();\n\t\tvar li = new RobustLineIntersector();\n\t\tli.setPrecisionModel(precisionModel);\n\t\tnoder.setSegmentIntersector(new IntersectionAdder(li));\n\t\treturn noder;\n\t},\n\tbuffer: function (g, distance) {\n\t\tvar precisionModel = this._workingPrecisionModel;\n\t\tif (precisionModel === null) precisionModel = g.getPrecisionModel();\n\t\tthis._geomFact = g.getFactory();\n\t\tvar curveBuilder = new OffsetCurveBuilder(precisionModel, this._bufParams);\n\t\tvar curveSetBuilder = new OffsetCurveSetBuilder(g, distance, curveBuilder);\n\t\tvar bufferSegStrList = curveSetBuilder.getCurves();\n\t\tif (bufferSegStrList.size() <= 0) {\n\t\t\treturn this.createEmptyResultGeometry();\n\t\t}\n\t\tthis.computeNodedEdges(bufferSegStrList, precisionModel);\n\t\tthis._graph = new PlanarGraph(new OverlayNodeFactory());\n\t\tthis._graph.addEdges(this._edgeList.getEdges());\n\t\tvar subgraphList = this.createSubgraphs(this._graph);\n\t\tvar polyBuilder = new PolygonBuilder(this._geomFact);\n\t\tthis.buildSubgraphs(subgraphList, polyBuilder);\n\t\tvar resultPolyList = polyBuilder.getPolygons();\n\t\tif (resultPolyList.size() <= 0) {\n\t\t\treturn this.createEmptyResultGeometry();\n\t\t}\n\t\tvar resultGeom = this._geomFact.buildGeometry(resultPolyList);\n\t\treturn resultGeom;\n\t},\n\tcomputeNodedEdges: function (bufferSegStrList, precisionModel) {\n\t\tvar noder = this.getNoder(precisionModel);\n\t\tnoder.computeNodes(bufferSegStrList);\n\t\tvar nodedSegStrings = noder.getNodedSubstrings();\n\t\tfor (var i = nodedSegStrings.iterator(); i.hasNext(); ) {\n\t\t\tvar segStr = i.next();\n\t\t\tvar pts = segStr.getCoordinates();\n\t\t\tif (pts.length === 2 && pts[0].equals2D(pts[1])) continue;\n\t\t\tvar oldLabel = segStr.getData();\n\t\t\tvar edge = new Edge(segStr.getCoordinates(), new Label(oldLabel));\n\t\t\tthis.insertUniqueEdge(edge);\n\t\t}\n\t},\n\tsetNoder: function (noder) {\n\t\tthis._workingNoder = noder;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn BufferBuilder;\n\t}\n});\nBufferBuilder.depthDelta = function (label) {\n\tvar lLoc = label.getLocation(0, Position.LEFT);\n\tvar rLoc = label.getLocation(0, Position.RIGHT);\n\tif (lLoc === Location.INTERIOR && rLoc === Location.EXTERIOR) return 1; else if (lLoc === Location.EXTERIOR && rLoc === Location.INTERIOR) return -1;\n\treturn 0;\n};\nBufferBuilder.convertSegStrings = function (it) {\n\tvar fact = new GeometryFactory();\n\tvar lines = new ArrayList();\n\twhile (it.hasNext()) {\n\t\tvar ss = it.next();\n\t\tvar line = fact.createLineString(ss.getCoordinates());\n\t\tlines.add(line);\n\t}\n\treturn fact.buildGeometry(lines);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/operation/buffer/BufferBuilder.js\n// module id = 157\n// module chunks = 0","import HashSet from '../../../../../java/util/HashSet';\nimport Position from '../../geomgraph/Position';\nimport Stack from '../../../../../java/util/Stack';\nimport RightmostEdgeFinder from './RightmostEdgeFinder';\nimport TopologyException from '../../geom/TopologyException';\nimport extend from '../../../../../extend';\nimport LinkedList from '../../../../../java/util/LinkedList';\nimport Comparable from '../../../../../java/lang/Comparable';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Envelope from '../../geom/Envelope';\nexport default function BufferSubgraph() {\n\tthis._finder = null;\n\tthis._dirEdgeList = new ArrayList();\n\tthis._nodes = new ArrayList();\n\tthis._rightMostCoord = null;\n\tthis._env = null;\n\tthis._finder = new RightmostEdgeFinder();\n}\nextend(BufferSubgraph.prototype, {\n\tclearVisitedEdges: function () {\n\t\tfor (var it = this._dirEdgeList.iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tde.setVisited(false);\n\t\t}\n\t},\n\tgetRightmostCoordinate: function () {\n\t\treturn this._rightMostCoord;\n\t},\n\tcomputeNodeDepth: function (n) {\n\t\tvar startEdge = null;\n\t\tfor (var i = n.getEdges().iterator(); i.hasNext(); ) {\n\t\t\tvar de = i.next();\n\t\t\tif (de.isVisited() || de.getSym().isVisited()) {\n\t\t\t\tstartEdge = de;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (startEdge === null) throw new TopologyException(\"unable to find edge to compute depths at \" + n.getCoordinate());\n\t\tn.getEdges().computeDepths(startEdge);\n\t\tfor (var i = n.getEdges().iterator(); i.hasNext(); ) {\n\t\t\tvar de = i.next();\n\t\t\tde.setVisited(true);\n\t\t\tthis.copySymDepths(de);\n\t\t}\n\t},\n\tcomputeDepth: function (outsideDepth) {\n\t\tthis.clearVisitedEdges();\n\t\tvar de = this._finder.getEdge();\n\t\tvar n = de.getNode();\n\t\tvar label = de.getLabel();\n\t\tde.setEdgeDepths(Position.RIGHT, outsideDepth);\n\t\tthis.copySymDepths(de);\n\t\tthis.computeDepths(de);\n\t},\n\tcreate: function (node) {\n\t\tthis.addReachable(node);\n\t\tthis._finder.findEdge(this._dirEdgeList);\n\t\tthis._rightMostCoord = this._finder.getCoordinate();\n\t},\n\tfindResultEdges: function () {\n\t\tfor (var it = this._dirEdgeList.iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tif (de.getDepth(Position.RIGHT) >= 1 && de.getDepth(Position.LEFT) <= 0 && !de.isInteriorAreaEdge()) {\n\t\t\t\tde.setInResult(true);\n\t\t\t}\n\t\t}\n\t},\n\tcomputeDepths: function (startEdge) {\n\t\tvar nodesVisited = new HashSet();\n\t\tvar nodeQueue = new LinkedList();\n\t\tvar startNode = startEdge.getNode();\n\t\tnodeQueue.addLast(startNode);\n\t\tnodesVisited.add(startNode);\n\t\tstartEdge.setVisited(true);\n\t\twhile (!nodeQueue.isEmpty()) {\n\t\t\tvar n = nodeQueue.removeFirst();\n\t\t\tnodesVisited.add(n);\n\t\t\tthis.computeNodeDepth(n);\n\t\t\tfor (var i = n.getEdges().iterator(); i.hasNext(); ) {\n\t\t\t\tvar de = i.next();\n\t\t\t\tvar sym = de.getSym();\n\t\t\t\tif (sym.isVisited()) continue;\n\t\t\t\tvar adjNode = sym.getNode();\n\t\t\t\tif (!nodesVisited.contains(adjNode)) {\n\t\t\t\t\tnodeQueue.addLast(adjNode);\n\t\t\t\t\tnodesVisited.add(adjNode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tcompareTo: function (o) {\n\t\tvar graph = o;\n\t\tif (this._rightMostCoord.x < graph._rightMostCoord.x) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (this._rightMostCoord.x > graph._rightMostCoord.x) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t},\n\tgetEnvelope: function () {\n\t\tif (this._env === null) {\n\t\t\tvar edgeEnv = new Envelope();\n\t\t\tfor (var it = this._dirEdgeList.iterator(); it.hasNext(); ) {\n\t\t\t\tvar dirEdge = it.next();\n\t\t\t\tvar pts = dirEdge.getEdge().getCoordinates();\n\t\t\t\tfor (var i = 0; i < pts.length - 1; i++) {\n\t\t\t\t\tedgeEnv.expandToInclude(pts[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._env = edgeEnv;\n\t\t}\n\t\treturn this._env;\n\t},\n\taddReachable: function (startNode) {\n\t\tvar nodeStack = new Stack();\n\t\tnodeStack.add(startNode);\n\t\twhile (!nodeStack.empty()) {\n\t\t\tvar node = nodeStack.pop();\n\t\t\tthis.add(node, nodeStack);\n\t\t}\n\t},\n\tcopySymDepths: function (de) {\n\t\tvar sym = de.getSym();\n\t\tsym.setDepth(Position.LEFT, de.getDepth(Position.RIGHT));\n\t\tsym.setDepth(Position.RIGHT, de.getDepth(Position.LEFT));\n\t},\n\tadd: function (node, nodeStack) {\n\t\tnode.setVisited(true);\n\t\tthis._nodes.add(node);\n\t\tfor (var i = node.getEdges().iterator(); i.hasNext(); ) {\n\t\t\tvar de = i.next();\n\t\t\tthis._dirEdgeList.add(de);\n\t\t\tvar sym = de.getSym();\n\t\t\tvar symNode = sym.getNode();\n\t\t\tif (!symNode.isVisited()) nodeStack.push(symNode);\n\t\t}\n\t},\n\tgetNodes: function () {\n\t\treturn this._nodes;\n\t},\n\tgetDirectedEdges: function () {\n\t\treturn this._dirEdgeList;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparable];\n\t},\n\tgetClass: function () {\n\t\treturn BufferSubgraph;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/operation/buffer/BufferSubgraph.js\n// module id = 158\n// module chunks = 0","import EmptyStackException from './EmptyStackException'\nimport List from './List'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Stack.html\n *\n * @extends {List}\n * @constructor\n * @private\n */\nexport default function Stack() {\n  /**\n   * @type {Array}\n   * @private\n   */\n  this.array_ = [];\n};\nStack.prototype = new List();\n\n\n/**\n * @override\n */\nStack.prototype.add = function(e) {\n  this.array_.push(e);\n  return true;\n};\n\n\n/**\n * @override\n */\nStack.prototype.get = function(index) {\n  if (index < 0 || index >= this.size()) {\n    throw new IndexOutOfBoundsException();\n  }\n\n  return this.array_[index];\n};\n\n\n/**\n * Pushes an item onto the top of this stack.\n * @param {Object} e\n * @return {Object}\n */\nStack.prototype.push = function(e) {\n  this.array_.push(e);\n  return e;\n};\n\n\n/**\n * Pushes an item onto the top of this stack.\n * @param {Object} e\n * @return {Object}\n */\nStack.prototype.pop = function(e) {\n  if (this.array_.length === 0) {\n    throw new EmptyStackException();\n  }\n\n  return this.array_.pop();\n};\n\n\n/**\n * Looks at the object at the top of this stack without removing it from the\n * stack.\n * @return {Object}\n */\nStack.prototype.peek = function() {\n  if (this.array_.length === 0) {\n    throw new EmptyStackException();\n  }\n\n  return this.array_[this.array_.length - 1];\n};\n\n\n/**\n * Tests if this stack is empty.\n * @return {boolean} true if and only if this stack contains no items; false\n *         otherwise.\n */\nStack.prototype.empty = function() {\n  if (this.array_.length === 0) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n\n/**\n * @return {boolean}\n */\nStack.prototype.isEmpty = function() {\n  return this.empty();\n};\n\n\n/**\n * Returns the 1-based position where an object is on this stack. If the object\n * o occurs as an item in this stack, this method returns the distance from the\n * top of the stack of the occurrence nearest the top of the stack; the topmost\n * item on the stack is considered to be at distance 1. The equals method is\n * used to compare o to the items in this stack.\n *\n * NOTE: does not currently actually use equals. (=== is used)\n *\n * @param {Object} o\n * @return {number} the 1-based position from the top of the stack where the\n *         object is located; the return value -1 indicates that the object is\n *         not on the stack.\n */\nStack.prototype.search = function(o) {\n  return this.array_.indexOf(o);\n};\n\n\n/**\n * @return {number}\n * @export\n */\nStack.prototype.size = function() {\n  return this.array_.length;\n};\n\n\n/**\n * @return {Array}\n */\nStack.prototype.toArray = function() {\n  var array = [];\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    array.push(this.array_[i]);\n  }\n\n  return array;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/util/Stack.js\n// module id = 159\n// module chunks = 0","/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nexport default function EmptyStackException(message) {\n  this.message = message || '';\n};\nEmptyStackException.prototype = new Error();\n\n\n/**\n * @type {string}\n */\nEmptyStackException.prototype.name = 'EmptyStackException';\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/util/EmptyStackException.js\n// module id = 160\n// module chunks = 0","import Position from '../../geomgraph/Position';\nimport extend from '../../../../../extend';\nimport Orientation from '../../algorithm/Orientation';\nimport Assert from '../../util/Assert';\nexport default function RightmostEdgeFinder() {\n\tthis._minIndex = -1;\n\tthis._minCoord = null;\n\tthis._minDe = null;\n\tthis._orientedDe = null;\n}\nextend(RightmostEdgeFinder.prototype, {\n\tgetCoordinate: function () {\n\t\treturn this._minCoord;\n\t},\n\tgetRightmostSide: function (de, index) {\n\t\tvar side = this.getRightmostSideOfSegment(de, index);\n\t\tif (side < 0) side = this.getRightmostSideOfSegment(de, index - 1);\n\t\tif (side < 0) {\n\t\t\tthis._minCoord = null;\n\t\t\tthis.checkForRightmostCoordinate(de);\n\t\t}\n\t\treturn side;\n\t},\n\tfindRightmostEdgeAtVertex: function () {\n\t\tvar pts = this._minDe.getEdge().getCoordinates();\n\t\tAssert.isTrue(this._minIndex > 0 && this._minIndex < pts.length, \"rightmost point expected to be interior vertex of edge\");\n\t\tvar pPrev = pts[this._minIndex - 1];\n\t\tvar pNext = pts[this._minIndex + 1];\n\t\tvar orientation = Orientation.index(this._minCoord, pNext, pPrev);\n\t\tvar usePrev = false;\n\t\tif (pPrev.y < this._minCoord.y && pNext.y < this._minCoord.y && orientation === Orientation.COUNTERCLOCKWISE) {\n\t\t\tusePrev = true;\n\t\t} else if (pPrev.y > this._minCoord.y && pNext.y > this._minCoord.y && orientation === Orientation.CLOCKWISE) {\n\t\t\tusePrev = true;\n\t\t}\n\t\tif (usePrev) {\n\t\t\tthis._minIndex = this._minIndex - 1;\n\t\t}\n\t},\n\tgetRightmostSideOfSegment: function (de, i) {\n\t\tvar e = de.getEdge();\n\t\tvar coord = e.getCoordinates();\n\t\tif (i < 0 || i + 1 >= coord.length) return -1;\n\t\tif (coord[i].y === coord[i + 1].y) return -1;\n\t\tvar pos = Position.LEFT;\n\t\tif (coord[i].y < coord[i + 1].y) pos = Position.RIGHT;\n\t\treturn pos;\n\t},\n\tgetEdge: function () {\n\t\treturn this._orientedDe;\n\t},\n\tcheckForRightmostCoordinate: function (de) {\n\t\tvar coord = de.getEdge().getCoordinates();\n\t\tfor (var i = 0; i < coord.length - 1; i++) {\n\t\t\tif (this._minCoord === null || coord[i].x > this._minCoord.x) {\n\t\t\t\tthis._minDe = de;\n\t\t\t\tthis._minIndex = i;\n\t\t\t\tthis._minCoord = coord[i];\n\t\t\t}\n\t\t}\n\t},\n\tfindRightmostEdgeAtNode: function () {\n\t\tvar node = this._minDe.getNode();\n\t\tvar star = node.getEdges();\n\t\tthis._minDe = star.getRightmostEdge();\n\t\tif (!this._minDe.isForward()) {\n\t\t\tthis._minDe = this._minDe.getSym();\n\t\t\tthis._minIndex = this._minDe.getEdge().getCoordinates().length - 1;\n\t\t}\n\t},\n\tfindEdge: function (dirEdgeList) {\n\t\tfor (var i = dirEdgeList.iterator(); i.hasNext(); ) {\n\t\t\tvar de = i.next();\n\t\t\tif (!de.isForward()) continue;\n\t\t\tthis.checkForRightmostCoordinate(de);\n\t\t}\n\t\tAssert.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), \"inconsistency in rightmost processing\");\n\t\tif (this._minIndex === 0) {\n\t\t\tthis.findRightmostEdgeAtNode();\n\t\t} else {\n\t\t\tthis.findRightmostEdgeAtVertex();\n\t\t}\n\t\tthis._orientedDe = this._minDe;\n\t\tvar rightmostSide = this.getRightmostSide(this._minDe, this._minIndex);\n\t\tif (rightmostSide === Position.LEFT) {\n\t\t\tthis._orientedDe = this._minDe.getSym();\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn RightmostEdgeFinder;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/operation/buffer/RightmostEdgeFinder.js\n// module id = 161\n// module chunks = 0","export default function LinkedList () {\n  this.array_ = []\n}\nLinkedList.prototype.addLast = function (e) {\n  this.array_.push(e)\n}\nLinkedList.prototype.removeFirst = function () {\n  return this.array_.shift()\n}\nLinkedList.prototype.isEmpty = function () {\n  return this.array_.length === 0\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/java/util/LinkedList.js\n// module id = 162\n// module chunks = 0","import WKTWriter from '../io/WKTWriter';\nimport Coordinate from '../geom/Coordinate';\nimport extend from '../../../../extend';\nimport Assert from '../util/Assert';\nimport StringBuilder from '../../../../java/lang/StringBuilder';\nexport default function LineIntersector() {\n\tthis._result = null;\n\tthis._inputLines = Array(2).fill().map(() => Array(2));\n\tthis._intPt = new Array(2).fill(null);\n\tthis._intLineIndex = null;\n\tthis._isProper = null;\n\tthis._pa = null;\n\tthis._pb = null;\n\tthis._precisionModel = null;\n\tthis._intPt[0] = new Coordinate();\n\tthis._intPt[1] = new Coordinate();\n\tthis._pa = this._intPt[0];\n\tthis._pb = this._intPt[1];\n\tthis._result = 0;\n}\nextend(LineIntersector.prototype, {\n\tgetIndexAlongSegment: function (segmentIndex, intIndex) {\n\t\tthis.computeIntLineIndex();\n\t\treturn this._intLineIndex[segmentIndex][intIndex];\n\t},\n\tgetTopologySummary: function () {\n\t\tvar catBuilder = new StringBuilder();\n\t\tif (this.isEndPoint()) catBuilder.append(\" endpoint\");\n\t\tif (this._isProper) catBuilder.append(\" proper\");\n\t\tif (this.isCollinear()) catBuilder.append(\" collinear\");\n\t\treturn catBuilder.toString();\n\t},\n\tcomputeIntersection: function (p1, p2, p3, p4) {\n\t\tthis._inputLines[0][0] = p1;\n\t\tthis._inputLines[0][1] = p2;\n\t\tthis._inputLines[1][0] = p3;\n\t\tthis._inputLines[1][1] = p4;\n\t\tthis._result = this.computeIntersect(p1, p2, p3, p4);\n\t},\n\tgetIntersectionNum: function () {\n\t\treturn this._result;\n\t},\n\tcomputeIntLineIndex: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tif (this._intLineIndex === null) {\n\t\t\t\tthis._intLineIndex = Array(2).fill().map(() => Array(2));\n\t\t\t\tthis.computeIntLineIndex(0);\n\t\t\t\tthis.computeIntLineIndex(1);\n\t\t\t}\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet segmentIndex = arguments[0];\n\t\t\tvar dist0 = this.getEdgeDistance(segmentIndex, 0);\n\t\t\tvar dist1 = this.getEdgeDistance(segmentIndex, 1);\n\t\t\tif (dist0 > dist1) {\n\t\t\t\tthis._intLineIndex[segmentIndex][0] = 0;\n\t\t\t\tthis._intLineIndex[segmentIndex][1] = 1;\n\t\t\t} else {\n\t\t\t\tthis._intLineIndex[segmentIndex][0] = 1;\n\t\t\t\tthis._intLineIndex[segmentIndex][1] = 0;\n\t\t\t}\n\t\t}\n\t},\n\tisProper: function () {\n\t\treturn this.hasIntersection() && this._isProper;\n\t},\n\tsetPrecisionModel: function (precisionModel) {\n\t\tthis._precisionModel = precisionModel;\n\t},\n\tisInteriorIntersection: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tif (this.isInteriorIntersection(0)) return true;\n\t\t\tif (this.isInteriorIntersection(1)) return true;\n\t\t\treturn false;\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet inputLineIndex = arguments[0];\n\t\t\tfor (var i = 0; i < this._result; i++) {\n\t\t\t\tif (!(this._intPt[i].equals2D(this._inputLines[inputLineIndex][0]) || this._intPt[i].equals2D(this._inputLines[inputLineIndex][1]))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t},\n\tgetIntersection: function (intIndex) {\n\t\treturn this._intPt[intIndex];\n\t},\n\tisEndPoint: function () {\n\t\treturn this.hasIntersection() && !this._isProper;\n\t},\n\thasIntersection: function () {\n\t\treturn this._result !== LineIntersector.NO_INTERSECTION;\n\t},\n\tgetEdgeDistance: function (segmentIndex, intIndex) {\n\t\tvar dist = LineIntersector.computeEdgeDistance(this._intPt[intIndex], this._inputLines[segmentIndex][0], this._inputLines[segmentIndex][1]);\n\t\treturn dist;\n\t},\n\tisCollinear: function () {\n\t\treturn this._result === LineIntersector.COLLINEAR_INTERSECTION;\n\t},\n\ttoString: function () {\n\t\treturn WKTWriter.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + \" - \" + WKTWriter.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();\n\t},\n\tgetEndpoint: function (segmentIndex, ptIndex) {\n\t\treturn this._inputLines[segmentIndex][ptIndex];\n\t},\n\tisIntersection: function (pt) {\n\t\tfor (var i = 0; i < this._result; i++) {\n\t\t\tif (this._intPt[i].equals2D(pt)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetIntersectionAlongSegment: function (segmentIndex, intIndex) {\n\t\tthis.computeIntLineIndex();\n\t\treturn this._intPt[this._intLineIndex[segmentIndex][intIndex]];\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn LineIntersector;\n\t}\n});\nLineIntersector.computeEdgeDistance = function (p, p0, p1) {\n\tvar dx = Math.abs(p1.x - p0.x);\n\tvar dy = Math.abs(p1.y - p0.y);\n\tvar dist = -1.0;\n\tif (p.equals(p0)) {\n\t\tdist = 0.0;\n\t} else if (p.equals(p1)) {\n\t\tif (dx > dy) dist = dx; else dist = dy;\n\t} else {\n\t\tvar pdx = Math.abs(p.x - p0.x);\n\t\tvar pdy = Math.abs(p.y - p0.y);\n\t\tif (dx > dy) dist = pdx; else dist = pdy;\n\t\tif (dist === 0.0 && !p.equals(p0)) {\n\t\t\tdist = Math.max(pdx, pdy);\n\t\t}\n\t}\n\tAssert.isTrue(!(dist === 0.0 && !p.equals(p0)), \"Bad distance calculation\");\n\treturn dist;\n};\nLineIntersector.nonRobustComputeEdgeDistance = function (p, p1, p2) {\n\tvar dx = p.x - p1.x;\n\tvar dy = p.y - p1.y;\n\tvar dist = Math.sqrt(dx * dx + dy * dy);\n\tAssert.isTrue(!(dist === 0.0 && !p.equals(p1)), \"Invalid distance calculation\");\n\treturn dist;\n};\nLineIntersector.DONT_INTERSECT = 0;\nLineIntersector.DO_INTERSECT = 1;\nLineIntersector.COLLINEAR = 2;\nLineIntersector.NO_INTERSECTION = 0;\nLineIntersector.POINT_INTERSECTION = 1;\nLineIntersector.COLLINEAR_INTERSECTION = 2;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/algorithm/LineIntersector.js\n// module id = 163\n// module chunks = 0","import Coordinate from '../geom/Coordinate'\nimport GeometryFactory from '../geom/GeometryFactory'\nimport extend from '../../../../extend'\n\nconst regExes = {\n  'typeStr': /^\\s*(\\w+)\\s*\\(\\s*(.*)\\s*\\)\\s*$/,\n  'emptyTypeStr': /^\\s*(\\w+)\\s*EMPTY\\s*$/,\n  'spaces': /\\s+/,\n  'parenComma': /\\)\\s*,\\s*\\(/,\n  'doubleParenComma': /\\)\\s*\\)\\s*,\\s*\\(\\s*\\(/, // can't use {2} here\n  'trimParens': /^\\s*\\(?(.*?)\\)?\\s*$/\n}\n\n/**\n * Class for reading and writing Well-Known Text.\n *\n * NOTE: Adapted from OpenLayers 2.11 implementation.\n */\n\n/** Create a new parser for WKT\n *\n * @param {GeometryFactory} geometryFactory\n * @return An instance of WKTParser.\n * @constructor\n * @private\n */\nexport default function WKTParser (geometryFactory) {\n  this.geometryFactory = geometryFactory || new GeometryFactory()\n  this.precisionModel = this.geometryFactory.getPrecisionModel()\n}\n\nextend(WKTParser.prototype, {\n  /**\n   * Deserialize a WKT string and return a geometry. Supports WKT for POINT,\n   * MULTIPOINT, LINESTRING, LINEARRING, MULTILINESTRING, POLYGON, MULTIPOLYGON,\n   * and GEOMETRYCOLLECTION.\n   *\n   * @param {String} wkt A WKT string.\n   * @return {Geometry} A geometry instance.\n   * @private\n   */\n  read (wkt) {\n    var geometry, type, str\n    wkt = wkt.replace(/[\\n\\r]/g, ' ')\n    var matches = regExes.typeStr.exec(wkt)\n    if (wkt.search('EMPTY') !== -1) {\n      matches = regExes.emptyTypeStr.exec(wkt)\n      matches[2] = undefined\n    }\n    if (matches) {\n      type = matches[1].toLowerCase()\n      str = matches[2]\n      if (parse[type]) {\n        geometry = parse[type].call(this, str)\n      }\n    }\n\n    if (geometry === undefined) throw new Error('Could not parse WKT ' + wkt)\n\n    return geometry\n  },\n\n  /**\n   * Serialize a geometry into a WKT string.\n   *\n   * @param {Geometry} geometry A feature or array of features.\n   * @return {String} The WKT string representation of the input geometries.\n   * @private\n   */\n  write (geometry) {\n    return this.extractGeometry(geometry)\n  },\n\n  /**\n   * Entry point to construct the WKT for a single Geometry object.\n   *\n   * @param {Geometry} geometry\n   * @return {String} A WKT string of representing the geometry.\n   * @private\n   */\n  extractGeometry (geometry) {\n    var type = geometry.getGeometryType().toLowerCase()\n    if (!extract[type]) {\n      return null\n    }\n    var wktType = type.toUpperCase()\n    var data\n    if (geometry.isEmpty()) {\n      data = wktType + ' EMPTY'\n    } else {\n      data = wktType + '(' + extract[type].call(this, geometry) + ')'\n    }\n    return data\n  }\n})\n\n/**\n * Object with properties corresponding to the geometry types. Property values\n * are functions that do the actual data extraction.\n * @private\n */\nconst extract = {\n  coordinate (coordinate) {\n    return coordinate.x + ' ' + coordinate.y\n  },\n\n  /**\n   * Return a space delimited string of point coordinates.\n   *\n   * @param {Point}\n   *          point\n   * @return {String} A string of coordinates representing the point.\n   */\n  point (point) {\n    return extract.coordinate.call(this, point._coordinates._coordinates[0])\n  },\n\n  /**\n   * Return a comma delimited string of point coordinates from a multipoint.\n   *\n   * @param {MultiPoint}\n   *          multipoint\n   * @return {String} A string of point coordinate strings representing the\n   *         multipoint.\n   */\n  multipoint (multipoint) {\n    var array = []\n    for (let i = 0, len = multipoint._geometries.length; i < len; ++i) {\n      array.push('(' + extract.point.call(this, multipoint._geometries[i]) + ')')\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return a comma delimited string of point coordinates from a line.\n   *\n   * @param {LineString} linestring\n   * @return {String} A string of point coordinate strings representing the linestring.\n   */\n  linestring (linestring) {\n    var array = []\n    for (let i = 0, len = linestring._points._coordinates.length; i < len; ++i) {\n      array.push(extract.coordinate.call(this, linestring._points._coordinates[i]))\n    }\n    return array.join(',')\n  },\n\n  linearring (linearring) {\n    var array = []\n    for (let i = 0, len = linearring._points._coordinates.length; i < len; ++i) {\n      array.push(extract.coordinate.call(this, linearring._points._coordinates[i]))\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return a comma delimited string of linestring strings from a\n   * multilinestring.\n   *\n   * @param {MultiLineString} multilinestring\n   * @return {String} A string of of linestring strings representing the multilinestring.\n   */\n  multilinestring (multilinestring) {\n    var array = []\n    for (let i = 0, len = multilinestring._geometries.length; i < len; ++i) {\n      array.push('(' +\n        extract.linestring.call(this, multilinestring._geometries[i]) +\n        ')')\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return a comma delimited string of linear ring arrays from a polygon.\n   *\n   * @param {Polygon} polygon\n   * @return {String} An array of linear ring arrays representing the polygon.\n   */\n  polygon (polygon) {\n    var array = []\n    array.push('(' + extract.linestring.call(this, polygon._shell) + ')')\n    for (let i = 0, len = polygon._holes.length; i < len; ++i) {\n      array.push('(' + extract.linestring.call(this, polygon._holes[i]) + ')')\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return an array of polygon arrays from a multipolygon.\n   *\n   * @param {MultiPolygon} multipolygon\n   * @return {String} An array of polygon arrays representing the multipolygon.\n   */\n  multipolygon (multipolygon) {\n    var array = []\n    for (let i = 0, len = multipolygon._geometries.length; i < len; ++i) {\n      array.push('(' + extract.polygon.call(this, multipolygon._geometries[i]) + ')')\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an\n   * geometrycollection.\n   *\n   * @param {GeometryCollection} collection\n   * @return {String} internal WKT representation of the collection.\n   */\n  geometrycollection (collection) {\n    var array = []\n    for (let i = 0, len = collection._geometries.length; i < len; ++i) {\n      array.push(this.extractGeometry(collection._geometries[i]))\n    }\n    return array.join(',')\n  }\n}\n\n/**\n * Object with properties corresponding to the geometry types. Property values\n * are functions that do the actual parsing.\n * @private\n */\nconst parse = {\n  \n  coord (str) {\n    var coords = str.trim().split(regExes.spaces)\n    var coord = new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1]))\n    this.precisionModel.makePrecise(coord)\n    return coord\n  },\n\n  /**\n   * Return point geometry given a point WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the point.\n   * @return {Point} A point geometry.\n   * @private\n   */\n  point (str) {\n    if (str === undefined)\n      return this.geometryFactory.createPoint()\n    return this.geometryFactory.createPoint(parse.coord.call(this, str))\n  },\n\n  /**\n   * Return a multipoint geometry given a multipoint WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multipoint.\n   * @return {Point} A multipoint feature.\n   * @private\n   */\n  multipoint (str) {\n    if (str === undefined)\n      return this.geometryFactory.createMultiPoint()\n    var point\n    var points = str.trim().split(',')\n    var components = []\n    for (let i = 0, len = points.length; i < len; ++i) {\n      point = points[i].replace(regExes.trimParens, '$1')\n      components.push(parse.point.call(this, point))\n    }\n    return this.geometryFactory.createMultiPoint(components)\n  },\n\n  /**\n   * Return a linestring geometry given a linestring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the linestring.\n   * @return {LineString} A linestring geometry.\n   * @private\n   */\n  linestring (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createLineString()\n    }\n\n    var points = str.trim().split(',')\n    var components = []\n    var coords\n    for (let i = 0, len = points.length; i < len; ++i) {\n      components.push(parse.coord.call(this, points[i]))\n    }\n    return this.geometryFactory.createLineString(components)\n  },\n\n  /**\n   * Return a linearring geometry given a linearring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the linearring.\n   * @return {LinearRing} A linearring geometry.\n   * @private\n   */\n  linearring (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createLinearRing()\n    }\n\n    var points = str.trim().split(',')\n    var components = []\n    var coords\n    for (let i = 0, len = points.length; i < len; ++i) {\n      components.push(parse.coord.call(this, points[i]))\n    }\n    return this.geometryFactory.createLinearRing(components)\n  },\n\n  /**\n   * Return a multilinestring geometry given a multilinestring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multilinestring.\n   * @return {MultiLineString} A multilinestring geometry.\n   * @private\n   */\n  multilinestring (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createMultiLineString()\n    }\n\n    var line\n    var lines = str.trim().split(regExes.parenComma)\n    var components = []\n    for (let i = 0, len = lines.length; i < len; ++i) {\n      line = lines[i].replace(regExes.trimParens, '$1')\n      components.push(parse.linestring.call(this, line))\n    }\n    return this.geometryFactory.createMultiLineString(components)\n  },\n\n  /**\n   * Return a polygon geometry given a polygon WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the polygon.\n   * @return {Polygon} A polygon geometry.\n   * @private\n   */\n  polygon (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createPolygon()\n    }\n\n    var ring, linestring, linearring\n    var rings = str.trim().split(regExes.parenComma)\n    var shell\n    var holes = []\n    for (let i = 0, len = rings.length; i < len; ++i) {\n      ring = rings[i].replace(regExes.trimParens, '$1')\n      linestring = parse.linestring.call(this, ring)\n      linearring = this.geometryFactory.createLinearRing(linestring._points)\n      if (i === 0) {\n        shell = linearring\n      } else {\n        holes.push(linearring)\n      }\n    }\n    return this.geometryFactory.createPolygon(shell, holes)\n  },\n\n  /**\n   * Return a multipolygon geometry given a multipolygon WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multipolygon.\n   * @return {MultiPolygon} A multipolygon geometry.\n   * @private\n   */\n  multipolygon (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createMultiPolygon()\n    }\n\n    var polygon\n    var polygons = str.trim().split(regExes.doubleParenComma)\n    var components = []\n    for (let i = 0, len = polygons.length; i < len; ++i) {\n      polygon = polygons[i].replace(regExes.trimParens, '$1')\n      components.push(parse.polygon.call(this, polygon))\n    }\n    return this.geometryFactory.createMultiPolygon(components)\n  },\n\n  /**\n   * Return a geometrycollection given a geometrycollection WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the geometrycollection.\n   * @return {GeometryCollection}\n   * @private\n   */\n  geometrycollection (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createGeometryCollection()\n    }\n\n    // separate components of the collection with |\n    str = str.replace(/,\\s*([A-Za-z])/g, '|$1')\n    var wktArray = str.trim().split('|')\n    var components = []\n    for (let i = 0, len = wktArray.length; i < len; ++i) {\n      components.push(this.read(wktArray[i]))\n    }\n    return this.geometryFactory.createGeometryCollection(components)\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/io/WKTParser.js\n// module id = 164\n// module chunks = 0","import MinimalEdgeRing from './MinimalEdgeRing';\nimport extend from '../../../../../extend';\nimport EdgeRing from '../../geomgraph/EdgeRing';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport inherits from '../../../../../inherits';\nexport default function MaximalEdgeRing() {\n\tlet start = arguments[0], geometryFactory = arguments[1];\n\tEdgeRing.call(this, start, geometryFactory);\n}\ninherits(MaximalEdgeRing, EdgeRing);\nextend(MaximalEdgeRing.prototype, {\n\tbuildMinimalRings: function () {\n\t\tvar minEdgeRings = new ArrayList();\n\t\tvar de = this._startDe;\n\t\tdo {\n\t\t\tif (de.getMinEdgeRing() === null) {\n\t\t\t\tvar minEr = new MinimalEdgeRing(de, this._geometryFactory);\n\t\t\t\tminEdgeRings.add(minEr);\n\t\t\t}\n\t\t\tde = de.getNext();\n\t\t} while (de !== this._startDe);\n\t\treturn minEdgeRings;\n\t},\n\tsetEdgeRing: function (de, er) {\n\t\tde.setEdgeRing(er);\n\t},\n\tlinkDirectedEdgesForMinimalEdgeRings: function () {\n\t\tvar de = this._startDe;\n\t\tdo {\n\t\t\tvar node = de.getNode();\n\t\t\tnode.getEdges().linkMinimalDirectedEdges(this);\n\t\t\tde = de.getNext();\n\t\t} while (de !== this._startDe);\n\t},\n\tgetNext: function (de) {\n\t\treturn de.getNext();\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn MaximalEdgeRing;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/operation/overlay/MaximalEdgeRing.js\n// module id = 165\n// module chunks = 0","import extend from '../../../../../extend';\nimport EdgeRing from '../../geomgraph/EdgeRing';\nimport inherits from '../../../../../inherits';\nexport default function MinimalEdgeRing() {\n\tlet start = arguments[0], geometryFactory = arguments[1];\n\tEdgeRing.call(this, start, geometryFactory);\n}\ninherits(MinimalEdgeRing, EdgeRing);\nextend(MinimalEdgeRing.prototype, {\n\tsetEdgeRing: function (de, er) {\n\t\tde.setMinEdgeRing(er);\n\t},\n\tgetNext: function (de) {\n\t\treturn de.getNextMin();\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn MinimalEdgeRing;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/operation/overlay/MinimalEdgeRing.js\n// module id = 166\n// module chunks = 0","import StringBuffer from '../../../../java/lang/StringBuffer';\nimport Location from '../geom/Location';\nimport Position from './Position';\nimport extend from '../../../../extend';\nexport default function TopologyLocation() {\n\tthis.location = null;\n\tif (arguments.length === 1) {\n\t\tif (arguments[0] instanceof Array) {\n\t\t\tlet location = arguments[0];\n\t\t\tthis.init(location.length);\n\t\t} else if (Number.isInteger(arguments[0])) {\n\t\t\tlet on = arguments[0];\n\t\t\tthis.init(1);\n\t\t\tthis.location[Position.ON] = on;\n\t\t} else if (arguments[0] instanceof TopologyLocation) {\n\t\t\tlet gl = arguments[0];\n\t\t\tthis.init(gl.location.length);\n\t\t\tif (gl !== null) {\n\t\t\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\t\t\tthis.location[i] = gl.location[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (arguments.length === 3) {\n\t\tlet on = arguments[0], left = arguments[1], right = arguments[2];\n\t\tthis.init(3);\n\t\tthis.location[Position.ON] = on;\n\t\tthis.location[Position.LEFT] = left;\n\t\tthis.location[Position.RIGHT] = right;\n\t}\n}\nextend(TopologyLocation.prototype, {\n\tsetAllLocations: function (locValue) {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tthis.location[i] = locValue;\n\t\t}\n\t},\n\tisNull: function () {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] !== Location.NONE) return false;\n\t\t}\n\t\treturn true;\n\t},\n\tsetAllLocationsIfNull: function (locValue) {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] === Location.NONE) this.location[i] = locValue;\n\t\t}\n\t},\n\tisLine: function () {\n\t\treturn this.location.length === 1;\n\t},\n\tmerge: function (gl) {\n\t\tif (gl.location.length > this.location.length) {\n\t\t\tvar newLoc = new Array(3).fill(null);\n\t\t\tnewLoc[Position.ON] = this.location[Position.ON];\n\t\t\tnewLoc[Position.LEFT] = Location.NONE;\n\t\t\tnewLoc[Position.RIGHT] = Location.NONE;\n\t\t\tthis.location = newLoc;\n\t\t}\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] === Location.NONE && i < gl.location.length) this.location[i] = gl.location[i];\n\t\t}\n\t},\n\tgetLocations: function () {\n\t\treturn this.location;\n\t},\n\tflip: function () {\n\t\tif (this.location.length <= 1) return null;\n\t\tvar temp = this.location[Position.LEFT];\n\t\tthis.location[Position.LEFT] = this.location[Position.RIGHT];\n\t\tthis.location[Position.RIGHT] = temp;\n\t},\n\ttoString: function () {\n\t\tvar buf = new StringBuffer();\n\t\tif (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.LEFT]));\n\t\tbuf.append(Location.toLocationSymbol(this.location[Position.ON]));\n\t\tif (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.RIGHT]));\n\t\treturn buf.toString();\n\t},\n\tsetLocations: function (on, left, right) {\n\t\tthis.location[Position.ON] = on;\n\t\tthis.location[Position.LEFT] = left;\n\t\tthis.location[Position.RIGHT] = right;\n\t},\n\tget: function (posIndex) {\n\t\tif (posIndex < this.location.length) return this.location[posIndex];\n\t\treturn Location.NONE;\n\t},\n\tisArea: function () {\n\t\treturn this.location.length > 1;\n\t},\n\tisAnyNull: function () {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] === Location.NONE) return true;\n\t\t}\n\t\treturn false;\n\t},\n\tsetLocation: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet locValue = arguments[0];\n\t\t\tthis.setLocation(Position.ON, locValue);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet locIndex = arguments[0], locValue = arguments[1];\n\t\t\tthis.location[locIndex] = locValue;\n\t\t}\n\t},\n\tinit: function (size) {\n\t\tthis.location = new Array(size).fill(null);\n\t\tthis.setAllLocations(Location.NONE);\n\t},\n\tisEqualOnSide: function (le, locIndex) {\n\t\treturn this.location[locIndex] === le.location[locIndex];\n\t},\n\tallPositionsEqual: function (loc) {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] !== loc) return false;\n\t\t}\n\t\treturn true;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn TopologyLocation;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geomgraph/TopologyLocation.js\n// module id = 167\n// module chunks = 0","import Location from '../geom/Location';\nimport Coordinate from '../geom/Coordinate';\nimport Node from './Node';\nimport extend from '../../../../extend';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport TreeMap from '../../../../java/util/TreeMap';\nexport default function NodeMap() {\n\tthis.nodeMap = new TreeMap();\n\tthis.nodeFact = null;\n\tlet nodeFact = arguments[0];\n\tthis.nodeFact = nodeFact;\n}\nextend(NodeMap.prototype, {\n\tfind: function (coord) {\n\t\treturn this.nodeMap.get(coord);\n\t},\n\taddNode: function () {\n\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\tlet coord = arguments[0];\n\t\t\tvar node = this.nodeMap.get(coord);\n\t\t\tif (node === null) {\n\t\t\t\tnode = this.nodeFact.createNode(coord);\n\t\t\t\tthis.nodeMap.put(coord, node);\n\t\t\t}\n\t\t\treturn node;\n\t\t} else if (arguments[0] instanceof Node) {\n\t\t\tlet n = arguments[0];\n\t\t\tvar node = this.nodeMap.get(n.getCoordinate());\n\t\t\tif (node === null) {\n\t\t\t\tthis.nodeMap.put(n.getCoordinate(), n);\n\t\t\t\treturn n;\n\t\t\t}\n\t\t\tnode.mergeLabel(n);\n\t\t\treturn node;\n\t\t}\n\t},\n\tprint: function (out) {\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar n = it.next();\n\t\t\tn.print(out);\n\t\t}\n\t},\n\titerator: function () {\n\t\treturn this.nodeMap.values().iterator();\n\t},\n\tvalues: function () {\n\t\treturn this.nodeMap.values();\n\t},\n\tgetBoundaryNodes: function (geomIndex) {\n\t\tvar bdyNodes = new ArrayList();\n\t\tfor (var i = this.iterator(); i.hasNext(); ) {\n\t\t\tvar node = i.next();\n\t\t\tif (node.getLabel().getLocation(geomIndex) === Location.BOUNDARY) bdyNodes.add(node);\n\t\t}\n\t\treturn bdyNodes;\n\t},\n\tadd: function (e) {\n\t\tvar p = e.getCoordinate();\n\t\tvar n = this.addNode(p);\n\t\tn.add(e);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn NodeMap;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geomgraph/NodeMap.js\n// module id = 168\n// module chunks = 0","import extend from '../../../../extend';\nimport Orientation from '../algorithm/Orientation';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Quadrant from './Quadrant';\nimport Assert from '../util/Assert';\nexport default function EdgeEnd() {\n\tthis._edge = null;\n\tthis._label = null;\n\tthis._node = null;\n\tthis._p0 = null;\n\tthis._p1 = null;\n\tthis._dx = null;\n\tthis._dy = null;\n\tthis._quadrant = null;\n\tif (arguments.length === 1) {\n\t\tlet edge = arguments[0];\n\t\tthis._edge = edge;\n\t} else if (arguments.length === 3) {\n\t\tlet edge = arguments[0], p0 = arguments[1], p1 = arguments[2];\n\t\tEdgeEnd.call(this, edge, p0, p1, null);\n\t} else if (arguments.length === 4) {\n\t\tlet edge = arguments[0], p0 = arguments[1], p1 = arguments[2], label = arguments[3];\n\t\tEdgeEnd.call(this, edge);\n\t\tthis.init(p0, p1);\n\t\tthis._label = label;\n\t}\n}\nextend(EdgeEnd.prototype, {\n\tcompareDirection: function (e) {\n\t\tif (this._dx === e._dx && this._dy === e._dy) return 0;\n\t\tif (this._quadrant > e._quadrant) return 1;\n\t\tif (this._quadrant < e._quadrant) return -1;\n\t\treturn Orientation.index(e._p0, e._p1, this._p1);\n\t},\n\tgetDy: function () {\n\t\treturn this._dy;\n\t},\n\tgetCoordinate: function () {\n\t\treturn this._p0;\n\t},\n\tsetNode: function (node) {\n\t\tthis._node = node;\n\t},\n\tprint: function (out) {\n\t\tvar angle = Math.atan2(this._dy, this._dx);\n\t\tvar className = this.getClass().getName();\n\t\tvar lastDotPos = className.lastIndexOf('.');\n\t\tvar name = className.substring(lastDotPos + 1);\n\t\tout.print(\"  \" + name + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + angle + \"   \" + this._label);\n\t},\n\tcompareTo: function (obj) {\n\t\tvar e = obj;\n\t\treturn this.compareDirection(e);\n\t},\n\tgetDirectedCoordinate: function () {\n\t\treturn this._p1;\n\t},\n\tgetDx: function () {\n\t\treturn this._dx;\n\t},\n\tgetLabel: function () {\n\t\treturn this._label;\n\t},\n\tgetEdge: function () {\n\t\treturn this._edge;\n\t},\n\tgetQuadrant: function () {\n\t\treturn this._quadrant;\n\t},\n\tgetNode: function () {\n\t\treturn this._node;\n\t},\n\ttoString: function () {\n\t\tvar angle = Math.atan2(this._dy, this._dx);\n\t\tvar className = this.getClass().getName();\n\t\tvar lastDotPos = className.lastIndexOf('.');\n\t\tvar name = className.substring(lastDotPos + 1);\n\t\treturn \"  \" + name + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + angle + \"   \" + this._label;\n\t},\n\tcomputeLabel: function (boundaryNodeRule) {},\n\tinit: function (p0, p1) {\n\t\tthis._p0 = p0;\n\t\tthis._p1 = p1;\n\t\tthis._dx = p1.x - p0.x;\n\t\tthis._dy = p1.y - p0.y;\n\t\tthis._quadrant = Quadrant.quadrant(this._dx, this._dy);\n\t\tAssert.isTrue(!(this._dx === 0 && this._dy === 0), \"EdgeEnd with identical endpoints found\");\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparable];\n\t},\n\tgetClass: function () {\n\t\treturn EdgeEnd;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeEnd.js\n// module id = 169\n// module chunks = 0","import ItemBoundable from './ItemBoundable';\nimport PriorityQueue from '../../util/PriorityQueue';\nimport hasInterface from '../../../../../hasInterface';\nimport BoundablePairDistanceComparator from './BoundablePairDistanceComparator';\nimport SpatialIndex from '../SpatialIndex';\nimport AbstractNode from './AbstractNode';\nimport Double from '../../../../../java/lang/Double';\nimport extend from '../../../../../extend';\nimport Collections from '../../../../../java/util/Collections';\nimport BoundablePair from './BoundablePair';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Comparator from '../../../../../java/util/Comparator';\nimport Serializable from '../../../../../java/io/Serializable';\nimport Envelope from '../../geom/Envelope';\nimport Assert from '../../util/Assert';\nimport inherits from '../../../../../inherits';\nimport AbstractSTRtree from './AbstractSTRtree';\nimport ItemDistance from './ItemDistance';\nexport default function STRtree() {\n\tif (arguments.length === 0) {\n\t\tSTRtree.call(this, STRtree.DEFAULT_NODE_CAPACITY);\n\t} else if (arguments.length === 1) {\n\t\tlet nodeCapacity = arguments[0];\n\t\tAbstractSTRtree.call(this, nodeCapacity);\n\t}\n}\ninherits(STRtree, AbstractSTRtree);\nextend(STRtree.prototype, {\n\tcreateParentBoundablesFromVerticalSlices: function (verticalSlices, newLevel) {\n\t\tAssert.isTrue(verticalSlices.length > 0);\n\t\tvar parentBoundables = new ArrayList();\n\t\tfor (var i = 0; i < verticalSlices.length; i++) {\n\t\t\tparentBoundables.addAll(this.createParentBoundablesFromVerticalSlice(verticalSlices[i], newLevel));\n\t\t}\n\t\treturn parentBoundables;\n\t},\n\tcreateNode: function (level) {\n\t\treturn new STRtreeNode(level);\n\t},\n\tsize: function () {\n\t\tif (arguments.length === 0) {\n\t\t\treturn AbstractSTRtree.prototype.size.call(this);\n\t\t} else return AbstractSTRtree.prototype.size.apply(this, arguments);\n\t},\n\tinsert: function () {\n\t\tif (arguments.length === 2 && (arguments[1] instanceof Object && arguments[0] instanceof Envelope)) {\n\t\t\tlet itemEnv = arguments[0], item = arguments[1];\n\t\t\tif (itemEnv.isNull()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tAbstractSTRtree.prototype.insert.call(this, itemEnv, item);\n\t\t} else return AbstractSTRtree.prototype.insert.apply(this, arguments);\n\t},\n\tgetIntersectsOp: function () {\n\t\treturn STRtree.intersectsOp;\n\t},\n\tverticalSlices: function (childBoundables, sliceCount) {\n\t\tvar sliceCapacity = Math.trunc(Math.ceil(childBoundables.size() / sliceCount));\n\t\tvar slices = new Array(sliceCount).fill(null);\n\t\tvar i = childBoundables.iterator();\n\t\tfor (var j = 0; j < sliceCount; j++) {\n\t\t\tslices[j] = new ArrayList();\n\t\t\tvar boundablesAddedToSlice = 0;\n\t\t\twhile (i.hasNext() && boundablesAddedToSlice < sliceCapacity) {\n\t\t\t\tvar childBoundable = i.next();\n\t\t\t\tslices[j].add(childBoundable);\n\t\t\t\tboundablesAddedToSlice++;\n\t\t\t}\n\t\t}\n\t\treturn slices;\n\t},\n\tquery: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet searchEnv = arguments[0];\n\t\t\treturn AbstractSTRtree.prototype.query.call(this, searchEnv);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet searchEnv = arguments[0], visitor = arguments[1];\n\t\t\tAbstractSTRtree.prototype.query.call(this, searchEnv, visitor);\n\t\t}\n\t},\n\tgetComparator: function () {\n\t\treturn STRtree.yComparator;\n\t},\n\tcreateParentBoundablesFromVerticalSlice: function (childBoundables, newLevel) {\n\t\treturn AbstractSTRtree.prototype.createParentBoundables.call(this, childBoundables, newLevel);\n\t},\n\tremove: function () {\n\t\tif (arguments.length === 2 && (arguments[1] instanceof Object && arguments[0] instanceof Envelope)) {\n\t\t\tlet itemEnv = arguments[0], item = arguments[1];\n\t\t\treturn AbstractSTRtree.prototype.remove.call(this, itemEnv, item);\n\t\t} else return AbstractSTRtree.prototype.remove.apply(this, arguments);\n\t},\n\tdepth: function () {\n\t\tif (arguments.length === 0) {\n\t\t\treturn AbstractSTRtree.prototype.depth.call(this);\n\t\t} else return AbstractSTRtree.prototype.depth.apply(this, arguments);\n\t},\n\tcreateParentBoundables: function (childBoundables, newLevel) {\n\t\tAssert.isTrue(!childBoundables.isEmpty());\n\t\tvar minLeafCount = Math.trunc(Math.ceil(childBoundables.size() / this.getNodeCapacity()));\n\t\tvar sortedChildBoundables = new ArrayList(childBoundables);\n\t\tCollections.sort(sortedChildBoundables, STRtree.xComparator);\n\t\tvar verticalSlices = this.verticalSlices(sortedChildBoundables, Math.trunc(Math.ceil(Math.sqrt(minLeafCount))));\n\t\treturn this.createParentBoundablesFromVerticalSlices(verticalSlices, newLevel);\n\t},\n\tnearestNeighbour: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tif (hasInterface(arguments[0], ItemDistance)) {\n\t\t\t\tlet itemDist = arguments[0];\n\t\t\t\tvar bp = new BoundablePair(this.getRoot(), this.getRoot(), itemDist);\n\t\t\t\treturn this.nearestNeighbour(bp);\n\t\t\t} else if (arguments[0] instanceof BoundablePair) {\n\t\t\t\tlet initBndPair = arguments[0];\n\t\t\t\treturn this.nearestNeighbour(initBndPair, Double.POSITIVE_INFINITY);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tif (arguments[0] instanceof STRtree && hasInterface(arguments[1], ItemDistance)) {\n\t\t\t\tlet tree = arguments[0], itemDist = arguments[1];\n\t\t\t\tvar bp = new BoundablePair(this.getRoot(), tree.getRoot(), itemDist);\n\t\t\t\treturn this.nearestNeighbour(bp);\n\t\t\t} else if (arguments[0] instanceof BoundablePair && typeof arguments[1] === \"number\") {\n\t\t\t\tlet initBndPair = arguments[0], maxDistance = arguments[1];\n\t\t\t\tvar distanceLowerBound = maxDistance;\n\t\t\t\tvar minPair = null;\n\t\t\t\tvar priQ = new PriorityQueue();\n\t\t\t\tpriQ.add(initBndPair);\n\t\t\t\twhile (!priQ.isEmpty() && distanceLowerBound > 0.0) {\n\t\t\t\t\tvar bndPair = priQ.poll();\n\t\t\t\t\tvar currentDistance = bndPair.getDistance();\n\t\t\t\t\tif (currentDistance >= distanceLowerBound) break;\n\t\t\t\t\tif (bndPair.isLeaves()) {\n\t\t\t\t\t\tdistanceLowerBound = currentDistance;\n\t\t\t\t\t\tminPair = bndPair;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbndPair.expandToQueue(priQ, distanceLowerBound);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn [minPair.getBoundable(0).getItem(), minPair.getBoundable(1).getItem()];\n\t\t\t} else if (arguments[0] instanceof BoundablePair && Number.isInteger(arguments[1])) {\n\t\t\t\tlet initBndPair = arguments[0], k = arguments[1];\n\t\t\t\treturn this.nearestNeighbour(initBndPair, Double.POSITIVE_INFINITY, k);\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tif (hasInterface(arguments[2], ItemDistance) && (arguments[0] instanceof Envelope && arguments[1] instanceof Object)) {\n\t\t\t\tlet env = arguments[0], item = arguments[1], itemDist = arguments[2];\n\t\t\t\tvar bnd = new ItemBoundable(env, item);\n\t\t\t\tvar bp = new BoundablePair(this.getRoot(), bnd, itemDist);\n\t\t\t\treturn this.nearestNeighbour(bp)[0];\n\t\t\t} else if (Number.isInteger(arguments[2]) && (arguments[0] instanceof BoundablePair && typeof arguments[1] === \"number\")) {\n\t\t\t\tlet initBndPair = arguments[0], maxDistance = arguments[1], k = arguments[2];\n\t\t\t\tvar distanceLowerBound = maxDistance;\n\t\t\t\tvar priQ = new PriorityQueue();\n\t\t\t\tpriQ.add(initBndPair);\n\t\t\t\tvar kNearestNeighbors = new java.util.PriorityQueue<BoundablePair>(k, new BoundablePairDistanceComparator(false));\n\t\t\t\twhile (!priQ.isEmpty() && distanceLowerBound >= 0.0) {\n\t\t\t\t\tvar bndPair = priQ.poll();\n\t\t\t\t\tvar currentDistance = bndPair.getDistance();\n\t\t\t\t\tif (currentDistance >= distanceLowerBound) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (bndPair.isLeaves()) {\n\t\t\t\t\t\tif (kNearestNeighbors.size() < k) {\n\t\t\t\t\t\t\tkNearestNeighbors.add(bndPair);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (kNearestNeighbors.peek().getDistance() > currentDistance) {\n\t\t\t\t\t\t\t\tkNearestNeighbors.poll();\n\t\t\t\t\t\t\t\tkNearestNeighbors.add(bndPair);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdistanceLowerBound = kNearestNeighbors.peek().getDistance();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbndPair.expandToQueue(priQ, distanceLowerBound);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn STRtree.getItems(kNearestNeighbors);\n\t\t\t}\n\t\t} else if (arguments.length === 4) {\n\t\t\tlet env = arguments[0], item = arguments[1], itemDist = arguments[2], k = arguments[3];\n\t\t\tvar bnd = new ItemBoundable(env, item);\n\t\t\tvar bp = new BoundablePair(this.getRoot(), bnd, itemDist);\n\t\t\treturn this.nearestNeighbour(bp, k);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [SpatialIndex, Serializable];\n\t},\n\tgetClass: function () {\n\t\treturn STRtree;\n\t}\n});\nSTRtree.centreX = function (e) {\n\treturn STRtree.avg(e.getMinX(), e.getMaxX());\n};\nSTRtree.avg = function (a, b) {\n\treturn (a + b) / 2;\n};\nSTRtree.getItems = function (kNearestNeighbors) {\n\tvar items = new Array(kNearestNeighbors.size()).fill(null);\n\tvar resultIterator = kNearestNeighbors.iterator();\n\tvar count = 0;\n\twhile (resultIterator.hasNext()) {\n\t\titems[count] = resultIterator.next().getBoundable(0).getItem();\n\t\tcount++;\n\t}\n\treturn items;\n};\nSTRtree.centreY = function (e) {\n\treturn STRtree.avg(e.getMinY(), e.getMaxY());\n};\nfunction STRtreeNode() {\n\tlet level = arguments[0];\n\tAbstractNode.call(this, level);\n}\ninherits(STRtreeNode, AbstractNode);\nextend(STRtreeNode.prototype, {\n\tcomputeBounds: function () {\n\t\tvar bounds = null;\n\t\tfor (var i = this.getChildBoundables().iterator(); i.hasNext(); ) {\n\t\t\tvar childBoundable = i.next();\n\t\t\tif (bounds === null) {\n\t\t\t\tbounds = new Envelope(childBoundable.getBounds());\n\t\t\t} else {\n\t\t\t\tbounds.expandToInclude(childBoundable.getBounds());\n\t\t\t}\n\t\t}\n\t\treturn bounds;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn STRtreeNode;\n\t}\n});\nSTRtree.STRtreeNode = STRtreeNode;\nSTRtree.serialVersionUID = 259274702368956900;\nSTRtree.xComparator = {\n\tinterfaces_: function () {\n\t\treturn [Comparator];\n\t},\n\tcompare: function (o1, o2) {\n\t\treturn AbstractSTRtree.compareDoubles(STRtree.centreX(o1.getBounds()), STRtree.centreX(o2.getBounds()));\n\t}\n};\nSTRtree.yComparator = {\n\tinterfaces_: function () {\n\t\treturn [Comparator];\n\t},\n\tcompare: function (o1, o2) {\n\t\treturn AbstractSTRtree.compareDoubles(STRtree.centreY(o1.getBounds()), STRtree.centreY(o2.getBounds()));\n\t}\n};\nSTRtree.intersectsOp = {\n\tinterfaces_: function () {\n\t\treturn [IntersectsOp];\n\t},\n\tintersects: function (aBounds, bBounds) {\n\t\treturn aBounds.intersects(bBounds);\n\t}\n};\nSTRtree.DEFAULT_NODE_CAPACITY = 10;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/index/strtree/STRtree.js\n// module id = 170\n// module chunks = 0","import extend from '../../../../extend';\nimport ArrayList from '../../../../java/util/ArrayList';\nexport default function PriorityQueue() {\n\tthis._size = null;\n\tthis._items = null;\n\tthis._size = 0;\n\tthis._items = new ArrayList();\n\tthis._items.add(null);\n}\nextend(PriorityQueue.prototype, {\n\tpoll: function () {\n\t\tif (this.isEmpty()) return null;\n\t\tvar minItem = this._items.get(1);\n\t\tthis._items.set(1, this._items.get(this._size));\n\t\tthis._size -= 1;\n\t\tthis.reorder(1);\n\t\treturn minItem;\n\t},\n\tsize: function () {\n\t\treturn this._size;\n\t},\n\treorder: function (hole) {\n\t\tvar child = null;\n\t\tvar tmp = this._items.get(hole);\n\t\tfor (; hole * 2 <= this._size; hole = child) {\n\t\t\tchild = hole * 2;\n\t\t\tif (child !== this._size && this._items.get(child + 1).compareTo(this._items.get(child)) < 0) child++;\n\t\t\tif (this._items.get(child).compareTo(tmp) < 0) this._items.set(hole, this._items.get(child)); else break;\n\t\t}\n\t\tthis._items.set(hole, tmp);\n\t},\n\tclear: function () {\n\t\tthis._size = 0;\n\t\tthis._items.clear();\n\t},\n\tisEmpty: function () {\n\t\treturn this._size === 0;\n\t},\n\tadd: function (x) {\n\t\tthis._items.add(null);\n\t\tthis._size += 1;\n\t\tvar hole = this._size;\n\t\tthis._items.set(0, x);\n\t\tfor (; x.compareTo(this._items.get(Math.trunc(hole / 2))) < 0; hole /= 2) {\n\t\t\tthis._items.set(hole, this._items.get(Math.trunc(hole / 2)));\n\t\t}\n\t\tthis._items.set(hole, x);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn PriorityQueue;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/util/PriorityQueue.js\n// module id = 171\n// module chunks = 0","import extend from '../../../../../extend';\nimport Comparator from '../../../../../java/util/Comparator';\nimport Serializable from '../../../../../java/io/Serializable';\nexport default function BoundablePairDistanceComparator() {\n\tthis.normalOrder = null;\n\tlet normalOrder = arguments[0];\n\tthis.normalOrder = normalOrder;\n}\nextend(BoundablePairDistanceComparator.prototype, {\n\tcompare: function (p1, p2) {\n\t\tvar distance1 = p1.getDistance();\n\t\tvar distance2 = p2.getDistance();\n\t\tif (this.normalOrder) {\n\t\t\tif (distance1 > distance2) {\n\t\t\t\treturn 1;\n\t\t\t} else if (distance1 === distance2) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tif (distance1 > distance2) {\n\t\t\t\treturn -1;\n\t\t\t} else if (distance1 === distance2) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparator, Serializable];\n\t},\n\tgetClass: function () {\n\t\treturn BoundablePairDistanceComparator;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/index/strtree/BoundablePairDistanceComparator.js\n// module id = 172\n// module chunks = 0","import extend from '../../../../extend';\nexport default function SpatialIndex() {}\nextend(SpatialIndex.prototype, {\n\tinsert: function (itemEnv, item) {},\n\tremove: function (itemEnv, item) {},\n\tquery: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet searchEnv = arguments[0];\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet searchEnv = arguments[0], visitor = arguments[1];\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn SpatialIndex;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/index/SpatialIndex.js\n// module id = 173\n// module chunks = 0","import IllegalArgumentException from '../../../../../java/lang/IllegalArgumentException';\nimport AbstractNode from './AbstractNode';\nimport extend from '../../../../../extend';\nimport Comparable from '../../../../../java/lang/Comparable';\nexport default function BoundablePair() {\n\tthis._boundable1 = null;\n\tthis._boundable2 = null;\n\tthis._distance = null;\n\tthis._itemDistance = null;\n\tlet boundable1 = arguments[0], boundable2 = arguments[1], itemDistance = arguments[2];\n\tthis._boundable1 = boundable1;\n\tthis._boundable2 = boundable2;\n\tthis._itemDistance = itemDistance;\n\tthis._distance = this.distance();\n}\nextend(BoundablePair.prototype, {\n\texpandToQueue: function (priQ, minDistance) {\n\t\tvar isComp1 = BoundablePair.isComposite(this._boundable1);\n\t\tvar isComp2 = BoundablePair.isComposite(this._boundable2);\n\t\tif (isComp1 && isComp2) {\n\t\t\tif (BoundablePair.area(this._boundable1) > BoundablePair.area(this._boundable2)) {\n\t\t\t\tthis.expand(this._boundable1, this._boundable2, priQ, minDistance);\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tthis.expand(this._boundable2, this._boundable1, priQ, minDistance);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else if (isComp1) {\n\t\t\tthis.expand(this._boundable1, this._boundable2, priQ, minDistance);\n\t\t\treturn null;\n\t\t} else if (isComp2) {\n\t\t\tthis.expand(this._boundable2, this._boundable1, priQ, minDistance);\n\t\t\treturn null;\n\t\t}\n\t\tthrow new IllegalArgumentException(\"neither boundable is composite\");\n\t},\n\tisLeaves: function () {\n\t\treturn !(BoundablePair.isComposite(this._boundable1) || BoundablePair.isComposite(this._boundable2));\n\t},\n\tcompareTo: function (o) {\n\t\tvar nd = o;\n\t\tif (this._distance < nd._distance) return -1;\n\t\tif (this._distance > nd._distance) return 1;\n\t\treturn 0;\n\t},\n\texpand: function (bndComposite, bndOther, priQ, minDistance) {\n\t\tvar children = bndComposite.getChildBoundables();\n\t\tfor (var i = children.iterator(); i.hasNext(); ) {\n\t\t\tvar child = i.next();\n\t\t\tvar bp = new BoundablePair(child, bndOther, this._itemDistance);\n\t\t\tif (bp.getDistance() < minDistance) {\n\t\t\t\tpriQ.add(bp);\n\t\t\t}\n\t\t}\n\t},\n\tgetBoundable: function (i) {\n\t\tif (i === 0) return this._boundable1;\n\t\treturn this._boundable2;\n\t},\n\tgetDistance: function () {\n\t\treturn this._distance;\n\t},\n\tdistance: function () {\n\t\tif (this.isLeaves()) {\n\t\t\treturn this._itemDistance.distance(this._boundable1, this._boundable2);\n\t\t}\n\t\treturn this._boundable1.getBounds().distance(this._boundable2.getBounds());\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparable];\n\t},\n\tgetClass: function () {\n\t\treturn BoundablePair;\n\t}\n});\nBoundablePair.area = function (b) {\n\treturn b.getBounds().getArea();\n};\nBoundablePair.isComposite = function (item) {\n\treturn item instanceof AbstractNode;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/index/strtree/BoundablePair.js\n// module id = 174\n// module chunks = 0","import ItemBoundable from './ItemBoundable';\nimport hasInterface from '../../../../../hasInterface';\nimport ItemVisitor from '../ItemVisitor';\nimport AbstractNode from './AbstractNode';\nimport extend from '../../../../../extend';\nimport Collections from '../../../../../java/util/Collections';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Serializable from '../../../../../java/io/Serializable';\nimport Assert from '../../util/Assert';\nimport List from '../../../../../java/util/List';\nexport default function AbstractSTRtree() {\n\tthis._root = null;\n\tthis._built = false;\n\tthis._itemBoundables = new ArrayList();\n\tthis._nodeCapacity = null;\n\tif (arguments.length === 0) {\n\t\tAbstractSTRtree.call(this, AbstractSTRtree.DEFAULT_NODE_CAPACITY);\n\t} else if (arguments.length === 1) {\n\t\tlet nodeCapacity = arguments[0];\n\t\tAssert.isTrue(nodeCapacity > 1, \"Node capacity must be greater than 1\");\n\t\tthis._nodeCapacity = nodeCapacity;\n\t}\n}\nextend(AbstractSTRtree.prototype, {\n\tqueryInternal: function () {\n\t\tif (hasInterface(arguments[2], ItemVisitor) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {\n\t\t\tlet searchBounds = arguments[0], node = arguments[1], visitor = arguments[2];\n\t\t\tvar childBoundables = node.getChildBoundables();\n\t\t\tfor (var i = 0; i < childBoundables.size(); i++) {\n\t\t\t\tvar childBoundable = childBoundables.get(i);\n\t\t\t\tif (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (childBoundable instanceof AbstractNode) {\n\t\t\t\t\tthis.queryInternal(searchBounds, childBoundable, visitor);\n\t\t\t\t} else if (childBoundable instanceof ItemBoundable) {\n\t\t\t\t\tvisitor.visitItem(childBoundable.getItem());\n\t\t\t\t} else {\n\t\t\t\t\tAssert.shouldNeverReachHere();\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {\n\t\t\tlet searchBounds = arguments[0], node = arguments[1], matches = arguments[2];\n\t\t\tvar childBoundables = node.getChildBoundables();\n\t\t\tfor (var i = 0; i < childBoundables.size(); i++) {\n\t\t\t\tvar childBoundable = childBoundables.get(i);\n\t\t\t\tif (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (childBoundable instanceof AbstractNode) {\n\t\t\t\t\tthis.queryInternal(searchBounds, childBoundable, matches);\n\t\t\t\t} else if (childBoundable instanceof ItemBoundable) {\n\t\t\t\t\tmatches.add(childBoundable.getItem());\n\t\t\t\t} else {\n\t\t\t\t\tAssert.shouldNeverReachHere();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tgetNodeCapacity: function () {\n\t\treturn this._nodeCapacity;\n\t},\n\tlastNode: function (nodes) {\n\t\treturn nodes.get(nodes.size() - 1);\n\t},\n\tsize: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tthis.build();\n\t\t\treturn this.size(this._root);\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet node = arguments[0];\n\t\t\tvar size = 0;\n\t\t\tfor (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {\n\t\t\t\tvar childBoundable = i.next();\n\t\t\t\tif (childBoundable instanceof AbstractNode) {\n\t\t\t\t\tsize += this.size(childBoundable);\n\t\t\t\t} else if (childBoundable instanceof ItemBoundable) {\n\t\t\t\t\tsize += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn size;\n\t\t}\n\t},\n\tremoveItem: function (node, item) {\n\t\tvar childToRemove = null;\n\t\tfor (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {\n\t\t\tvar childBoundable = i.next();\n\t\t\tif (childBoundable instanceof ItemBoundable) {\n\t\t\t\tif (childBoundable.getItem() === item) childToRemove = childBoundable;\n\t\t\t}\n\t\t}\n\t\tif (childToRemove !== null) {\n\t\t\tnode.getChildBoundables().remove(childToRemove);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\titemsTree: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tthis.build();\n\t\t\tvar valuesTree = this.itemsTree(this._root);\n\t\t\tif (valuesTree === null) return new ArrayList();\n\t\t\treturn valuesTree;\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet node = arguments[0];\n\t\t\tvar valuesTreeForNode = new ArrayList();\n\t\t\tfor (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {\n\t\t\t\tvar childBoundable = i.next();\n\t\t\t\tif (childBoundable instanceof AbstractNode) {\n\t\t\t\t\tvar valuesTreeForChild = this.itemsTree(childBoundable);\n\t\t\t\t\tif (valuesTreeForChild !== null) valuesTreeForNode.add(valuesTreeForChild);\n\t\t\t\t} else if (childBoundable instanceof ItemBoundable) {\n\t\t\t\t\tvaluesTreeForNode.add(childBoundable.getItem());\n\t\t\t\t} else {\n\t\t\t\t\tAssert.shouldNeverReachHere();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (valuesTreeForNode.size() <= 0) return null;\n\t\t\treturn valuesTreeForNode;\n\t\t}\n\t},\n\tinsert: function (bounds, item) {\n\t\tAssert.isTrue(!this._built, \"Cannot insert items into an STR packed R-tree after it has been built.\");\n\t\tthis._itemBoundables.add(new ItemBoundable(bounds, item));\n\t},\n\tboundablesAtLevel: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet level = arguments[0];\n\t\t\tvar boundables = new ArrayList();\n\t\t\tthis.boundablesAtLevel(level, this._root, boundables);\n\t\t\treturn boundables;\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet level = arguments[0], top = arguments[1], boundables = arguments[2];\n\t\t\tAssert.isTrue(level > -2);\n\t\t\tif (top.getLevel() === level) {\n\t\t\t\tboundables.add(top);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfor (var i = top.getChildBoundables().iterator(); i.hasNext(); ) {\n\t\t\t\tvar boundable = i.next();\n\t\t\t\tif (boundable instanceof AbstractNode) {\n\t\t\t\t\tthis.boundablesAtLevel(level, boundable, boundables);\n\t\t\t\t} else {\n\t\t\t\t\tAssert.isTrue(boundable instanceof ItemBoundable);\n\t\t\t\t\tif (level === -1) {\n\t\t\t\t\t\tboundables.add(boundable);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t},\n\tquery: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet searchBounds = arguments[0];\n\t\t\tthis.build();\n\t\t\tvar matches = new ArrayList();\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn matches;\n\t\t\t}\n\t\t\tif (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {\n\t\t\t\tthis.queryInternal(searchBounds, this._root, matches);\n\t\t\t}\n\t\t\treturn matches;\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet searchBounds = arguments[0], visitor = arguments[1];\n\t\t\tthis.build();\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {\n\t\t\t\tthis.queryInternal(searchBounds, this._root, visitor);\n\t\t\t}\n\t\t}\n\t},\n\tbuild: function () {\n\t\tif (this._built) return null;\n\t\tthis._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1);\n\t\tthis._itemBoundables = null;\n\t\tthis._built = true;\n\t},\n\tgetRoot: function () {\n\t\tthis.build();\n\t\treturn this._root;\n\t},\n\tremove: function () {\n\t\tif (arguments.length === 2) {\n\t\t\tlet searchBounds = arguments[0], item = arguments[1];\n\t\t\tthis.build();\n\t\t\tif (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {\n\t\t\t\treturn this.remove(searchBounds, this._root, item);\n\t\t\t}\n\t\t\treturn false;\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet searchBounds = arguments[0], node = arguments[1], item = arguments[2];\n\t\t\tvar found = this.removeItem(node, item);\n\t\t\tif (found) return true;\n\t\t\tvar childToPrune = null;\n\t\t\tfor (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {\n\t\t\t\tvar childBoundable = i.next();\n\t\t\t\tif (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (childBoundable instanceof AbstractNode) {\n\t\t\t\t\tfound = this.remove(searchBounds, childBoundable, item);\n\t\t\t\t\tif (found) {\n\t\t\t\t\t\tchildToPrune = childBoundable;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (childToPrune !== null) {\n\t\t\t\tif (childToPrune.getChildBoundables().isEmpty()) {\n\t\t\t\t\tnode.getChildBoundables().remove(childToPrune);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn found;\n\t\t}\n\t},\n\tcreateHigherLevels: function (boundablesOfALevel, level) {\n\t\tAssert.isTrue(!boundablesOfALevel.isEmpty());\n\t\tvar parentBoundables = this.createParentBoundables(boundablesOfALevel, level + 1);\n\t\tif (parentBoundables.size() === 1) {\n\t\t\treturn parentBoundables.get(0);\n\t\t}\n\t\treturn this.createHigherLevels(parentBoundables, level + 1);\n\t},\n\tdepth: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tthis.build();\n\t\t\treturn this.depth(this._root);\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet node = arguments[0];\n\t\t\tvar maxChildDepth = 0;\n\t\t\tfor (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {\n\t\t\t\tvar childBoundable = i.next();\n\t\t\t\tif (childBoundable instanceof AbstractNode) {\n\t\t\t\t\tvar childDepth = this.depth(childBoundable);\n\t\t\t\t\tif (childDepth > maxChildDepth) maxChildDepth = childDepth;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn maxChildDepth + 1;\n\t\t}\n\t},\n\tcreateParentBoundables: function (childBoundables, newLevel) {\n\t\tAssert.isTrue(!childBoundables.isEmpty());\n\t\tvar parentBoundables = new ArrayList();\n\t\tparentBoundables.add(this.createNode(newLevel));\n\t\tvar sortedChildBoundables = new ArrayList(childBoundables);\n\t\tCollections.sort(sortedChildBoundables, this.getComparator());\n\t\tfor (var i = sortedChildBoundables.iterator(); i.hasNext(); ) {\n\t\t\tvar childBoundable = i.next();\n\t\t\tif (this.lastNode(parentBoundables).getChildBoundables().size() === this.getNodeCapacity()) {\n\t\t\t\tparentBoundables.add(this.createNode(newLevel));\n\t\t\t}\n\t\t\tthis.lastNode(parentBoundables).addChildBoundable(childBoundable);\n\t\t}\n\t\treturn parentBoundables;\n\t},\n\tisEmpty: function () {\n\t\tif (!this._built) return this._itemBoundables.isEmpty();\n\t\treturn this._root.isEmpty();\n\t},\n\tinterfaces_: function () {\n\t\treturn [Serializable];\n\t},\n\tgetClass: function () {\n\t\treturn AbstractSTRtree;\n\t}\n});\nAbstractSTRtree.compareDoubles = function (a, b) {\n\treturn a > b ? 1 : a < b ? -1 : 0;\n};\nfunction IntersectsOp() {}\nAbstractSTRtree.IntersectsOp = IntersectsOp;\nAbstractSTRtree.serialVersionUID = -3886435814360241337;\nAbstractSTRtree.DEFAULT_NODE_CAPACITY = 10;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/index/strtree/AbstractSTRtree.js\n// module id = 175\n// module chunks = 0","import extend from '../../../../../extend';\nexport default function ItemDistance() {}\nextend(ItemDistance.prototype, {\n\tdistance: function (item1, item2) {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn ItemDistance;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/index/strtree/ItemDistance.js\n// module id = 176\n// module chunks = 0","import CoordinateList from '../geom/CoordinateList';\nimport SegmentNode from './SegmentNode';\nimport Iterator from '../../../../java/util/Iterator';\nimport Coordinate from '../geom/Coordinate';\nimport NodedSegmentString from './NodedSegmentString';\nimport extend from '../../../../extend';\nimport Integer from '../../../../java/lang/Integer';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport RuntimeException from '../../../../java/lang/RuntimeException';\nimport Assert from '../util/Assert';\nimport TreeMap from '../../../../java/util/TreeMap';\nexport default function SegmentNodeList() {\n\tthis._nodeMap = new TreeMap();\n\tthis._edge = null;\n\tlet edge = arguments[0];\n\tthis._edge = edge;\n}\nextend(SegmentNodeList.prototype, {\n\tgetSplitCoordinates: function () {\n\t\tvar coordList = new CoordinateList();\n\t\tthis.addEndpoints();\n\t\tvar it = this.iterator();\n\t\tvar eiPrev = it.next();\n\t\twhile (it.hasNext()) {\n\t\t\tvar ei = it.next();\n\t\t\tthis.addEdgeCoordinates(eiPrev, ei, coordList);\n\t\t\teiPrev = ei;\n\t\t}\n\t\treturn coordList.toCoordinateArray();\n\t},\n\taddCollapsedNodes: function () {\n\t\tvar collapsedVertexIndexes = new ArrayList();\n\t\tthis.findCollapsesFromInsertedNodes(collapsedVertexIndexes);\n\t\tthis.findCollapsesFromExistingVertices(collapsedVertexIndexes);\n\t\tfor (var it = collapsedVertexIndexes.iterator(); it.hasNext(); ) {\n\t\t\tvar vertexIndex = it.next().intValue();\n\t\t\tthis.add(this._edge.getCoordinate(vertexIndex), vertexIndex);\n\t\t}\n\t},\n\tprint: function (out) {\n\t\tout.println(\"Intersections:\");\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar ei = it.next();\n\t\t\tei.print(out);\n\t\t}\n\t},\n\tfindCollapsesFromExistingVertices: function (collapsedVertexIndexes) {\n\t\tfor (var i = 0; i < this._edge.size() - 2; i++) {\n\t\t\tvar p0 = this._edge.getCoordinate(i);\n\t\t\tvar p1 = this._edge.getCoordinate(i + 1);\n\t\t\tvar p2 = this._edge.getCoordinate(i + 2);\n\t\t\tif (p0.equals2D(p2)) {\n\t\t\t\tcollapsedVertexIndexes.add(new Integer(i + 1));\n\t\t\t}\n\t\t}\n\t},\n\taddEdgeCoordinates: function (ei0, ei1, coordList) {\n\t\tvar npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n\t\tvar lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);\n\t\tvar useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);\n\t\tif (!useIntPt1) {\n\t\t\tnpts--;\n\t\t}\n\t\tvar ipt = 0;\n\t\tcoordList.add(new Coordinate(ei0.coord), false);\n\t\tfor (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n\t\t\tcoordList.add(this._edge.getCoordinate(i));\n\t\t}\n\t\tif (useIntPt1) {\n\t\t\tcoordList.add(new Coordinate(ei1.coord));\n\t\t}\n\t},\n\titerator: function () {\n\t\treturn this._nodeMap.values().iterator();\n\t},\n\taddSplitEdges: function (edgeList) {\n\t\tthis.addEndpoints();\n\t\tthis.addCollapsedNodes();\n\t\tvar it = this.iterator();\n\t\tvar eiPrev = it.next();\n\t\twhile (it.hasNext()) {\n\t\t\tvar ei = it.next();\n\t\t\tvar newEdge = this.createSplitEdge(eiPrev, ei);\n\t\t\tedgeList.add(newEdge);\n\t\t\teiPrev = ei;\n\t\t}\n\t},\n\tfindCollapseIndex: function (ei0, ei1, collapsedVertexIndex) {\n\t\tif (!ei0.coord.equals2D(ei1.coord)) return false;\n\t\tvar numVerticesBetween = ei1.segmentIndex - ei0.segmentIndex;\n\t\tif (!ei1.isInterior()) {\n\t\t\tnumVerticesBetween--;\n\t\t}\n\t\tif (numVerticesBetween === 1) {\n\t\t\tcollapsedVertexIndex[0] = ei0.segmentIndex + 1;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\tfindCollapsesFromInsertedNodes: function (collapsedVertexIndexes) {\n\t\tvar collapsedVertexIndex = new Array(1).fill(null);\n\t\tvar it = this.iterator();\n\t\tvar eiPrev = it.next();\n\t\twhile (it.hasNext()) {\n\t\t\tvar ei = it.next();\n\t\t\tvar isCollapsed = this.findCollapseIndex(eiPrev, ei, collapsedVertexIndex);\n\t\t\tif (isCollapsed) collapsedVertexIndexes.add(new Integer(collapsedVertexIndex[0]));\n\t\t\teiPrev = ei;\n\t\t}\n\t},\n\tgetEdge: function () {\n\t\treturn this._edge;\n\t},\n\taddEndpoints: function () {\n\t\tvar maxSegIndex = this._edge.size() - 1;\n\t\tthis.add(this._edge.getCoordinate(0), 0);\n\t\tthis.add(this._edge.getCoordinate(maxSegIndex), maxSegIndex);\n\t},\n\tcreateSplitEdge: function (ei0, ei1) {\n\t\tvar npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n\t\tvar lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);\n\t\tvar useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);\n\t\tif (!useIntPt1) {\n\t\t\tnpts--;\n\t\t}\n\t\tvar pts = new Array(npts).fill(null);\n\t\tvar ipt = 0;\n\t\tpts[ipt++] = new Coordinate(ei0.coord);\n\t\tfor (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n\t\t\tpts[ipt++] = this._edge.getCoordinate(i);\n\t\t}\n\t\tif (useIntPt1) pts[ipt] = new Coordinate(ei1.coord);\n\t\treturn new NodedSegmentString(pts, this._edge.getData());\n\t},\n\tadd: function (intPt, segmentIndex) {\n\t\tvar eiNew = new SegmentNode(this._edge, intPt, segmentIndex, this._edge.getSegmentOctant(segmentIndex));\n\t\tvar ei = this._nodeMap.get(eiNew);\n\t\tif (ei !== null) {\n\t\t\tAssert.isTrue(ei.coord.equals2D(intPt), \"Found equal nodes with different coordinates\");\n\t\t\treturn ei;\n\t\t}\n\t\tthis._nodeMap.put(eiNew, eiNew);\n\t\treturn eiNew;\n\t},\n\tcheckSplitEdgesCorrectness: function (splitEdges) {\n\t\tvar edgePts = this._edge.getCoordinates();\n\t\tvar split0 = splitEdges.get(0);\n\t\tvar pt0 = split0.getCoordinate(0);\n\t\tif (!pt0.equals2D(edgePts[0])) throw new RuntimeException(\"bad split edge start point at \" + pt0);\n\t\tvar splitn = splitEdges.get(splitEdges.size() - 1);\n\t\tvar splitnPts = splitn.getCoordinates();\n\t\tvar ptn = splitnPts[splitnPts.length - 1];\n\t\tif (!ptn.equals2D(edgePts[edgePts.length - 1])) throw new RuntimeException(\"bad split edge end point at \" + ptn);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn SegmentNodeList;\n\t}\n});\nfunction NodeVertexIterator() {\n\tthis._nodeList = null;\n\tthis._edge = null;\n\tthis._nodeIt = null;\n\tthis._currNode = null;\n\tthis._nextNode = null;\n\tthis._currSegIndex = 0;\n\tlet nodeList = arguments[0];\n\tthis._nodeList = nodeList;\n\tthis._edge = nodeList.getEdge();\n\tthis._nodeIt = nodeList.iterator();\n\tthis.readNextNode();\n}\nextend(NodeVertexIterator.prototype, {\n\tnext: function () {\n\t\tif (this._currNode === null) {\n\t\t\tthis._currNode = this._nextNode;\n\t\t\tthis._currSegIndex = this._currNode.segmentIndex;\n\t\t\tthis.readNextNode();\n\t\t\treturn this._currNode;\n\t\t}\n\t\tif (this._nextNode === null) return null;\n\t\tif (this._nextNode.segmentIndex === this._currNode.segmentIndex) {\n\t\t\tthis._currNode = this._nextNode;\n\t\t\tthis._currSegIndex = this._currNode.segmentIndex;\n\t\t\tthis.readNextNode();\n\t\t\treturn this._currNode;\n\t\t}\n\t\tif (this._nextNode.segmentIndex > this._currNode.segmentIndex) {}\n\t\treturn null;\n\t},\n\tremove: function () {\n\t\tthrow new UnsupportedOperationException(this.getClass().getName());\n\t},\n\thasNext: function () {\n\t\tif (this._nextNode === null) return false;\n\t\treturn true;\n\t},\n\treadNextNode: function () {\n\t\tif (this._nodeIt.hasNext()) this._nextNode = this._nodeIt.next(); else this._nextNode = null;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Iterator];\n\t},\n\tgetClass: function () {\n\t\treturn NodeVertexIterator;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/noding/SegmentNodeList.js\n// module id = 177\n// module chunks = 0","import Coordinate from '../geom/Coordinate';\nimport extend from '../../../../extend';\nimport SegmentPointComparator from './SegmentPointComparator';\nimport Comparable from '../../../../java/lang/Comparable';\nexport default function SegmentNode() {\n\tthis._segString = null;\n\tthis.coord = null;\n\tthis.segmentIndex = null;\n\tthis._segmentOctant = null;\n\tthis._isInterior = null;\n\tlet segString = arguments[0], coord = arguments[1], segmentIndex = arguments[2], segmentOctant = arguments[3];\n\tthis._segString = segString;\n\tthis.coord = new Coordinate(coord);\n\tthis.segmentIndex = segmentIndex;\n\tthis._segmentOctant = segmentOctant;\n\tthis._isInterior = !coord.equals2D(segString.getCoordinate(segmentIndex));\n}\nextend(SegmentNode.prototype, {\n\tgetCoordinate: function () {\n\t\treturn this.coord;\n\t},\n\tprint: function (out) {\n\t\tout.print(this.coord);\n\t\tout.print(\" seg # = \" + this.segmentIndex);\n\t},\n\tcompareTo: function (obj) {\n\t\tvar other = obj;\n\t\tif (this.segmentIndex < other.segmentIndex) return -1;\n\t\tif (this.segmentIndex > other.segmentIndex) return 1;\n\t\tif (this.coord.equals2D(other.coord)) return 0;\n\t\treturn SegmentPointComparator.compare(this._segmentOctant, this.coord, other.coord);\n\t},\n\tisEndPoint: function (maxSegmentIndex) {\n\t\tif (this.segmentIndex === 0 && !this._isInterior) return true;\n\t\tif (this.segmentIndex === maxSegmentIndex) return true;\n\t\treturn false;\n\t},\n\tisInterior: function () {\n\t\treturn this._isInterior;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparable];\n\t},\n\tgetClass: function () {\n\t\treturn SegmentNode;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/noding/SegmentNode.js\n// module id = 178\n// module chunks = 0","import extend from '../../../../extend';\nimport Assert from '../util/Assert';\nexport default function SegmentPointComparator() {}\nextend(SegmentPointComparator.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn SegmentPointComparator;\n\t}\n});\nSegmentPointComparator.relativeSign = function (x0, x1) {\n\tif (x0 < x1) return -1;\n\tif (x0 > x1) return 1;\n\treturn 0;\n};\nSegmentPointComparator.compare = function (octant, p0, p1) {\n\tif (p0.equals2D(p1)) return 0;\n\tvar xSign = SegmentPointComparator.relativeSign(p0.x, p1.x);\n\tvar ySign = SegmentPointComparator.relativeSign(p0.y, p1.y);\n\tswitch (octant) {\n\t\tcase 0:\n\t\t\treturn SegmentPointComparator.compareValue(xSign, ySign);\n\t\tcase 1:\n\t\t\treturn SegmentPointComparator.compareValue(ySign, xSign);\n\t\tcase 2:\n\t\t\treturn SegmentPointComparator.compareValue(ySign, -xSign);\n\t\tcase 3:\n\t\t\treturn SegmentPointComparator.compareValue(-xSign, ySign);\n\t\tcase 4:\n\t\t\treturn SegmentPointComparator.compareValue(-xSign, -ySign);\n\t\tcase 5:\n\t\t\treturn SegmentPointComparator.compareValue(-ySign, -xSign);\n\t\tcase 6:\n\t\t\treturn SegmentPointComparator.compareValue(-ySign, xSign);\n\t\tcase 7:\n\t\t\treturn SegmentPointComparator.compareValue(xSign, -ySign);\n\t}\n\tAssert.shouldNeverReachHere(\"invalid octant value\");\n\treturn 0;\n};\nSegmentPointComparator.compareValue = function (compareSign0, compareSign1) {\n\tif (compareSign0 < 0) return -1;\n\tif (compareSign0 > 0) return 1;\n\tif (compareSign1 < 0) return -1;\n\tif (compareSign1 > 0) return 1;\n\treturn 0;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/noding/SegmentPointComparator.js\n// module id = 179\n// module chunks = 0","import extend from '../../../../extend';\nimport SegmentString from './SegmentString';\nexport default function NodableSegmentString() {}\nextend(NodableSegmentString.prototype, {\n\taddIntersection: function (intPt, segmentIndex) {},\n\tinterfaces_: function () {\n\t\treturn [SegmentString];\n\t},\n\tgetClass: function () {\n\t\treturn NodableSegmentString;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/noding/NodableSegmentString.js\n// module id = 180\n// module chunks = 0","import extend from '../../../../../extend';\nimport LineSegment from '../../geom/LineSegment';\nexport default function MonotoneChainOverlapAction() {\n\tthis._overlapSeg1 = new LineSegment();\n\tthis._overlapSeg2 = new LineSegment();\n}\nextend(MonotoneChainOverlapAction.prototype, {\n\toverlap: function () {\n\t\tif (arguments.length === 2) {\n\t\t\tlet seg1 = arguments[0], seg2 = arguments[1];\n\t\t} else if (arguments.length === 4) {\n\t\t\tlet mc1 = arguments[0], start1 = arguments[1], mc2 = arguments[2], start2 = arguments[3];\n\t\t\tmc1.getLineSegment(start1, this._overlapSeg1);\n\t\t\tmc2.getLineSegment(start2, this._overlapSeg2);\n\t\t\tthis.overlap(this._overlapSeg1, this._overlapSeg2);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn MonotoneChainOverlapAction;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/index/chain/MonotoneChainOverlapAction.js\n// module id = 181\n// module chunks = 0","import MonotoneChain from './MonotoneChain';\nimport extend from '../../../../../extend';\nimport Integer from '../../../../../java/lang/Integer';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Quadrant from '../../geomgraph/Quadrant';\nexport default function MonotoneChainBuilder() {}\nextend(MonotoneChainBuilder.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn MonotoneChainBuilder;\n\t}\n});\nMonotoneChainBuilder.getChainStartIndices = function (pts) {\n\tvar start = 0;\n\tvar startIndexList = new ArrayList();\n\tstartIndexList.add(new Integer(start));\n\tdo {\n\t\tvar last = MonotoneChainBuilder.findChainEnd(pts, start);\n\t\tstartIndexList.add(new Integer(last));\n\t\tstart = last;\n\t} while (start < pts.length - 1);\n\tvar startIndex = MonotoneChainBuilder.toIntArray(startIndexList);\n\treturn startIndex;\n};\nMonotoneChainBuilder.findChainEnd = function (pts, start) {\n\tvar safeStart = start;\n\twhile (safeStart < pts.length - 1 && pts[safeStart].equals2D(pts[safeStart + 1])) {\n\t\tsafeStart++;\n\t}\n\tif (safeStart >= pts.length - 1) {\n\t\treturn pts.length - 1;\n\t}\n\tvar chainQuad = Quadrant.quadrant(pts[safeStart], pts[safeStart + 1]);\n\tvar last = start + 1;\n\twhile (last < pts.length) {\n\t\tif (!pts[last - 1].equals2D(pts[last])) {\n\t\t\tvar quad = Quadrant.quadrant(pts[last - 1], pts[last]);\n\t\t\tif (quad !== chainQuad) break;\n\t\t}\n\t\tlast++;\n\t}\n\treturn last - 1;\n};\nMonotoneChainBuilder.getChains = function () {\n\tif (arguments.length === 1) {\n\t\tlet pts = arguments[0];\n\t\treturn MonotoneChainBuilder.getChains(pts, null);\n\t} else if (arguments.length === 2) {\n\t\tlet pts = arguments[0], context = arguments[1];\n\t\tvar mcList = new ArrayList();\n\t\tvar startIndex = MonotoneChainBuilder.getChainStartIndices(pts);\n\t\tfor (var i = 0; i < startIndex.length - 1; i++) {\n\t\t\tvar mc = new MonotoneChain(pts, startIndex[i], startIndex[i + 1], context);\n\t\t\tmcList.add(mc);\n\t\t}\n\t\treturn mcList;\n\t}\n};\nMonotoneChainBuilder.toIntArray = function (list) {\n\tvar array = new Array(list.size()).fill(null);\n\tfor (var i = 0; i < array.length; i++) {\n\t\tarray[i] = list.get(i).intValue();\n\t}\n\treturn array;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/index/chain/MonotoneChainBuilder.js\n// module id = 182\n// module chunks = 0","import Noder from './Noder';\nimport extend from '../../../../extend';\nexport default function SinglePassNoder() {\n\tthis._segInt = null;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet segInt = arguments[0];\n\t\tthis.setSegmentIntersector(segInt);\n\t}\n}\nextend(SinglePassNoder.prototype, {\n\tsetSegmentIntersector: function (segInt) {\n\t\tthis._segInt = segInt;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Noder];\n\t},\n\tgetClass: function () {\n\t\treturn SinglePassNoder;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/noding/SinglePassNoder.js\n// module id = 183\n// module chunks = 0","import BufferParameters from './BufferParameters';\nimport Position from '../../geomgraph/Position';\nimport Coordinate from '../../geom/Coordinate';\nimport extend from '../../../../../extend';\nimport BufferInputLineSimplifier from './BufferInputLineSimplifier';\nimport CoordinateArrays from '../../geom/CoordinateArrays';\nimport OffsetSegmentGenerator from './OffsetSegmentGenerator';\nexport default function OffsetCurveBuilder() {\n\tthis._distance = 0.0;\n\tthis._precisionModel = null;\n\tthis._bufParams = null;\n\tlet precisionModel = arguments[0], bufParams = arguments[1];\n\tthis._precisionModel = precisionModel;\n\tthis._bufParams = bufParams;\n}\nextend(OffsetCurveBuilder.prototype, {\n\tgetOffsetCurve: function (inputPts, distance) {\n\t\tthis._distance = distance;\n\t\tif (distance === 0.0) return null;\n\t\tvar isRightSide = distance < 0.0;\n\t\tvar posDistance = Math.abs(distance);\n\t\tvar segGen = this.getSegGen(posDistance);\n\t\tif (inputPts.length <= 1) {\n\t\t\tthis.computePointCurve(inputPts[0], segGen);\n\t\t} else {\n\t\t\tthis.computeOffsetCurve(inputPts, isRightSide, segGen);\n\t\t}\n\t\tvar curvePts = segGen.getCoordinates();\n\t\tif (isRightSide) CoordinateArrays.reverse(curvePts);\n\t\treturn curvePts;\n\t},\n\tcomputeSingleSidedBufferCurve: function (inputPts, isRightSide, segGen) {\n\t\tvar distTol = this.simplifyTolerance(this._distance);\n\t\tif (isRightSide) {\n\t\t\tsegGen.addSegments(inputPts, true);\n\t\t\tvar simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n\t\t\tvar n2 = simp2.length - 1;\n\t\t\tsegGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n\t\t\tsegGen.addFirstSegment();\n\t\t\tfor (var i = n2 - 2; i >= 0; i--) {\n\t\t\t\tsegGen.addNextSegment(simp2[i], true);\n\t\t\t}\n\t\t} else {\n\t\t\tsegGen.addSegments(inputPts, false);\n\t\t\tvar simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n\t\t\tvar n1 = simp1.length - 1;\n\t\t\tsegGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n\t\t\tsegGen.addFirstSegment();\n\t\t\tfor (var i = 2; i <= n1; i++) {\n\t\t\t\tsegGen.addNextSegment(simp1[i], true);\n\t\t\t}\n\t\t}\n\t\tsegGen.addLastSegment();\n\t\tsegGen.closeRing();\n\t},\n\tcomputeRingBufferCurve: function (inputPts, side, segGen) {\n\t\tvar distTol = this.simplifyTolerance(this._distance);\n\t\tif (side === Position.RIGHT) distTol = -distTol;\n\t\tvar simp = BufferInputLineSimplifier.simplify(inputPts, distTol);\n\t\tvar n = simp.length - 1;\n\t\tsegGen.initSideSegments(simp[n - 1], simp[0], side);\n\t\tfor (var i = 1; i <= n; i++) {\n\t\t\tvar addStartPoint = i !== 1;\n\t\t\tsegGen.addNextSegment(simp[i], addStartPoint);\n\t\t}\n\t\tsegGen.closeRing();\n\t},\n\tcomputeLineBufferCurve: function (inputPts, segGen) {\n\t\tvar distTol = this.simplifyTolerance(this._distance);\n\t\tvar simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n\t\tvar n1 = simp1.length - 1;\n\t\tsegGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n\t\tfor (var i = 2; i <= n1; i++) {\n\t\t\tsegGen.addNextSegment(simp1[i], true);\n\t\t}\n\t\tsegGen.addLastSegment();\n\t\tsegGen.addLineEndCap(simp1[n1 - 1], simp1[n1]);\n\t\tvar simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n\t\tvar n2 = simp2.length - 1;\n\t\tsegGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n\t\tfor (var i = n2 - 2; i >= 0; i--) {\n\t\t\tsegGen.addNextSegment(simp2[i], true);\n\t\t}\n\t\tsegGen.addLastSegment();\n\t\tsegGen.addLineEndCap(simp2[1], simp2[0]);\n\t\tsegGen.closeRing();\n\t},\n\tcomputePointCurve: function (pt, segGen) {\n\t\tswitch (this._bufParams.getEndCapStyle()) {\n\t\t\tcase BufferParameters.CAP_ROUND:\n\t\t\t\tsegGen.createCircle(pt);\n\t\t\t\tbreak;\n\t\t\tcase BufferParameters.CAP_SQUARE:\n\t\t\t\tsegGen.createSquare(pt);\n\t\t\t\tbreak;\n\t\t}\n\t},\n\tgetLineCurve: function (inputPts, distance) {\n\t\tthis._distance = distance;\n\t\tif (distance < 0.0 && !this._bufParams.isSingleSided()) return null;\n\t\tif (distance === 0.0) return null;\n\t\tvar posDistance = Math.abs(distance);\n\t\tvar segGen = this.getSegGen(posDistance);\n\t\tif (inputPts.length <= 1) {\n\t\t\tthis.computePointCurve(inputPts[0], segGen);\n\t\t} else {\n\t\t\tif (this._bufParams.isSingleSided()) {\n\t\t\t\tvar isRightSide = distance < 0.0;\n\t\t\t\tthis.computeSingleSidedBufferCurve(inputPts, isRightSide, segGen);\n\t\t\t} else this.computeLineBufferCurve(inputPts, segGen);\n\t\t}\n\t\tvar lineCoord = segGen.getCoordinates();\n\t\treturn lineCoord;\n\t},\n\tgetBufferParameters: function () {\n\t\treturn this._bufParams;\n\t},\n\tsimplifyTolerance: function (bufDistance) {\n\t\treturn bufDistance * this._bufParams.getSimplifyFactor();\n\t},\n\tgetRingCurve: function (inputPts, side, distance) {\n\t\tthis._distance = distance;\n\t\tif (inputPts.length <= 2) return this.getLineCurve(inputPts, distance);\n\t\tif (distance === 0.0) {\n\t\t\treturn OffsetCurveBuilder.copyCoordinates(inputPts);\n\t\t}\n\t\tvar segGen = this.getSegGen(distance);\n\t\tthis.computeRingBufferCurve(inputPts, side, segGen);\n\t\treturn segGen.getCoordinates();\n\t},\n\tcomputeOffsetCurve: function (inputPts, isRightSide, segGen) {\n\t\tvar distTol = this.simplifyTolerance(this._distance);\n\t\tif (isRightSide) {\n\t\t\tvar simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n\t\t\tvar n2 = simp2.length - 1;\n\t\t\tsegGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n\t\t\tsegGen.addFirstSegment();\n\t\t\tfor (var i = n2 - 2; i >= 0; i--) {\n\t\t\t\tsegGen.addNextSegment(simp2[i], true);\n\t\t\t}\n\t\t} else {\n\t\t\tvar simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n\t\t\tvar n1 = simp1.length - 1;\n\t\t\tsegGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n\t\t\tsegGen.addFirstSegment();\n\t\t\tfor (var i = 2; i <= n1; i++) {\n\t\t\t\tsegGen.addNextSegment(simp1[i], true);\n\t\t\t}\n\t\t}\n\t\tsegGen.addLastSegment();\n\t},\n\tgetSegGen: function (distance) {\n\t\treturn new OffsetSegmentGenerator(this._precisionModel, this._bufParams, distance);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn OffsetCurveBuilder;\n\t}\n});\nOffsetCurveBuilder.copyCoordinates = function (pts) {\n\tvar copy = new Array(pts.length).fill(null);\n\tfor (var i = 0; i < copy.length; i++) {\n\t\tcopy[i] = new Coordinate(pts[i]);\n\t}\n\treturn copy;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/operation/buffer/OffsetCurveBuilder.js\n// module id = 184\n// module chunks = 0","import CoordinateList from '../../geom/CoordinateList';\nimport extend from '../../../../../extend';\nimport Orientation from '../../algorithm/Orientation';\nimport Distance from '../../algorithm/Distance';\nexport default function BufferInputLineSimplifier() {\n\tthis._inputLine = null;\n\tthis._distanceTol = null;\n\tthis._isDeleted = null;\n\tthis._angleOrientation = Orientation.COUNTERCLOCKWISE;\n\tlet inputLine = arguments[0];\n\tthis._inputLine = inputLine;\n}\nextend(BufferInputLineSimplifier.prototype, {\n\tisDeletable: function (i0, i1, i2, distanceTol) {\n\t\tvar p0 = this._inputLine[i0];\n\t\tvar p1 = this._inputLine[i1];\n\t\tvar p2 = this._inputLine[i2];\n\t\tif (!this.isConcave(p0, p1, p2)) return false;\n\t\tif (!this.isShallow(p0, p1, p2, distanceTol)) return false;\n\t\treturn this.isShallowSampled(p0, p1, i0, i2, distanceTol);\n\t},\n\tdeleteShallowConcavities: function () {\n\t\tvar index = 1;\n\t\tvar maxIndex = this._inputLine.length - 1;\n\t\tvar midIndex = this.findNextNonDeletedIndex(index);\n\t\tvar lastIndex = this.findNextNonDeletedIndex(midIndex);\n\t\tvar isChanged = false;\n\t\twhile (lastIndex < this._inputLine.length) {\n\t\t\tvar isMiddleVertexDeleted = false;\n\t\t\tif (this.isDeletable(index, midIndex, lastIndex, this._distanceTol)) {\n\t\t\t\tthis._isDeleted[midIndex] = BufferInputLineSimplifier.DELETE;\n\t\t\t\tisMiddleVertexDeleted = true;\n\t\t\t\tisChanged = true;\n\t\t\t}\n\t\t\tif (isMiddleVertexDeleted) index = lastIndex; else index = midIndex;\n\t\t\tmidIndex = this.findNextNonDeletedIndex(index);\n\t\t\tlastIndex = this.findNextNonDeletedIndex(midIndex);\n\t\t}\n\t\treturn isChanged;\n\t},\n\tisShallowConcavity: function (p0, p1, p2, distanceTol) {\n\t\tvar orientation = Orientation.index(p0, p1, p2);\n\t\tvar isAngleToSimplify = orientation === this._angleOrientation;\n\t\tif (!isAngleToSimplify) return false;\n\t\tvar dist = Distance.pointToSegment(p1, p0, p2);\n\t\treturn dist < distanceTol;\n\t},\n\tisShallowSampled: function (p0, p2, i0, i2, distanceTol) {\n\t\tvar inc = Math.trunc((i2 - i0) / BufferInputLineSimplifier.NUM_PTS_TO_CHECK);\n\t\tif (inc <= 0) inc = 1;\n\t\tfor (var i = i0; i < i2; i += inc) {\n\t\t\tif (!this.isShallow(p0, p2, this._inputLine[i], distanceTol)) return false;\n\t\t}\n\t\treturn true;\n\t},\n\tisConcave: function (p0, p1, p2) {\n\t\tvar orientation = Orientation.index(p0, p1, p2);\n\t\tvar isConcave = orientation === this._angleOrientation;\n\t\treturn isConcave;\n\t},\n\tsimplify: function (distanceTol) {\n\t\tthis._distanceTol = Math.abs(distanceTol);\n\t\tif (distanceTol < 0) this._angleOrientation = Orientation.CLOCKWISE;\n\t\tthis._isDeleted = new Array(this._inputLine.length).fill(null);\n\t\tvar isChanged = false;\n\t\tdo {\n\t\t\tisChanged = this.deleteShallowConcavities();\n\t\t} while (isChanged);\n\t\treturn this.collapseLine();\n\t},\n\tfindNextNonDeletedIndex: function (index) {\n\t\tvar next = index + 1;\n\t\twhile (next < this._inputLine.length && this._isDeleted[next] === BufferInputLineSimplifier.DELETE) next++;\n\t\treturn next;\n\t},\n\tisShallow: function (p0, p1, p2, distanceTol) {\n\t\tvar dist = Distance.pointToSegment(p1, p0, p2);\n\t\treturn dist < distanceTol;\n\t},\n\tcollapseLine: function () {\n\t\tvar coordList = new CoordinateList();\n\t\tfor (var i = 0; i < this._inputLine.length; i++) {\n\t\t\tif (this._isDeleted[i] !== BufferInputLineSimplifier.DELETE) coordList.add(this._inputLine[i]);\n\t\t}\n\t\treturn coordList.toCoordinateArray();\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn BufferInputLineSimplifier;\n\t}\n});\nBufferInputLineSimplifier.simplify = function (inputLine, distanceTol) {\n\tvar simp = new BufferInputLineSimplifier(inputLine);\n\treturn simp.simplify(distanceTol);\n};\nBufferInputLineSimplifier.INIT = 0;\nBufferInputLineSimplifier.DELETE = 1;\nBufferInputLineSimplifier.KEEP = 1;\nBufferInputLineSimplifier.NUM_PTS_TO_CHECK = 10;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/operation/buffer/BufferInputLineSimplifier.js\n// module id = 185\n// module chunks = 0","import BufferParameters from './BufferParameters';\nimport NotRepresentableException from '../../algorithm/NotRepresentableException';\nimport Position from '../../geomgraph/Position';\nimport Coordinate from '../../geom/Coordinate';\nimport extend from '../../../../../extend';\nimport Orientation from '../../algorithm/Orientation';\nimport OffsetSegmentString from './OffsetSegmentString';\nimport LineSegment from '../../geom/LineSegment';\nimport Angle from '../../algorithm/Angle';\nimport RobustLineIntersector from '../../algorithm/RobustLineIntersector';\nimport HCoordinate from '../../algorithm/HCoordinate';\nexport default function OffsetSegmentGenerator() {\n\tthis._maxCurveSegmentError = 0.0;\n\tthis._filletAngleQuantum = null;\n\tthis._closingSegLengthFactor = 1;\n\tthis._segList = null;\n\tthis._distance = 0.0;\n\tthis._precisionModel = null;\n\tthis._bufParams = null;\n\tthis._li = null;\n\tthis._s0 = null;\n\tthis._s1 = null;\n\tthis._s2 = null;\n\tthis._seg0 = new LineSegment();\n\tthis._seg1 = new LineSegment();\n\tthis._offset0 = new LineSegment();\n\tthis._offset1 = new LineSegment();\n\tthis._side = 0;\n\tthis._hasNarrowConcaveAngle = false;\n\tlet precisionModel = arguments[0], bufParams = arguments[1], distance = arguments[2];\n\tthis._precisionModel = precisionModel;\n\tthis._bufParams = bufParams;\n\tthis._li = new RobustLineIntersector();\n\tthis._filletAngleQuantum = Math.PI / 2.0 / bufParams.getQuadrantSegments();\n\tif (bufParams.getQuadrantSegments() >= 8 && bufParams.getJoinStyle() === BufferParameters.JOIN_ROUND) this._closingSegLengthFactor = OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR;\n\tthis.init(distance);\n}\nextend(OffsetSegmentGenerator.prototype, {\n\taddNextSegment: function (p, addStartPoint) {\n\t\tthis._s0 = this._s1;\n\t\tthis._s1 = this._s2;\n\t\tthis._s2 = p;\n\t\tthis._seg0.setCoordinates(this._s0, this._s1);\n\t\tthis.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0);\n\t\tthis._seg1.setCoordinates(this._s1, this._s2);\n\t\tthis.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1);\n\t\tif (this._s1.equals(this._s2)) return null;\n\t\tvar orientation = Orientation.index(this._s0, this._s1, this._s2);\n\t\tvar outsideTurn = orientation === Orientation.CLOCKWISE && this._side === Position.LEFT || orientation === Orientation.COUNTERCLOCKWISE && this._side === Position.RIGHT;\n\t\tif (orientation === 0) {\n\t\t\tthis.addCollinear(addStartPoint);\n\t\t} else if (outsideTurn) {\n\t\t\tthis.addOutsideTurn(orientation, addStartPoint);\n\t\t} else {\n\t\t\tthis.addInsideTurn(orientation, addStartPoint);\n\t\t}\n\t},\n\taddLineEndCap: function (p0, p1) {\n\t\tvar seg = new LineSegment(p0, p1);\n\t\tvar offsetL = new LineSegment();\n\t\tthis.computeOffsetSegment(seg, Position.LEFT, this._distance, offsetL);\n\t\tvar offsetR = new LineSegment();\n\t\tthis.computeOffsetSegment(seg, Position.RIGHT, this._distance, offsetR);\n\t\tvar dx = p1.x - p0.x;\n\t\tvar dy = p1.y - p0.y;\n\t\tvar angle = Math.atan2(dy, dx);\n\t\tswitch (this._bufParams.getEndCapStyle()) {\n\t\t\tcase BufferParameters.CAP_ROUND:\n\t\t\t\tthis._segList.addPt(offsetL.p1);\n\t\t\t\tthis.addDirectedFillet(p1, angle + Math.PI / 2, angle - Math.PI / 2, Orientation.CLOCKWISE, this._distance);\n\t\t\t\tthis._segList.addPt(offsetR.p1);\n\t\t\t\tbreak;\n\t\t\tcase BufferParameters.CAP_FLAT:\n\t\t\t\tthis._segList.addPt(offsetL.p1);\n\t\t\t\tthis._segList.addPt(offsetR.p1);\n\t\t\t\tbreak;\n\t\t\tcase BufferParameters.CAP_SQUARE:\n\t\t\t\tvar squareCapSideOffset = new Coordinate();\n\t\t\t\tsquareCapSideOffset.x = Math.abs(this._distance) * Math.cos(angle);\n\t\t\t\tsquareCapSideOffset.y = Math.abs(this._distance) * Math.sin(angle);\n\t\t\t\tvar squareCapLOffset = new Coordinate(offsetL.p1.x + squareCapSideOffset.x, offsetL.p1.y + squareCapSideOffset.y);\n\t\t\t\tvar squareCapROffset = new Coordinate(offsetR.p1.x + squareCapSideOffset.x, offsetR.p1.y + squareCapSideOffset.y);\n\t\t\t\tthis._segList.addPt(squareCapLOffset);\n\t\t\t\tthis._segList.addPt(squareCapROffset);\n\t\t\t\tbreak;\n\t\t}\n\t},\n\tgetCoordinates: function () {\n\t\tvar pts = this._segList.getCoordinates();\n\t\treturn pts;\n\t},\n\taddMitreJoin: function (p, offset0, offset1, distance) {\n\t\tvar isMitreWithinLimit = true;\n\t\tvar intPt = null;\n\t\ttry {\n\t\t\tintPt = HCoordinate.intersection(offset0.p0, offset0.p1, offset1.p0, offset1.p1);\n\t\t\tvar mitreRatio = distance <= 0.0 ? 1.0 : intPt.distance(p) / Math.abs(distance);\n\t\t\tif (mitreRatio > this._bufParams.getMitreLimit()) isMitreWithinLimit = false;\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof NotRepresentableException) {\n\t\t\t\tintPt = new Coordinate(0, 0);\n\t\t\t\tisMitreWithinLimit = false;\n\t\t\t} else throw ex;\n\t\t} finally {}\n\t\tif (isMitreWithinLimit) {\n\t\t\tthis._segList.addPt(intPt);\n\t\t} else {\n\t\t\tthis.addLimitedMitreJoin(offset0, offset1, distance, this._bufParams.getMitreLimit());\n\t\t}\n\t},\n\taddOutsideTurn: function (orientation, addStartPoint) {\n\t\tif (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR) {\n\t\t\tthis._segList.addPt(this._offset0.p1);\n\t\t\treturn null;\n\t\t}\n\t\tif (this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {\n\t\t\tthis.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance);\n\t\t} else if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL) {\n\t\t\tthis.addBevelJoin(this._offset0, this._offset1);\n\t\t} else {\n\t\t\tif (addStartPoint) this._segList.addPt(this._offset0.p1);\n\t\t\tthis.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, orientation, this._distance);\n\t\t\tthis._segList.addPt(this._offset1.p0);\n\t\t}\n\t},\n\tcreateSquare: function (p) {\n\t\tthis._segList.addPt(new Coordinate(p.x + this._distance, p.y + this._distance));\n\t\tthis._segList.addPt(new Coordinate(p.x + this._distance, p.y - this._distance));\n\t\tthis._segList.addPt(new Coordinate(p.x - this._distance, p.y - this._distance));\n\t\tthis._segList.addPt(new Coordinate(p.x - this._distance, p.y + this._distance));\n\t\tthis._segList.closeRing();\n\t},\n\taddSegments: function (pt, isForward) {\n\t\tthis._segList.addPts(pt, isForward);\n\t},\n\taddFirstSegment: function () {\n\t\tthis._segList.addPt(this._offset1.p0);\n\t},\n\taddCornerFillet: function (p, p0, p1, direction, radius) {\n\t\tvar dx0 = p0.x - p.x;\n\t\tvar dy0 = p0.y - p.y;\n\t\tvar startAngle = Math.atan2(dy0, dx0);\n\t\tvar dx1 = p1.x - p.x;\n\t\tvar dy1 = p1.y - p.y;\n\t\tvar endAngle = Math.atan2(dy1, dx1);\n\t\tif (direction === Orientation.CLOCKWISE) {\n\t\t\tif (startAngle <= endAngle) startAngle += 2.0 * Math.PI;\n\t\t} else {\n\t\t\tif (startAngle >= endAngle) startAngle -= 2.0 * Math.PI;\n\t\t}\n\t\tthis._segList.addPt(p0);\n\t\tthis.addDirectedFillet(p, startAngle, endAngle, direction, radius);\n\t\tthis._segList.addPt(p1);\n\t},\n\taddLastSegment: function () {\n\t\tthis._segList.addPt(this._offset1.p1);\n\t},\n\tinitSideSegments: function (s1, s2, side) {\n\t\tthis._s1 = s1;\n\t\tthis._s2 = s2;\n\t\tthis._side = side;\n\t\tthis._seg1.setCoordinates(s1, s2);\n\t\tthis.computeOffsetSegment(this._seg1, side, this._distance, this._offset1);\n\t},\n\taddLimitedMitreJoin: function (offset0, offset1, distance, mitreLimit) {\n\t\tvar basePt = this._seg0.p1;\n\t\tvar ang0 = Angle.angle(basePt, this._seg0.p0);\n\t\tvar ang1 = Angle.angle(basePt, this._seg1.p1);\n\t\tvar angDiff = Angle.angleBetweenOriented(this._seg0.p0, basePt, this._seg1.p1);\n\t\tvar angDiffHalf = angDiff / 2;\n\t\tvar midAng = Angle.normalize(ang0 + angDiffHalf);\n\t\tvar mitreMidAng = Angle.normalize(midAng + Math.PI);\n\t\tvar mitreDist = mitreLimit * distance;\n\t\tvar bevelDelta = mitreDist * Math.abs(Math.sin(angDiffHalf));\n\t\tvar bevelHalfLen = distance - bevelDelta;\n\t\tvar bevelMidX = basePt.x + mitreDist * Math.cos(mitreMidAng);\n\t\tvar bevelMidY = basePt.y + mitreDist * Math.sin(mitreMidAng);\n\t\tvar bevelMidPt = new Coordinate(bevelMidX, bevelMidY);\n\t\tvar mitreMidLine = new LineSegment(basePt, bevelMidPt);\n\t\tvar bevelEndLeft = mitreMidLine.pointAlongOffset(1.0, bevelHalfLen);\n\t\tvar bevelEndRight = mitreMidLine.pointAlongOffset(1.0, -bevelHalfLen);\n\t\tif (this._side === Position.LEFT) {\n\t\t\tthis._segList.addPt(bevelEndLeft);\n\t\t\tthis._segList.addPt(bevelEndRight);\n\t\t} else {\n\t\t\tthis._segList.addPt(bevelEndRight);\n\t\t\tthis._segList.addPt(bevelEndLeft);\n\t\t}\n\t},\n\taddDirectedFillet: function (p, startAngle, endAngle, direction, radius) {\n\t\tvar directionFactor = direction === Orientation.CLOCKWISE ? -1 : 1;\n\t\tvar totalAngle = Math.abs(startAngle - endAngle);\n\t\tvar nSegs = Math.trunc(totalAngle / this._filletAngleQuantum + 0.5);\n\t\tif (nSegs < 1) return null;\n\t\tvar initAngle = null, currAngleInc = null;\n\t\tinitAngle = 0.0;\n\t\tcurrAngleInc = totalAngle / nSegs;\n\t\tvar currAngle = initAngle;\n\t\tvar pt = new Coordinate();\n\t\twhile (currAngle < totalAngle) {\n\t\t\tvar angle = startAngle + directionFactor * currAngle;\n\t\t\tpt.x = p.x + radius * Math.cos(angle);\n\t\t\tpt.y = p.y + radius * Math.sin(angle);\n\t\t\tthis._segList.addPt(pt);\n\t\t\tcurrAngle += currAngleInc;\n\t\t}\n\t},\n\tcomputeOffsetSegment: function (seg, side, distance, offset) {\n\t\tvar sideSign = side === Position.LEFT ? 1 : -1;\n\t\tvar dx = seg.p1.x - seg.p0.x;\n\t\tvar dy = seg.p1.y - seg.p0.y;\n\t\tvar len = Math.sqrt(dx * dx + dy * dy);\n\t\tvar ux = sideSign * distance * dx / len;\n\t\tvar uy = sideSign * distance * dy / len;\n\t\toffset.p0.x = seg.p0.x - uy;\n\t\toffset.p0.y = seg.p0.y + ux;\n\t\toffset.p1.x = seg.p1.x - uy;\n\t\toffset.p1.y = seg.p1.y + ux;\n\t},\n\taddInsideTurn: function (orientation, addStartPoint) {\n\t\tthis._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1);\n\t\tif (this._li.hasIntersection()) {\n\t\t\tthis._segList.addPt(this._li.getIntersection(0));\n\t\t} else {\n\t\t\tthis._hasNarrowConcaveAngle = true;\n\t\t\tif (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) {\n\t\t\t\tthis._segList.addPt(this._offset0.p1);\n\t\t\t} else {\n\t\t\t\tthis._segList.addPt(this._offset0.p1);\n\t\t\t\tif (this._closingSegLengthFactor > 0) {\n\t\t\t\t\tvar mid0 = new Coordinate((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));\n\t\t\t\t\tthis._segList.addPt(mid0);\n\t\t\t\t\tvar mid1 = new Coordinate((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));\n\t\t\t\t\tthis._segList.addPt(mid1);\n\t\t\t\t} else {\n\t\t\t\t\tthis._segList.addPt(this._s1);\n\t\t\t\t}\n\t\t\t\tthis._segList.addPt(this._offset1.p0);\n\t\t\t}\n\t\t}\n\t},\n\tcreateCircle: function (p) {\n\t\tvar pt = new Coordinate(p.x + this._distance, p.y);\n\t\tthis._segList.addPt(pt);\n\t\tthis.addDirectedFillet(p, 0.0, 2.0 * Math.PI, -1, this._distance);\n\t\tthis._segList.closeRing();\n\t},\n\taddBevelJoin: function (offset0, offset1) {\n\t\tthis._segList.addPt(offset0.p1);\n\t\tthis._segList.addPt(offset1.p0);\n\t},\n\tinit: function (distance) {\n\t\tthis._distance = distance;\n\t\tthis._maxCurveSegmentError = distance * (1 - Math.cos(this._filletAngleQuantum / 2.0));\n\t\tthis._segList = new OffsetSegmentString();\n\t\tthis._segList.setPrecisionModel(this._precisionModel);\n\t\tthis._segList.setMinimumVertexDistance(distance * OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);\n\t},\n\taddCollinear: function (addStartPoint) {\n\t\tthis._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);\n\t\tvar numInt = this._li.getIntersectionNum();\n\t\tif (numInt >= 2) {\n\t\t\tif (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL || this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {\n\t\t\t\tif (addStartPoint) this._segList.addPt(this._offset0.p1);\n\t\t\t\tthis._segList.addPt(this._offset1.p0);\n\t\t\t} else {\n\t\t\t\tthis.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, Orientation.CLOCKWISE, this._distance);\n\t\t\t}\n\t\t}\n\t},\n\tcloseRing: function () {\n\t\tthis._segList.closeRing();\n\t},\n\thasNarrowConcaveAngle: function () {\n\t\treturn this._hasNarrowConcaveAngle;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn OffsetSegmentGenerator;\n\t}\n});\nOffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR = 1.0E-3;\nOffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-3;\nOffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-6;\nOffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR = 80;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/operation/buffer/OffsetSegmentGenerator.js\n// module id = 186\n// module chunks = 0","import GeometryFactory from '../../geom/GeometryFactory';\nimport Coordinate from '../../geom/Coordinate';\nimport extend from '../../../../../extend';\nimport ArrayList from '../../../../../java/util/ArrayList';\nexport default function OffsetSegmentString() {\n\tthis._ptList = null;\n\tthis._precisionModel = null;\n\tthis._minimimVertexDistance = 0.0;\n\tthis._ptList = new ArrayList();\n}\nextend(OffsetSegmentString.prototype, {\n\tgetCoordinates: function () {\n\t\tvar coord = this._ptList.toArray(OffsetSegmentString.COORDINATE_ARRAY_TYPE);\n\t\treturn coord;\n\t},\n\tsetPrecisionModel: function (precisionModel) {\n\t\tthis._precisionModel = precisionModel;\n\t},\n\taddPt: function (pt) {\n\t\tvar bufPt = new Coordinate(pt);\n\t\tthis._precisionModel.makePrecise(bufPt);\n\t\tif (this.isRedundant(bufPt)) return null;\n\t\tthis._ptList.add(bufPt);\n\t},\n\treverse: function () {},\n\taddPts: function (pt, isForward) {\n\t\tif (isForward) {\n\t\t\tfor (var i = 0; i < pt.length; i++) {\n\t\t\t\tthis.addPt(pt[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var i = pt.length - 1; i >= 0; i--) {\n\t\t\t\tthis.addPt(pt[i]);\n\t\t\t}\n\t\t}\n\t},\n\tisRedundant: function (pt) {\n\t\tif (this._ptList.size() < 1) return false;\n\t\tvar lastPt = this._ptList.get(this._ptList.size() - 1);\n\t\tvar ptDist = pt.distance(lastPt);\n\t\tif (ptDist < this._minimimVertexDistance) return true;\n\t\treturn false;\n\t},\n\ttoString: function () {\n\t\tvar fact = new GeometryFactory();\n\t\tvar line = fact.createLineString(this.getCoordinates());\n\t\treturn line.toString();\n\t},\n\tcloseRing: function () {\n\t\tif (this._ptList.size() < 1) return null;\n\t\tvar startPt = new Coordinate(this._ptList.get(0));\n\t\tvar lastPt = this._ptList.get(this._ptList.size() - 1);\n\t\tvar last2Pt = null;\n\t\tif (this._ptList.size() >= 2) last2Pt = this._ptList.get(this._ptList.size() - 2);\n\t\tif (startPt.equals(lastPt)) return null;\n\t\tthis._ptList.add(startPt);\n\t},\n\tsetMinimumVertexDistance: function (minimimVertexDistance) {\n\t\tthis._minimimVertexDistance = minimimVertexDistance;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn OffsetSegmentString;\n\t}\n});\nOffsetSegmentString.COORDINATE_ARRAY_TYPE = new Array(0).fill(null);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/operation/buffer/OffsetSegmentString.js\n// module id = 187\n// module chunks = 0","import hasInterface from '../../../../../hasInterface';\nimport Position from '../../geomgraph/Position';\nimport Coordinate from '../../geom/Coordinate';\nimport extend from '../../../../../extend';\nimport Orientation from '../../algorithm/Orientation';\nimport Collections from '../../../../../java/util/Collections';\nimport DirectedEdge from '../../geomgraph/DirectedEdge';\nimport LineSegment from '../../geom/LineSegment';\nimport Comparable from '../../../../../java/lang/Comparable';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport List from '../../../../../java/util/List';\nexport default function SubgraphDepthLocater() {\n\tthis._subgraphs = null;\n\tthis._seg = new LineSegment();\n\tlet subgraphs = arguments[0];\n\tthis._subgraphs = subgraphs;\n}\nextend(SubgraphDepthLocater.prototype, {\n\tfindStabbedSegments: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet stabbingRayLeftPt = arguments[0];\n\t\t\tvar stabbedSegments = new ArrayList();\n\t\t\tfor (var i = this._subgraphs.iterator(); i.hasNext(); ) {\n\t\t\t\tvar bsg = i.next();\n\t\t\t\tvar env = bsg.getEnvelope();\n\t\t\t\tif (stabbingRayLeftPt.y < env.getMinY() || stabbingRayLeftPt.y > env.getMaxY()) continue;\n\t\t\t\tthis.findStabbedSegments(stabbingRayLeftPt, bsg.getDirectedEdges(), stabbedSegments);\n\t\t\t}\n\t\t\treturn stabbedSegments;\n\t\t} else if (arguments.length === 3) {\n\t\t\tif (hasInterface(arguments[2], List) && (arguments[0] instanceof Coordinate && arguments[1] instanceof DirectedEdge)) {\n\t\t\t\tlet stabbingRayLeftPt = arguments[0], dirEdge = arguments[1], stabbedSegments = arguments[2];\n\t\t\t\tvar pts = dirEdge.getEdge().getCoordinates();\n\t\t\t\tfor (var i = 0; i < pts.length - 1; i++) {\n\t\t\t\t\tthis._seg.p0 = pts[i];\n\t\t\t\t\tthis._seg.p1 = pts[i + 1];\n\t\t\t\t\tif (this._seg.p0.y > this._seg.p1.y) this._seg.reverse();\n\t\t\t\t\tvar maxx = Math.max(this._seg.p0.x, this._seg.p1.x);\n\t\t\t\t\tif (maxx < stabbingRayLeftPt.x) continue;\n\t\t\t\t\tif (this._seg.isHorizontal()) continue;\n\t\t\t\t\tif (stabbingRayLeftPt.y < this._seg.p0.y || stabbingRayLeftPt.y > this._seg.p1.y) continue;\n\t\t\t\t\tif (Orientation.index(this._seg.p0, this._seg.p1, stabbingRayLeftPt) === Orientation.RIGHT) continue;\n\t\t\t\t\tvar depth = dirEdge.getDepth(Position.LEFT);\n\t\t\t\t\tif (!this._seg.p0.equals(pts[i])) depth = dirEdge.getDepth(Position.RIGHT);\n\t\t\t\t\tvar ds = new DepthSegment(this._seg, depth);\n\t\t\t\t\tstabbedSegments.add(ds);\n\t\t\t\t}\n\t\t\t} else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Coordinate && hasInterface(arguments[1], List))) {\n\t\t\t\tlet stabbingRayLeftPt = arguments[0], dirEdges = arguments[1], stabbedSegments = arguments[2];\n\t\t\t\tfor (var i = dirEdges.iterator(); i.hasNext(); ) {\n\t\t\t\t\tvar de = i.next();\n\t\t\t\t\tif (!de.isForward()) continue;\n\t\t\t\t\tthis.findStabbedSegments(stabbingRayLeftPt, de, stabbedSegments);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tgetDepth: function (p) {\n\t\tvar stabbedSegments = this.findStabbedSegments(p);\n\t\tif (stabbedSegments.size() === 0) return 0;\n\t\tvar ds = Collections.min(stabbedSegments);\n\t\treturn ds._leftDepth;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn SubgraphDepthLocater;\n\t}\n});\nfunction DepthSegment() {\n\tthis._upwardSeg = null;\n\tthis._leftDepth = null;\n\tlet seg = arguments[0], depth = arguments[1];\n\tthis._upwardSeg = new LineSegment(seg);\n\tthis._leftDepth = depth;\n}\nextend(DepthSegment.prototype, {\n\tcompareTo: function (obj) {\n\t\tvar other = obj;\n\t\tif (this._upwardSeg.minX() >= other._upwardSeg.maxX()) return 1;\n\t\tif (this._upwardSeg.maxX() <= other._upwardSeg.minX()) return -1;\n\t\tvar orientIndex = this._upwardSeg.orientationIndex(other._upwardSeg);\n\t\tif (orientIndex !== 0) return orientIndex;\n\t\torientIndex = -1 * other._upwardSeg.orientationIndex(this._upwardSeg);\n\t\tif (orientIndex !== 0) return orientIndex;\n\t\treturn this._upwardSeg.compareTo(other._upwardSeg);\n\t},\n\tcompareX: function (seg0, seg1) {\n\t\tvar compare0 = seg0.p0.compareTo(seg1.p0);\n\t\tif (compare0 !== 0) return compare0;\n\t\treturn seg0.p1.compareTo(seg1.p1);\n\t},\n\ttoString: function () {\n\t\treturn this._upwardSeg.toString();\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparable];\n\t},\n\tgetClass: function () {\n\t\treturn DepthSegment;\n\t}\n});\nSubgraphDepthLocater.DepthSegment = DepthSegment;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/operation/buffer/SubgraphDepthLocater.js\n// module id = 188\n// module chunks = 0","import Location from '../../geom/Location';\nimport LineString from '../../geom/LineString';\nimport Position from '../../geomgraph/Position';\nimport Point from '../../geom/Point';\nimport NodedSegmentString from '../../noding/NodedSegmentString';\nimport Polygon from '../../geom/Polygon';\nimport MultiPoint from '../../geom/MultiPoint';\nimport LinearRing from '../../geom/LinearRing';\nimport extend from '../../../../../extend';\nimport Orientation from '../../algorithm/Orientation';\nimport MultiPolygon from '../../geom/MultiPolygon';\nimport Label from '../../geomgraph/Label';\nimport GeometryCollection from '../../geom/GeometryCollection';\nimport CoordinateArrays from '../../geom/CoordinateArrays';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Distance from '../../algorithm/Distance';\nimport MultiLineString from '../../geom/MultiLineString';\nimport Triangle from '../../geom/Triangle';\nexport default function OffsetCurveSetBuilder() {\n\tthis._inputGeom = null;\n\tthis._distance = null;\n\tthis._curveBuilder = null;\n\tthis._curveList = new ArrayList();\n\tlet inputGeom = arguments[0], distance = arguments[1], curveBuilder = arguments[2];\n\tthis._inputGeom = inputGeom;\n\tthis._distance = distance;\n\tthis._curveBuilder = curveBuilder;\n}\nextend(OffsetCurveSetBuilder.prototype, {\n\taddPoint: function (p) {\n\t\tif (this._distance <= 0.0) return null;\n\t\tvar coord = p.getCoordinates();\n\t\tvar curve = this._curveBuilder.getLineCurve(coord, this._distance);\n\t\tthis.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);\n\t},\n\taddPolygon: function (p) {\n\t\tvar offsetDistance = this._distance;\n\t\tvar offsetSide = Position.LEFT;\n\t\tif (this._distance < 0.0) {\n\t\t\toffsetDistance = -this._distance;\n\t\t\toffsetSide = Position.RIGHT;\n\t\t}\n\t\tvar shell = p.getExteriorRing();\n\t\tvar shellCoord = CoordinateArrays.removeRepeatedPoints(shell.getCoordinates());\n\t\tif (this._distance < 0.0 && this.isErodedCompletely(shell, this._distance)) return null;\n\t\tif (this._distance <= 0.0 && shellCoord.length < 3) return null;\n\t\tthis.addPolygonRing(shellCoord, offsetDistance, offsetSide, Location.EXTERIOR, Location.INTERIOR);\n\t\tfor (var i = 0; i < p.getNumInteriorRing(); i++) {\n\t\t\tvar hole = p.getInteriorRingN(i);\n\t\t\tvar holeCoord = CoordinateArrays.removeRepeatedPoints(hole.getCoordinates());\n\t\t\tif (this._distance > 0.0 && this.isErodedCompletely(hole, -this._distance)) continue;\n\t\t\tthis.addPolygonRing(holeCoord, offsetDistance, Position.opposite(offsetSide), Location.INTERIOR, Location.EXTERIOR);\n\t\t}\n\t},\n\tisTriangleErodedCompletely: function (triangleCoord, bufferDistance) {\n\t\tvar tri = new Triangle(triangleCoord[0], triangleCoord[1], triangleCoord[2]);\n\t\tvar inCentre = tri.inCentre();\n\t\tvar distToCentre = Distance.pointToSegment(inCentre, tri.p0, tri.p1);\n\t\treturn distToCentre < Math.abs(bufferDistance);\n\t},\n\taddLineString: function (line) {\n\t\tif (this._distance <= 0.0 && !this._curveBuilder.getBufferParameters().isSingleSided()) return null;\n\t\tvar coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n\t\tvar curve = this._curveBuilder.getLineCurve(coord, this._distance);\n\t\tthis.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);\n\t},\n\taddCurve: function (coord, leftLoc, rightLoc) {\n\t\tif (coord === null || coord.length < 2) return null;\n\t\tvar e = new NodedSegmentString(coord, new Label(0, Location.BOUNDARY, leftLoc, rightLoc));\n\t\tthis._curveList.add(e);\n\t},\n\tgetCurves: function () {\n\t\tthis.add(this._inputGeom);\n\t\treturn this._curveList;\n\t},\n\taddPolygonRing: function (coord, offsetDistance, side, cwLeftLoc, cwRightLoc) {\n\t\tif (offsetDistance === 0.0 && coord.length < LinearRing.MINIMUM_VALID_SIZE) return null;\n\t\tvar leftLoc = cwLeftLoc;\n\t\tvar rightLoc = cwRightLoc;\n\t\tif (coord.length >= LinearRing.MINIMUM_VALID_SIZE && Orientation.isCCW(coord)) {\n\t\t\tleftLoc = cwRightLoc;\n\t\t\trightLoc = cwLeftLoc;\n\t\t\tside = Position.opposite(side);\n\t\t}\n\t\tvar curve = this._curveBuilder.getRingCurve(coord, side, offsetDistance);\n\t\tthis.addCurve(curve, leftLoc, rightLoc);\n\t},\n\tadd: function (g) {\n\t\tif (g.isEmpty()) return null;\n\t\tif (g instanceof Polygon) this.addPolygon(g); else if (g instanceof LineString) this.addLineString(g); else if (g instanceof Point) this.addPoint(g); else if (g instanceof MultiPoint) this.addCollection(g); else if (g instanceof MultiLineString) this.addCollection(g); else if (g instanceof MultiPolygon) this.addCollection(g); else if (g instanceof GeometryCollection) this.addCollection(g); else throw new UnsupportedOperationException(g.getClass().getName());\n\t},\n\tisErodedCompletely: function (ring, bufferDistance) {\n\t\tvar ringCoord = ring.getCoordinates();\n\t\tvar minDiam = 0.0;\n\t\tif (ringCoord.length < 4) return bufferDistance < 0;\n\t\tif (ringCoord.length === 4) return this.isTriangleErodedCompletely(ringCoord, bufferDistance);\n\t\tvar env = ring.getEnvelopeInternal();\n\t\tvar envMinDimension = Math.min(env.getHeight(), env.getWidth());\n\t\tif (bufferDistance < 0.0 && 2 * Math.abs(bufferDistance) > envMinDimension) return true;\n\t\treturn false;\n\t},\n\taddCollection: function (gc) {\n\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n\t\t\tvar g = gc.getGeometryN(i);\n\t\t\tthis.add(g);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn OffsetCurveSetBuilder;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/operation/buffer/OffsetCurveSetBuilder.js\n// module id = 189\n// module chunks = 0","import Coordinate from './Coordinate';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../extend';\nimport Angle from '../algorithm/Angle';\nimport HCoordinate from '../algorithm/HCoordinate';\nexport default function Triangle() {\n\tthis.p0 = null;\n\tthis.p1 = null;\n\tthis.p2 = null;\n\tlet p0 = arguments[0], p1 = arguments[1], p2 = arguments[2];\n\tthis.p0 = p0;\n\tthis.p1 = p1;\n\tthis.p2 = p2;\n}\nextend(Triangle.prototype, {\n\tarea: function () {\n\t\treturn Triangle.area(this.p0, this.p1, this.p2);\n\t},\n\tsignedArea: function () {\n\t\treturn Triangle.signedArea(this.p0, this.p1, this.p2);\n\t},\n\tinterpolateZ: function (p) {\n\t\tif (p === null) throw new IllegalArgumentException(\"Supplied point is null.\");\n\t\treturn Triangle.interpolateZ(p, this.p0, this.p1, this.p2);\n\t},\n\tlongestSideLength: function () {\n\t\treturn Triangle.longestSideLength(this.p0, this.p1, this.p2);\n\t},\n\tisAcute: function () {\n\t\treturn Triangle.isAcute(this.p0, this.p1, this.p2);\n\t},\n\tcircumcentre: function () {\n\t\treturn Triangle.circumcentre(this.p0, this.p1, this.p2);\n\t},\n\tarea3D: function () {\n\t\treturn Triangle.area3D(this.p0, this.p1, this.p2);\n\t},\n\tcentroid: function () {\n\t\treturn Triangle.centroid(this.p0, this.p1, this.p2);\n\t},\n\tinCentre: function () {\n\t\treturn Triangle.inCentre(this.p0, this.p1, this.p2);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Triangle;\n\t}\n});\nTriangle.area = function (a, b, c) {\n\treturn Math.abs(((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2);\n};\nTriangle.signedArea = function (a, b, c) {\n\treturn ((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2;\n};\nTriangle.det = function (m00, m01, m10, m11) {\n\treturn m00 * m11 - m01 * m10;\n};\nTriangle.interpolateZ = function (p, v0, v1, v2) {\n\tvar x0 = v0.x;\n\tvar y0 = v0.y;\n\tvar a = v1.x - x0;\n\tvar b = v2.x - x0;\n\tvar c = v1.y - y0;\n\tvar d = v2.y - y0;\n\tvar det = a * d - b * c;\n\tvar dx = p.x - x0;\n\tvar dy = p.y - y0;\n\tvar t = (d * dx - b * dy) / det;\n\tvar u = (-c * dx + a * dy) / det;\n\tvar z = v0.z + t * (v1.z - v0.z) + u * (v2.z - v0.z);\n\treturn z;\n};\nTriangle.longestSideLength = function (a, b, c) {\n\tvar lenAB = a.distance(b);\n\tvar lenBC = b.distance(c);\n\tvar lenCA = c.distance(a);\n\tvar maxLen = lenAB;\n\tif (lenBC > maxLen) maxLen = lenBC;\n\tif (lenCA > maxLen) maxLen = lenCA;\n\treturn maxLen;\n};\nTriangle.isAcute = function (a, b, c) {\n\tif (!Angle.isAcute(a, b, c)) return false;\n\tif (!Angle.isAcute(b, c, a)) return false;\n\tif (!Angle.isAcute(c, a, b)) return false;\n\treturn true;\n};\nTriangle.circumcentre = function (a, b, c) {\n\tvar cx = c.x;\n\tvar cy = c.y;\n\tvar ax = a.x - cx;\n\tvar ay = a.y - cy;\n\tvar bx = b.x - cx;\n\tvar by = b.y - cy;\n\tvar denom = 2 * Triangle.det(ax, ay, bx, by);\n\tvar numx = Triangle.det(ay, ax * ax + ay * ay, by, bx * bx + by * by);\n\tvar numy = Triangle.det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);\n\tvar ccx = cx - numx / denom;\n\tvar ccy = cy + numy / denom;\n\treturn new Coordinate(ccx, ccy);\n};\nTriangle.perpendicularBisector = function (a, b) {\n\tvar dx = b.x - a.x;\n\tvar dy = b.y - a.y;\n\tvar l1 = new HCoordinate(a.x + dx / 2.0, a.y + dy / 2.0, 1.0);\n\tvar l2 = new HCoordinate(a.x - dy + dx / 2.0, a.y + dx + dy / 2.0, 1.0);\n\treturn new HCoordinate(l1, l2);\n};\nTriangle.angleBisector = function (a, b, c) {\n\tvar len0 = b.distance(a);\n\tvar len2 = b.distance(c);\n\tvar frac = len0 / (len0 + len2);\n\tvar dx = c.x - a.x;\n\tvar dy = c.y - a.y;\n\tvar splitPt = new Coordinate(a.x + frac * dx, a.y + frac * dy);\n\treturn splitPt;\n};\nTriangle.area3D = function (a, b, c) {\n\tvar ux = b.x - a.x;\n\tvar uy = b.y - a.y;\n\tvar uz = b.z - a.z;\n\tvar vx = c.x - a.x;\n\tvar vy = c.y - a.y;\n\tvar vz = c.z - a.z;\n\tvar crossx = uy * vz - uz * vy;\n\tvar crossy = uz * vx - ux * vz;\n\tvar crossz = ux * vy - uy * vx;\n\tvar absSq = crossx * crossx + crossy * crossy + crossz * crossz;\n\tvar area3D = Math.sqrt(absSq) / 2;\n\treturn area3D;\n};\nTriangle.centroid = function (a, b, c) {\n\tvar x = (a.x + b.x + c.x) / 3;\n\tvar y = (a.y + b.y + c.y) / 3;\n\treturn new Coordinate(x, y);\n};\nTriangle.inCentre = function (a, b, c) {\n\tvar len0 = b.distance(c);\n\tvar len1 = a.distance(c);\n\tvar len2 = a.distance(b);\n\tvar circum = len0 + len1 + len2;\n\tvar inCentreX = (len0 * a.x + len1 * b.x + len2 * c.x) / circum;\n\tvar inCentreY = (len0 * a.y + len1 * b.y + len2 * c.y) / circum;\n\treturn new Coordinate(inCentreX, inCentreY);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/Triangle.js\n// module id = 190\n// module chunks = 0","import Location from '../geom/Location';\nimport Position from './Position';\nimport TopologyException from '../geom/TopologyException';\nimport extend from '../../../../extend';\nimport EdgeEndStar from './EdgeEndStar';\nimport System from '../../../../java/lang/System';\nimport Label from './Label';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport Quadrant from './Quadrant';\nimport Assert from '../util/Assert';\nimport inherits from '../../../../inherits';\nexport default function DirectedEdgeStar() {\n\tEdgeEndStar.apply(this);\n\tthis._resultAreaEdgeList = null;\n\tthis._label = null;\n\tthis._SCANNING_FOR_INCOMING = 1;\n\tthis._LINKING_TO_OUTGOING = 2;\n}\ninherits(DirectedEdgeStar, EdgeEndStar);\nextend(DirectedEdgeStar.prototype, {\n\tlinkResultDirectedEdges: function () {\n\t\tthis.getResultAreaEdges();\n\t\tvar firstOut = null;\n\t\tvar incoming = null;\n\t\tvar state = this._SCANNING_FOR_INCOMING;\n\t\tfor (var i = 0; i < this._resultAreaEdgeList.size(); i++) {\n\t\t\tvar nextOut = this._resultAreaEdgeList.get(i);\n\t\t\tvar nextIn = nextOut.getSym();\n\t\t\tif (!nextOut.getLabel().isArea()) continue;\n\t\t\tif (firstOut === null && nextOut.isInResult()) firstOut = nextOut;\n\t\t\tswitch (state) {\n\t\t\t\tcase this._SCANNING_FOR_INCOMING:\n\t\t\t\t\tif (!nextIn.isInResult()) continue;\n\t\t\t\t\tincoming = nextIn;\n\t\t\t\t\tstate = this._LINKING_TO_OUTGOING;\n\t\t\t\t\tbreak;\n\t\t\t\tcase this._LINKING_TO_OUTGOING:\n\t\t\t\t\tif (!nextOut.isInResult()) continue;\n\t\t\t\t\tincoming.setNext(nextOut);\n\t\t\t\t\tstate = this._SCANNING_FOR_INCOMING;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (state === this._LINKING_TO_OUTGOING) {\n\t\t\tif (firstOut === null) throw new TopologyException(\"no outgoing dirEdge found\", this.getCoordinate());\n\t\t\tAssert.isTrue(firstOut.isInResult(), \"unable to link last incoming dirEdge\");\n\t\t\tincoming.setNext(firstOut);\n\t\t}\n\t},\n\tinsert: function (ee) {\n\t\tvar de = ee;\n\t\tthis.insertEdgeEnd(de, de);\n\t},\n\tgetRightmostEdge: function () {\n\t\tvar edges = this.getEdges();\n\t\tvar size = edges.size();\n\t\tif (size < 1) return null;\n\t\tvar de0 = edges.get(0);\n\t\tif (size === 1) return de0;\n\t\tvar deLast = edges.get(size - 1);\n\t\tvar quad0 = de0.getQuadrant();\n\t\tvar quad1 = deLast.getQuadrant();\n\t\tif (Quadrant.isNorthern(quad0) && Quadrant.isNorthern(quad1)) return de0; else if (!Quadrant.isNorthern(quad0) && !Quadrant.isNorthern(quad1)) return deLast; else {\n\t\t\tvar nonHorizontalEdge = null;\n\t\t\tif (de0.getDy() !== 0) return de0; else if (deLast.getDy() !== 0) return deLast;\n\t\t}\n\t\tAssert.shouldNeverReachHere(\"found two horizontal edges incident on node\");\n\t\treturn null;\n\t},\n\tprint: function (out) {\n\t\tSystem.out.println(\"DirectedEdgeStar: \" + this.getCoordinate());\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tout.print(\"out \");\n\t\t\tde.print(out);\n\t\t\tout.println();\n\t\t\tout.print(\"in \");\n\t\t\tde.getSym().print(out);\n\t\t\tout.println();\n\t\t}\n\t},\n\tgetResultAreaEdges: function () {\n\t\tif (this._resultAreaEdgeList !== null) return this._resultAreaEdgeList;\n\t\tthis._resultAreaEdgeList = new ArrayList();\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tif (de.isInResult() || de.getSym().isInResult()) this._resultAreaEdgeList.add(de);\n\t\t}\n\t\treturn this._resultAreaEdgeList;\n\t},\n\tupdateLabelling: function (nodeLabel) {\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tvar label = de.getLabel();\n\t\t\tlabel.setAllLocationsIfNull(0, nodeLabel.getLocation(0));\n\t\t\tlabel.setAllLocationsIfNull(1, nodeLabel.getLocation(1));\n\t\t}\n\t},\n\tlinkAllDirectedEdges: function () {\n\t\tthis.getEdges();\n\t\tvar prevOut = null;\n\t\tvar firstIn = null;\n\t\tfor (var i = this._edgeList.size() - 1; i >= 0; i--) {\n\t\t\tvar nextOut = this._edgeList.get(i);\n\t\t\tvar nextIn = nextOut.getSym();\n\t\t\tif (firstIn === null) firstIn = nextIn;\n\t\t\tif (prevOut !== null) nextIn.setNext(prevOut);\n\t\t\tprevOut = nextOut;\n\t\t}\n\t\tfirstIn.setNext(prevOut);\n\t},\n\tcomputeDepths: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet de = arguments[0];\n\t\t\tvar edgeIndex = this.findIndex(de);\n\t\t\tvar label = de.getLabel();\n\t\t\tvar startDepth = de.getDepth(Position.LEFT);\n\t\t\tvar targetLastDepth = de.getDepth(Position.RIGHT);\n\t\t\tvar nextDepth = this.computeDepths(edgeIndex + 1, this._edgeList.size(), startDepth);\n\t\t\tvar lastDepth = this.computeDepths(0, edgeIndex, nextDepth);\n\t\t\tif (lastDepth !== targetLastDepth) throw new TopologyException(\"depth mismatch at \" + de.getCoordinate());\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet startIndex = arguments[0], endIndex = arguments[1], startDepth = arguments[2];\n\t\t\tvar currDepth = startDepth;\n\t\t\tfor (var i = startIndex; i < endIndex; i++) {\n\t\t\t\tvar nextDe = this._edgeList.get(i);\n\t\t\t\tvar label = nextDe.getLabel();\n\t\t\t\tnextDe.setEdgeDepths(Position.RIGHT, currDepth);\n\t\t\t\tcurrDepth = nextDe.getDepth(Position.LEFT);\n\t\t\t}\n\t\t\treturn currDepth;\n\t\t}\n\t},\n\tmergeSymLabels: function () {\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tvar label = de.getLabel();\n\t\t\tlabel.merge(de.getSym().getLabel());\n\t\t}\n\t},\n\tlinkMinimalDirectedEdges: function (er) {\n\t\tvar firstOut = null;\n\t\tvar incoming = null;\n\t\tvar state = this._SCANNING_FOR_INCOMING;\n\t\tfor (var i = this._resultAreaEdgeList.size() - 1; i >= 0; i--) {\n\t\t\tvar nextOut = this._resultAreaEdgeList.get(i);\n\t\t\tvar nextIn = nextOut.getSym();\n\t\t\tif (firstOut === null && nextOut.getEdgeRing() === er) firstOut = nextOut;\n\t\t\tswitch (state) {\n\t\t\t\tcase this._SCANNING_FOR_INCOMING:\n\t\t\t\t\tif (nextIn.getEdgeRing() !== er) continue;\n\t\t\t\t\tincoming = nextIn;\n\t\t\t\t\tstate = this._LINKING_TO_OUTGOING;\n\t\t\t\t\tbreak;\n\t\t\t\tcase this._LINKING_TO_OUTGOING:\n\t\t\t\t\tif (nextOut.getEdgeRing() !== er) continue;\n\t\t\t\t\tincoming.setNextMin(nextOut);\n\t\t\t\t\tstate = this._SCANNING_FOR_INCOMING;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (state === this._LINKING_TO_OUTGOING) {\n\t\t\tAssert.isTrue(firstOut !== null, \"found null for first outgoing dirEdge\");\n\t\t\tAssert.isTrue(firstOut.getEdgeRing() === er, \"unable to link last incoming dirEdge\");\n\t\t\tincoming.setNextMin(firstOut);\n\t\t}\n\t},\n\tgetOutgoingDegree: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tvar degree = 0;\n\t\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\t\tvar de = it.next();\n\t\t\t\tif (de.isInResult()) degree++;\n\t\t\t}\n\t\t\treturn degree;\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet er = arguments[0];\n\t\t\tvar degree = 0;\n\t\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\t\tvar de = it.next();\n\t\t\t\tif (de.getEdgeRing() === er) degree++;\n\t\t\t}\n\t\t\treturn degree;\n\t\t}\n\t},\n\tgetLabel: function () {\n\t\treturn this._label;\n\t},\n\tfindCoveredLineEdges: function () {\n\t\tvar startLoc = Location.NONE;\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar nextOut = it.next();\n\t\t\tvar nextIn = nextOut.getSym();\n\t\t\tif (!nextOut.isLineEdge()) {\n\t\t\t\tif (nextOut.isInResult()) {\n\t\t\t\t\tstartLoc = Location.INTERIOR;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (nextIn.isInResult()) {\n\t\t\t\t\tstartLoc = Location.EXTERIOR;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (startLoc === Location.NONE) return null;\n\t\tvar currLoc = startLoc;\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar nextOut = it.next();\n\t\t\tvar nextIn = nextOut.getSym();\n\t\t\tif (nextOut.isLineEdge()) {\n\t\t\t\tnextOut.getEdge().setCovered(currLoc === Location.INTERIOR);\n\t\t\t} else {\n\t\t\t\tif (nextOut.isInResult()) currLoc = Location.EXTERIOR;\n\t\t\t\tif (nextIn.isInResult()) currLoc = Location.INTERIOR;\n\t\t\t}\n\t\t}\n\t},\n\tcomputeLabelling: function (geom) {\n\t\tEdgeEndStar.prototype.computeLabelling.call(this, geom);\n\t\tthis._label = new Label(Location.NONE);\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar ee = it.next();\n\t\t\tvar e = ee.getEdge();\n\t\t\tvar eLabel = e.getLabel();\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tvar eLoc = eLabel.getLocation(i);\n\t\t\t\tif (eLoc === Location.INTERIOR || eLoc === Location.BOUNDARY) this._label.setLocation(i, Location.INTERIOR);\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn DirectedEdgeStar;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geomgraph/DirectedEdgeStar.js\n// module id = 191\n// module chunks = 0","import StringBuffer from '../../../../java/lang/StringBuffer';\nimport Location from '../geom/Location';\nimport Position from './Position';\nimport TopologyException from '../geom/TopologyException';\nimport extend from '../../../../extend';\nimport System from '../../../../java/lang/System';\nimport SimplePointInAreaLocator from '../algorithm/locate/SimplePointInAreaLocator';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport Assert from '../util/Assert';\nimport TreeMap from '../../../../java/util/TreeMap';\nexport default function EdgeEndStar() {\n\tthis._edgeMap = new TreeMap();\n\tthis._edgeList = null;\n\tthis._ptInAreaLocation = [Location.NONE, Location.NONE];\n}\nextend(EdgeEndStar.prototype, {\n\tgetNextCW: function (ee) {\n\t\tthis.getEdges();\n\t\tvar i = this._edgeList.indexOf(ee);\n\t\tvar iNextCW = i - 1;\n\t\tif (i === 0) iNextCW = this._edgeList.size() - 1;\n\t\treturn this._edgeList.get(iNextCW);\n\t},\n\tpropagateSideLabels: function (geomIndex) {\n\t\tvar startLoc = Location.NONE;\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tif (label.isArea(geomIndex) && label.getLocation(geomIndex, Position.LEFT) !== Location.NONE) startLoc = label.getLocation(geomIndex, Position.LEFT);\n\t\t}\n\t\tif (startLoc === Location.NONE) return null;\n\t\tvar currLoc = startLoc;\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tif (label.getLocation(geomIndex, Position.ON) === Location.NONE) label.setLocation(geomIndex, Position.ON, currLoc);\n\t\t\tif (label.isArea(geomIndex)) {\n\t\t\t\tvar leftLoc = label.getLocation(geomIndex, Position.LEFT);\n\t\t\t\tvar rightLoc = label.getLocation(geomIndex, Position.RIGHT);\n\t\t\t\tif (rightLoc !== Location.NONE) {\n\t\t\t\t\tif (rightLoc !== currLoc) throw new TopologyException(\"side location conflict\", e.getCoordinate());\n\t\t\t\t\tif (leftLoc === Location.NONE) {\n\t\t\t\t\t\tAssert.shouldNeverReachHere(\"found single null side (at \" + e.getCoordinate() + \")\");\n\t\t\t\t\t}\n\t\t\t\t\tcurrLoc = leftLoc;\n\t\t\t\t} else {\n\t\t\t\t\tAssert.isTrue(label.getLocation(geomIndex, Position.LEFT) === Location.NONE, \"found single null side\");\n\t\t\t\t\tlabel.setLocation(geomIndex, Position.RIGHT, currLoc);\n\t\t\t\t\tlabel.setLocation(geomIndex, Position.LEFT, currLoc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tgetCoordinate: function () {\n\t\tvar it = this.iterator();\n\t\tif (!it.hasNext()) return null;\n\t\tvar e = it.next();\n\t\treturn e.getCoordinate();\n\t},\n\tprint: function (out) {\n\t\tSystem.out.println(\"EdgeEndStar:   \" + this.getCoordinate());\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\te.print(out);\n\t\t}\n\t},\n\tisAreaLabelsConsistent: function (geomGraph) {\n\t\tthis.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule());\n\t\treturn this.checkAreaLabelsConsistent(0);\n\t},\n\tcheckAreaLabelsConsistent: function (geomIndex) {\n\t\tvar edges = this.getEdges();\n\t\tif (edges.size() <= 0) return true;\n\t\tvar lastEdgeIndex = edges.size() - 1;\n\t\tvar startLabel = edges.get(lastEdgeIndex).getLabel();\n\t\tvar startLoc = startLabel.getLocation(geomIndex, Position.LEFT);\n\t\tAssert.isTrue(startLoc !== Location.NONE, \"Found unlabelled area edge\");\n\t\tvar currLoc = startLoc;\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tAssert.isTrue(label.isArea(geomIndex), \"Found non-area edge\");\n\t\t\tvar leftLoc = label.getLocation(geomIndex, Position.LEFT);\n\t\t\tvar rightLoc = label.getLocation(geomIndex, Position.RIGHT);\n\t\t\tif (leftLoc === rightLoc) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (rightLoc !== currLoc) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcurrLoc = leftLoc;\n\t\t}\n\t\treturn true;\n\t},\n\tfindIndex: function (eSearch) {\n\t\tthis.iterator();\n\t\tfor (var i = 0; i < this._edgeList.size(); i++) {\n\t\t\tvar e = this._edgeList.get(i);\n\t\t\tif (e === eSearch) return i;\n\t\t}\n\t\treturn -1;\n\t},\n\titerator: function () {\n\t\treturn this.getEdges().iterator();\n\t},\n\tgetEdges: function () {\n\t\tif (this._edgeList === null) {\n\t\t\tthis._edgeList = new ArrayList(this._edgeMap.values());\n\t\t}\n\t\treturn this._edgeList;\n\t},\n\tgetLocation: function (geomIndex, p, geom) {\n\t\tif (this._ptInAreaLocation[geomIndex] === Location.NONE) {\n\t\t\tthis._ptInAreaLocation[geomIndex] = SimplePointInAreaLocator.locate(p, geom[geomIndex].getGeometry());\n\t\t}\n\t\treturn this._ptInAreaLocation[geomIndex];\n\t},\n\ttoString: function () {\n\t\tvar buf = new StringBuffer();\n\t\tbuf.append(\"EdgeEndStar:   \" + this.getCoordinate());\n\t\tbuf.append(\"\\n\");\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tbuf.append(e);\n\t\t\tbuf.append(\"\\n\");\n\t\t}\n\t\treturn buf.toString();\n\t},\n\tcomputeEdgeEndLabels: function (boundaryNodeRule) {\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar ee = it.next();\n\t\t\tee.computeLabel(boundaryNodeRule);\n\t\t}\n\t},\n\tcomputeLabelling: function (geomGraph) {\n\t\tthis.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule());\n\t\tthis.propagateSideLabels(0);\n\t\tthis.propagateSideLabels(1);\n\t\tvar hasDimensionalCollapseEdge = [false, false];\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tfor (var geomi = 0; geomi < 2; geomi++) {\n\t\t\t\tif (label.isLine(geomi) && label.getLocation(geomi) === Location.BOUNDARY) hasDimensionalCollapseEdge[geomi] = true;\n\t\t\t}\n\t\t}\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tfor (var geomi = 0; geomi < 2; geomi++) {\n\t\t\t\tif (label.isAnyNull(geomi)) {\n\t\t\t\t\tvar loc = Location.NONE;\n\t\t\t\t\tif (hasDimensionalCollapseEdge[geomi]) {\n\t\t\t\t\t\tloc = Location.EXTERIOR;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar p = e.getCoordinate();\n\t\t\t\t\t\tloc = this.getLocation(geomi, p, geomGraph);\n\t\t\t\t\t}\n\t\t\t\t\tlabel.setAllLocationsIfNull(geomi, loc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tgetDegree: function () {\n\t\treturn this._edgeMap.size();\n\t},\n\tinsertEdgeEnd: function (e, obj) {\n\t\tthis._edgeMap.put(e, obj);\n\t\tthis._edgeList = null;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn EdgeEndStar;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeEndStar.js\n// module id = 192\n// module chunks = 0","import Location from '../../geom/Location';\nimport Polygon from '../../geom/Polygon';\nimport PointLocation from '../PointLocation';\nimport PointOnGeometryLocator from './PointOnGeometryLocator';\nimport extend from '../../../../../extend';\nimport GeometryCollectionIterator from '../../geom/GeometryCollectionIterator';\nimport GeometryCollection from '../../geom/GeometryCollection';\nexport default function SimplePointInAreaLocator() {\n\tthis._geom = null;\n\tlet geom = arguments[0];\n\tthis._geom = geom;\n}\nextend(SimplePointInAreaLocator.prototype, {\n\tlocate: function (p) {\n\t\treturn SimplePointInAreaLocator.locate(p, this._geom);\n\t},\n\tinterfaces_: function () {\n\t\treturn [PointOnGeometryLocator];\n\t},\n\tgetClass: function () {\n\t\treturn SimplePointInAreaLocator;\n\t}\n});\nSimplePointInAreaLocator.locatePointInPolygon = function (p, poly) {\n\tif (poly.isEmpty()) return Location.EXTERIOR;\n\tvar shell = poly.getExteriorRing();\n\tvar shellLoc = SimplePointInAreaLocator.locatePointInRing(p, shell);\n\tif (shellLoc !== Location.INTERIOR) return shellLoc;\n\tfor (var i = 0; i < poly.getNumInteriorRing(); i++) {\n\t\tvar hole = poly.getInteriorRingN(i);\n\t\tvar holeLoc = SimplePointInAreaLocator.locatePointInRing(p, hole);\n\t\tif (holeLoc === Location.BOUNDARY) return Location.BOUNDARY;\n\t\tif (holeLoc === Location.INTERIOR) return Location.EXTERIOR;\n\t}\n\treturn Location.INTERIOR;\n};\nSimplePointInAreaLocator.locatePointInRing = function (p, ring) {\n\tif (!ring.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;\n\treturn PointLocation.locateInRing(p, ring.getCoordinates());\n};\nSimplePointInAreaLocator.containsPointInPolygon = function (p, poly) {\n\treturn Location.EXTERIOR !== SimplePointInAreaLocator.locatePointInPolygon(p, poly);\n};\nSimplePointInAreaLocator.locateInGeometry = function (p, geom) {\n\tif (geom instanceof Polygon) {\n\t\treturn SimplePointInAreaLocator.locatePointInPolygon(p, geom);\n\t} else if (geom instanceof GeometryCollection) {\n\t\tvar geomi = new GeometryCollectionIterator(geom);\n\t\twhile (geomi.hasNext()) {\n\t\t\tvar g2 = geomi.next();\n\t\t\tif (g2 !== geom) {\n\t\t\t\tvar loc = SimplePointInAreaLocator.locateInGeometry(p, g2);\n\t\t\t\tif (loc !== Location.EXTERIOR) return loc;\n\t\t\t}\n\t\t}\n\t}\n\treturn Location.EXTERIOR;\n};\nSimplePointInAreaLocator.locate = function (p, geom) {\n\tif (geom.isEmpty()) return Location.EXTERIOR;\n\treturn SimplePointInAreaLocator.locateInGeometry(p, geom);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/algorithm/locate/SimplePointInAreaLocator.js\n// module id = 193\n// module chunks = 0","import extend from '../../../../extend';\nimport Comparable from '../../../../java/lang/Comparable';\nimport CoordinateArrays from '../geom/CoordinateArrays';\nexport default function OrientedCoordinateArray() {\n\tthis._pts = null;\n\tthis._orientation = null;\n\tlet pts = arguments[0];\n\tthis._pts = pts;\n\tthis._orientation = OrientedCoordinateArray.orientation(pts);\n}\nextend(OrientedCoordinateArray.prototype, {\n\tcompareTo: function (o1) {\n\t\tvar oca = o1;\n\t\tvar comp = OrientedCoordinateArray.compareOriented(this._pts, this._orientation, oca._pts, oca._orientation);\n\t\treturn comp;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparable];\n\t},\n\tgetClass: function () {\n\t\treturn OrientedCoordinateArray;\n\t}\n});\nOrientedCoordinateArray.orientation = function (pts) {\n\treturn CoordinateArrays.increasingDirection(pts) === 1;\n};\nOrientedCoordinateArray.compareOriented = function (pts1, orientation1, pts2, orientation2) {\n\tvar dir1 = orientation1 ? 1 : -1;\n\tvar dir2 = orientation2 ? 1 : -1;\n\tvar limit1 = orientation1 ? pts1.length : -1;\n\tvar limit2 = orientation2 ? pts2.length : -1;\n\tvar i1 = orientation1 ? 0 : pts1.length - 1;\n\tvar i2 = orientation2 ? 0 : pts2.length - 1;\n\tvar comp = 0;\n\twhile (true) {\n\t\tvar compPt = pts1[i1].compareTo(pts2[i2]);\n\t\tif (compPt !== 0) return compPt;\n\t\ti1 += dir1;\n\t\ti2 += dir2;\n\t\tvar done1 = i1 === limit1;\n\t\tvar done2 = i2 === limit2;\n\t\tif (done1 && !done2) return -1;\n\t\tif (!done1 && done2) return 1;\n\t\tif (done1 && done2) return 0;\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/noding/OrientedCoordinateArray.js\n// module id = 194\n// module chunks = 0","import extend from '../../../../extend';\nimport SegmentIntersector from './SegmentIntersector';\nexport default function IntersectionAdder() {\n\tthis._hasIntersection = false;\n\tthis._hasProper = false;\n\tthis._hasProperInterior = false;\n\tthis._hasInterior = false;\n\tthis._properIntersectionPoint = null;\n\tthis._li = null;\n\tthis._isSelfIntersection = null;\n\tthis.numIntersections = 0;\n\tthis.numInteriorIntersections = 0;\n\tthis.numProperIntersections = 0;\n\tthis.numTests = 0;\n\tlet li = arguments[0];\n\tthis._li = li;\n}\nextend(IntersectionAdder.prototype, {\n\tisTrivialIntersection: function (e0, segIndex0, e1, segIndex1) {\n\t\tif (e0 === e1) {\n\t\t\tif (this._li.getIntersectionNum() === 1) {\n\t\t\t\tif (IntersectionAdder.isAdjacentSegments(segIndex0, segIndex1)) return true;\n\t\t\t\tif (e0.isClosed()) {\n\t\t\t\t\tvar maxSegIndex = e0.size() - 1;\n\t\t\t\t\tif (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetProperIntersectionPoint: function () {\n\t\treturn this._properIntersectionPoint;\n\t},\n\thasProperInteriorIntersection: function () {\n\t\treturn this._hasProperInterior;\n\t},\n\tgetLineIntersector: function () {\n\t\treturn this._li;\n\t},\n\thasProperIntersection: function () {\n\t\treturn this._hasProper;\n\t},\n\tprocessIntersections: function (e0, segIndex0, e1, segIndex1) {\n\t\tif (e0 === e1 && segIndex0 === segIndex1) return null;\n\t\tthis.numTests++;\n\t\tvar p00 = e0.getCoordinates()[segIndex0];\n\t\tvar p01 = e0.getCoordinates()[segIndex0 + 1];\n\t\tvar p10 = e1.getCoordinates()[segIndex1];\n\t\tvar p11 = e1.getCoordinates()[segIndex1 + 1];\n\t\tthis._li.computeIntersection(p00, p01, p10, p11);\n\t\tif (this._li.hasIntersection()) {\n\t\t\tthis.numIntersections++;\n\t\t\tif (this._li.isInteriorIntersection()) {\n\t\t\t\tthis.numInteriorIntersections++;\n\t\t\t\tthis._hasInterior = true;\n\t\t\t}\n\t\t\tif (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {\n\t\t\t\tthis._hasIntersection = true;\n\t\t\t\te0.addIntersections(this._li, segIndex0, 0);\n\t\t\t\te1.addIntersections(this._li, segIndex1, 1);\n\t\t\t\tif (this._li.isProper()) {\n\t\t\t\t\tthis.numProperIntersections++;\n\t\t\t\t\tthis._hasProper = true;\n\t\t\t\t\tthis._hasProperInterior = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\thasIntersection: function () {\n\t\treturn this._hasIntersection;\n\t},\n\tisDone: function () {\n\t\treturn false;\n\t},\n\thasInteriorIntersection: function () {\n\t\treturn this._hasInterior;\n\t},\n\tinterfaces_: function () {\n\t\treturn [SegmentIntersector];\n\t},\n\tgetClass: function () {\n\t\treturn IntersectionAdder;\n\t}\n});\nIntersectionAdder.isAdjacentSegments = function (i1, i2) {\n\treturn Math.abs(i1 - i2) === 1;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/noding/IntersectionAdder.js\n// module id = 195\n// module chunks = 0","import EdgeIntersection from './EdgeIntersection';\nimport Coordinate from '../geom/Coordinate';\nimport extend from '../../../../extend';\nimport Label from './Label';\nimport Edge from './Edge';\nimport TreeMap from '../../../../java/util/TreeMap';\nexport default function EdgeIntersectionList() {\n\tthis._nodeMap = new TreeMap();\n\tthis.edge = null;\n\tlet edge = arguments[0];\n\tthis.edge = edge;\n}\nextend(EdgeIntersectionList.prototype, {\n\tprint: function (out) {\n\t\tout.println(\"Intersections:\");\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar ei = it.next();\n\t\t\tei.print(out);\n\t\t}\n\t},\n\titerator: function () {\n\t\treturn this._nodeMap.values().iterator();\n\t},\n\taddSplitEdges: function (edgeList) {\n\t\tthis.addEndpoints();\n\t\tvar it = this.iterator();\n\t\tvar eiPrev = it.next();\n\t\twhile (it.hasNext()) {\n\t\t\tvar ei = it.next();\n\t\t\tvar newEdge = this.createSplitEdge(eiPrev, ei);\n\t\t\tedgeList.add(newEdge);\n\t\t\teiPrev = ei;\n\t\t}\n\t},\n\taddEndpoints: function () {\n\t\tvar maxSegIndex = this.edge.pts.length - 1;\n\t\tthis.add(this.edge.pts[0], 0, 0.0);\n\t\tthis.add(this.edge.pts[maxSegIndex], maxSegIndex, 0.0);\n\t},\n\tcreateSplitEdge: function (ei0, ei1) {\n\t\tvar npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n\t\tvar lastSegStartPt = this.edge.pts[ei1.segmentIndex];\n\t\tvar useIntPt1 = ei1.dist > 0.0 || !ei1.coord.equals2D(lastSegStartPt);\n\t\tif (!useIntPt1) {\n\t\t\tnpts--;\n\t\t}\n\t\tvar pts = new Array(npts).fill(null);\n\t\tvar ipt = 0;\n\t\tpts[ipt++] = new Coordinate(ei0.coord);\n\t\tfor (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n\t\t\tpts[ipt++] = this.edge.pts[i];\n\t\t}\n\t\tif (useIntPt1) pts[ipt] = ei1.coord;\n\t\treturn new Edge(pts, new Label(this.edge._label));\n\t},\n\tadd: function (intPt, segmentIndex, dist) {\n\t\tvar eiNew = new EdgeIntersection(intPt, segmentIndex, dist);\n\t\tvar ei = this._nodeMap.get(eiNew);\n\t\tif (ei !== null) {\n\t\t\treturn ei;\n\t\t}\n\t\tthis._nodeMap.put(eiNew, eiNew);\n\t\treturn eiNew;\n\t},\n\tisIntersection: function (pt) {\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar ei = it.next();\n\t\t\tif (ei.coord.equals(pt)) return true;\n\t\t}\n\t\treturn false;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn EdgeIntersectionList;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeIntersectionList.js\n// module id = 196\n// module chunks = 0","import Coordinate from '../geom/Coordinate';\nimport extend from '../../../../extend';\nimport Comparable from '../../../../java/lang/Comparable';\nexport default function EdgeIntersection() {\n\tthis.coord = null;\n\tthis.segmentIndex = null;\n\tthis.dist = null;\n\tlet coord = arguments[0], segmentIndex = arguments[1], dist = arguments[2];\n\tthis.coord = new Coordinate(coord);\n\tthis.segmentIndex = segmentIndex;\n\tthis.dist = dist;\n}\nextend(EdgeIntersection.prototype, {\n\tgetSegmentIndex: function () {\n\t\treturn this.segmentIndex;\n\t},\n\tgetCoordinate: function () {\n\t\treturn this.coord;\n\t},\n\tprint: function (out) {\n\t\tout.print(this.coord);\n\t\tout.print(\" seg # = \" + this.segmentIndex);\n\t\tout.println(\" dist = \" + this.dist);\n\t},\n\tcompareTo: function (obj) {\n\t\tvar other = obj;\n\t\treturn this.compare(other.segmentIndex, other.dist);\n\t},\n\tisEndPoint: function (maxSegmentIndex) {\n\t\tif (this.segmentIndex === 0 && this.dist === 0.0) return true;\n\t\tif (this.segmentIndex === maxSegmentIndex) return true;\n\t\treturn false;\n\t},\n\ttoString: function () {\n\t\treturn this.coord + \" seg # = \" + this.segmentIndex + \" dist = \" + this.dist;\n\t},\n\tgetDistance: function () {\n\t\treturn this.dist;\n\t},\n\tcompare: function (segmentIndex, dist) {\n\t\tif (this.segmentIndex < segmentIndex) return -1;\n\t\tif (this.segmentIndex > segmentIndex) return 1;\n\t\tif (this.dist < dist) return -1;\n\t\tif (this.dist > dist) return 1;\n\t\treturn 0;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparable];\n\t},\n\tgetClass: function () {\n\t\treturn EdgeIntersection;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeIntersection.js\n// module id = 197\n// module chunks = 0","import Location from './Location';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../extend';\nimport Dimension from './Dimension';\nimport Cloneable from '../../../../java/lang/Cloneable';\nimport StringBuilder from '../../../../java/lang/StringBuilder';\nexport default function IntersectionMatrix() {\n\tthis._matrix = null;\n\tif (arguments.length === 0) {\n\t\tthis._matrix = Array(3).fill().map(() => Array(3));\n\t\tthis.setAll(Dimension.FALSE);\n\t} else if (arguments.length === 1) {\n\t\tif (typeof arguments[0] === \"string\") {\n\t\t\tlet elements = arguments[0];\n\t\t\tIntersectionMatrix.call(this);\n\t\t\tthis.set(elements);\n\t\t} else if (arguments[0] instanceof IntersectionMatrix) {\n\t\t\tlet other = arguments[0];\n\t\t\tIntersectionMatrix.call(this);\n\t\t\tthis._matrix[Location.INTERIOR][Location.INTERIOR] = other._matrix[Location.INTERIOR][Location.INTERIOR];\n\t\t\tthis._matrix[Location.INTERIOR][Location.BOUNDARY] = other._matrix[Location.INTERIOR][Location.BOUNDARY];\n\t\t\tthis._matrix[Location.INTERIOR][Location.EXTERIOR] = other._matrix[Location.INTERIOR][Location.EXTERIOR];\n\t\t\tthis._matrix[Location.BOUNDARY][Location.INTERIOR] = other._matrix[Location.BOUNDARY][Location.INTERIOR];\n\t\t\tthis._matrix[Location.BOUNDARY][Location.BOUNDARY] = other._matrix[Location.BOUNDARY][Location.BOUNDARY];\n\t\t\tthis._matrix[Location.BOUNDARY][Location.EXTERIOR] = other._matrix[Location.BOUNDARY][Location.EXTERIOR];\n\t\t\tthis._matrix[Location.EXTERIOR][Location.INTERIOR] = other._matrix[Location.EXTERIOR][Location.INTERIOR];\n\t\t\tthis._matrix[Location.EXTERIOR][Location.BOUNDARY] = other._matrix[Location.EXTERIOR][Location.BOUNDARY];\n\t\t\tthis._matrix[Location.EXTERIOR][Location.EXTERIOR] = other._matrix[Location.EXTERIOR][Location.EXTERIOR];\n\t\t}\n\t}\n}\nextend(IntersectionMatrix.prototype, {\n\tisIntersects: function () {\n\t\treturn !this.isDisjoint();\n\t},\n\tisCovers: function () {\n\t\tvar hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]);\n\t\treturn hasPointInCommon && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n\t},\n\tisCoveredBy: function () {\n\t\tvar hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]);\n\t\treturn hasPointInCommon && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE;\n\t},\n\tset: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet dimensionSymbols = arguments[0];\n\t\t\tfor (var i = 0; i < dimensionSymbols.length; i++) {\n\t\t\t\tvar row = Math.trunc(i / 3);\n\t\t\t\tvar col = i % 3;\n\t\t\t\tthis._matrix[row][col] = Dimension.toDimensionValue(dimensionSymbols.charAt(i));\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet row = arguments[0], column = arguments[1], dimensionValue = arguments[2];\n\t\t\tthis._matrix[row][column] = dimensionValue;\n\t\t}\n\t},\n\tisContains: function () {\n\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n\t},\n\tsetAtLeast: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet minimumDimensionSymbols = arguments[0];\n\t\t\tfor (var i = 0; i < minimumDimensionSymbols.length; i++) {\n\t\t\t\tvar row = Math.trunc(i / 3);\n\t\t\t\tvar col = i % 3;\n\t\t\t\tthis.setAtLeast(row, col, Dimension.toDimensionValue(minimumDimensionSymbols.charAt(i)));\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet row = arguments[0], column = arguments[1], minimumDimensionValue = arguments[2];\n\t\t\tif (this._matrix[row][column] < minimumDimensionValue) {\n\t\t\t\tthis._matrix[row][column] = minimumDimensionValue;\n\t\t\t}\n\t\t}\n\t},\n\tsetAtLeastIfValid: function (row, column, minimumDimensionValue) {\n\t\tif (row >= 0 && column >= 0) {\n\t\t\tthis.setAtLeast(row, column, minimumDimensionValue);\n\t\t}\n\t},\n\tisWithin: function () {\n\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE;\n\t},\n\tisTouches: function (dimensionOfGeometryA, dimensionOfGeometryB) {\n\t\tif (dimensionOfGeometryA > dimensionOfGeometryB) {\n\t\t\treturn this.isTouches(dimensionOfGeometryB, dimensionOfGeometryA);\n\t\t}\n\t\tif (dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.L) {\n\t\t\treturn this._matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE && (IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]));\n\t\t}\n\t\treturn false;\n\t},\n\tisOverlaps: function (dimensionOfGeometryA, dimensionOfGeometryB) {\n\t\tif (dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.A) {\n\t\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);\n\t\t}\n\t\tif (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L) {\n\t\t\treturn this._matrix[Location.INTERIOR][Location.INTERIOR] === 1 && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);\n\t\t}\n\t\treturn false;\n\t},\n\tisEquals: function (dimensionOfGeometryA, dimensionOfGeometryB) {\n\t\tif (dimensionOfGeometryA !== dimensionOfGeometryB) {\n\t\t\treturn false;\n\t\t}\n\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n\t},\n\ttoString: function () {\n\t\tvar builder = new StringBuilder(\"123456789\");\n\t\tfor (var ai = 0; ai < 3; ai++) {\n\t\t\tfor (var bi = 0; bi < 3; bi++) {\n\t\t\t\tbuilder.setCharAt(3 * ai + bi, Dimension.toDimensionSymbol(this._matrix[ai][bi]));\n\t\t\t}\n\t\t}\n\t\treturn builder.toString();\n\t},\n\tsetAll: function (dimensionValue) {\n\t\tfor (var ai = 0; ai < 3; ai++) {\n\t\t\tfor (var bi = 0; bi < 3; bi++) {\n\t\t\t\tthis._matrix[ai][bi] = dimensionValue;\n\t\t\t}\n\t\t}\n\t},\n\tget: function (row, column) {\n\t\treturn this._matrix[row][column];\n\t},\n\ttranspose: function () {\n\t\tvar temp = this._matrix[1][0];\n\t\tthis._matrix[1][0] = this._matrix[0][1];\n\t\tthis._matrix[0][1] = temp;\n\t\ttemp = this._matrix[2][0];\n\t\tthis._matrix[2][0] = this._matrix[0][2];\n\t\tthis._matrix[0][2] = temp;\n\t\ttemp = this._matrix[2][1];\n\t\tthis._matrix[2][1] = this._matrix[1][2];\n\t\tthis._matrix[1][2] = temp;\n\t\treturn this;\n\t},\n\tmatches: function (requiredDimensionSymbols) {\n\t\tif (requiredDimensionSymbols.length !== 9) {\n\t\t\tthrow new IllegalArgumentException(\"Should be length 9: \" + requiredDimensionSymbols);\n\t\t}\n\t\tfor (var ai = 0; ai < 3; ai++) {\n\t\t\tfor (var bi = 0; bi < 3; bi++) {\n\t\t\t\tif (!IntersectionMatrix.matches(this._matrix[ai][bi], requiredDimensionSymbols.charAt(3 * ai + bi))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\tadd: function (im) {\n\t\tfor (var i = 0; i < 3; i++) {\n\t\t\tfor (var j = 0; j < 3; j++) {\n\t\t\t\tthis.setAtLeast(i, j, im.get(i, j));\n\t\t\t}\n\t\t}\n\t},\n\tisDisjoint: function () {\n\t\treturn this._matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.INTERIOR][Location.BOUNDARY] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.BOUNDARY] === Dimension.FALSE;\n\t},\n\tisCrosses: function (dimensionOfGeometryA, dimensionOfGeometryB) {\n\t\tif (dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.L || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.A) {\n\t\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]);\n\t\t}\n\t\tif (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.L) {\n\t\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);\n\t\t}\n\t\tif (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L) {\n\t\t\treturn this._matrix[Location.INTERIOR][Location.INTERIOR] === 0;\n\t\t}\n\t\treturn false;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Cloneable];\n\t},\n\tgetClass: function () {\n\t\treturn IntersectionMatrix;\n\t}\n});\nIntersectionMatrix.matches = function () {\n\tif (Number.isInteger(arguments[0]) && typeof arguments[1] === \"string\") {\n\t\tlet actualDimensionValue = arguments[0], requiredDimensionSymbol = arguments[1];\n\t\tif (requiredDimensionSymbol === Dimension.SYM_DONTCARE) {\n\t\t\treturn true;\n\t\t}\n\t\tif (requiredDimensionSymbol === Dimension.SYM_TRUE && (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (requiredDimensionSymbol === Dimension.SYM_FALSE && actualDimensionValue === Dimension.FALSE) {\n\t\t\treturn true;\n\t\t}\n\t\tif (requiredDimensionSymbol === Dimension.SYM_P && actualDimensionValue === Dimension.P) {\n\t\t\treturn true;\n\t\t}\n\t\tif (requiredDimensionSymbol === Dimension.SYM_L && actualDimensionValue === Dimension.L) {\n\t\t\treturn true;\n\t\t}\n\t\tif (requiredDimensionSymbol === Dimension.SYM_A && actualDimensionValue === Dimension.A) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t} else if (typeof arguments[0] === \"string\" && typeof arguments[1] === \"string\") {\n\t\tlet actualDimensionSymbols = arguments[0], requiredDimensionSymbols = arguments[1];\n\t\tvar m = new IntersectionMatrix(actualDimensionSymbols);\n\t\treturn m.matches(requiredDimensionSymbols);\n\t}\n};\nIntersectionMatrix.isTrue = function (actualDimensionValue) {\n\tif (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE) {\n\t\treturn true;\n\t}\n\treturn false;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/IntersectionMatrix.js\n// module id = 198\n// module chunks = 0","import extend from '../../../../../extend';\nimport MonotoneChainIndexer from './MonotoneChainIndexer';\nimport Envelope from '../../geom/Envelope';\nexport default function MonotoneChainEdge() {\n\tthis.e = null;\n\tthis.pts = null;\n\tthis.startIndex = null;\n\tlet e = arguments[0];\n\tthis.e = e;\n\tthis.pts = e.getCoordinates();\n\tvar mcb = new MonotoneChainIndexer();\n\tthis.startIndex = mcb.getChainStartIndices(this.pts);\n}\nextend(MonotoneChainEdge.prototype, {\n\tgetCoordinates: function () {\n\t\treturn this.pts;\n\t},\n\tgetMaxX: function (chainIndex) {\n\t\tvar x1 = this.pts[this.startIndex[chainIndex]].x;\n\t\tvar x2 = this.pts[this.startIndex[chainIndex + 1]].x;\n\t\treturn x1 > x2 ? x1 : x2;\n\t},\n\tgetMinX: function (chainIndex) {\n\t\tvar x1 = this.pts[this.startIndex[chainIndex]].x;\n\t\tvar x2 = this.pts[this.startIndex[chainIndex + 1]].x;\n\t\treturn x1 < x2 ? x1 : x2;\n\t},\n\tcomputeIntersectsForChain: function () {\n\t\tif (arguments.length === 4) {\n\t\t\tlet chainIndex0 = arguments[0], mce = arguments[1], chainIndex1 = arguments[2], si = arguments[3];\n\t\t\tthis.computeIntersectsForChain(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1], mce, mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1], si);\n\t\t} else if (arguments.length === 6) {\n\t\t\tlet start0 = arguments[0], end0 = arguments[1], mce = arguments[2], start1 = arguments[3], end1 = arguments[4], ei = arguments[5];\n\t\t\tif (end0 - start0 === 1 && end1 - start1 === 1) {\n\t\t\t\tei.addIntersections(this.e, start0, mce.e, start1);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (!this.overlaps(start0, end0, mce, start1, end1)) return null;\n\t\t\tvar mid0 = Math.trunc((start0 + end0) / 2);\n\t\t\tvar mid1 = Math.trunc((start1 + end1) / 2);\n\t\t\tif (start0 < mid0) {\n\t\t\t\tif (start1 < mid1) this.computeIntersectsForChain(start0, mid0, mce, start1, mid1, ei);\n\t\t\t\tif (mid1 < end1) this.computeIntersectsForChain(start0, mid0, mce, mid1, end1, ei);\n\t\t\t}\n\t\t\tif (mid0 < end0) {\n\t\t\t\tif (start1 < mid1) this.computeIntersectsForChain(mid0, end0, mce, start1, mid1, ei);\n\t\t\t\tif (mid1 < end1) this.computeIntersectsForChain(mid0, end0, mce, mid1, end1, ei);\n\t\t\t}\n\t\t}\n\t},\n\toverlaps: function (start0, end0, mce, start1, end1) {\n\t\treturn Envelope.intersects(this.pts[start0], this.pts[end0], mce.pts[start1], mce.pts[end1]);\n\t},\n\tgetStartIndexes: function () {\n\t\treturn this.startIndex;\n\t},\n\tcomputeIntersects: function (mce, si) {\n\t\tfor (var i = 0; i < this.startIndex.length - 1; i++) {\n\t\t\tfor (var j = 0; j < mce.startIndex.length - 1; j++) {\n\t\t\t\tthis.computeIntersectsForChain(i, mce, j, si);\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn MonotoneChainEdge;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geomgraph/index/MonotoneChainEdge.js\n// module id = 199\n// module chunks = 0","import extend from '../../../../../extend';\nimport Integer from '../../../../../java/lang/Integer';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Quadrant from '../Quadrant';\nexport default function MonotoneChainIndexer() {}\nextend(MonotoneChainIndexer.prototype, {\n\tgetChainStartIndices: function (pts) {\n\t\tvar start = 0;\n\t\tvar startIndexList = new ArrayList();\n\t\tstartIndexList.add(new Integer(start));\n\t\tdo {\n\t\t\tvar last = this.findChainEnd(pts, start);\n\t\t\tstartIndexList.add(new Integer(last));\n\t\t\tstart = last;\n\t\t} while (start < pts.length - 1);\n\t\tvar startIndex = MonotoneChainIndexer.toIntArray(startIndexList);\n\t\treturn startIndex;\n\t},\n\tfindChainEnd: function (pts, start) {\n\t\tvar chainQuad = Quadrant.quadrant(pts[start], pts[start + 1]);\n\t\tvar last = start + 1;\n\t\twhile (last < pts.length) {\n\t\t\tvar quad = Quadrant.quadrant(pts[last - 1], pts[last]);\n\t\t\tif (quad !== chainQuad) break;\n\t\t\tlast++;\n\t\t}\n\t\treturn last - 1;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn MonotoneChainIndexer;\n\t}\n});\nMonotoneChainIndexer.toIntArray = function (list) {\n\tvar array = new Array(list.size()).fill(null);\n\tfor (var i = 0; i < array.length; i++) {\n\t\tarray[i] = list.get(i).intValue();\n\t}\n\treturn array;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geomgraph/index/MonotoneChainIndexer.js\n// module id = 200\n// module chunks = 0","import Location from '../geom/Location';\nimport Position from './Position';\nimport extend from '../../../../extend';\nexport default function Depth() {\n\tthis._depth = Array(2).fill().map(() => Array(3));\n\tfor (var i = 0; i < 2; i++) {\n\t\tfor (var j = 0; j < 3; j++) {\n\t\t\tthis._depth[i][j] = Depth.NULL_VALUE;\n\t\t}\n\t}\n}\nextend(Depth.prototype, {\n\tgetDepth: function (geomIndex, posIndex) {\n\t\treturn this._depth[geomIndex][posIndex];\n\t},\n\tsetDepth: function (geomIndex, posIndex, depthValue) {\n\t\tthis._depth[geomIndex][posIndex] = depthValue;\n\t},\n\tisNull: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tfor (var j = 0; j < 3; j++) {\n\t\t\t\t\tif (this._depth[i][j] !== Depth.NULL_VALUE) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet geomIndex = arguments[0];\n\t\t\treturn this._depth[geomIndex][1] === Depth.NULL_VALUE;\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet geomIndex = arguments[0], posIndex = arguments[1];\n\t\t\treturn this._depth[geomIndex][posIndex] === Depth.NULL_VALUE;\n\t\t}\n\t},\n\tnormalize: function () {\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (!this.isNull(i)) {\n\t\t\t\tvar minDepth = this._depth[i][1];\n\t\t\t\tif (this._depth[i][2] < minDepth) minDepth = this._depth[i][2];\n\t\t\t\tif (minDepth < 0) minDepth = 0;\n\t\t\t\tfor (var j = 1; j < 3; j++) {\n\t\t\t\t\tvar newValue = 0;\n\t\t\t\t\tif (this._depth[i][j] > minDepth) newValue = 1;\n\t\t\t\t\tthis._depth[i][j] = newValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tgetDelta: function (geomIndex) {\n\t\treturn this._depth[geomIndex][Position.RIGHT] - this._depth[geomIndex][Position.LEFT];\n\t},\n\tgetLocation: function (geomIndex, posIndex) {\n\t\tif (this._depth[geomIndex][posIndex] <= 0) return Location.EXTERIOR;\n\t\treturn Location.INTERIOR;\n\t},\n\ttoString: function () {\n\t\treturn \"A: \" + this._depth[0][1] + \",\" + this._depth[0][2] + \" B: \" + this._depth[1][1] + \",\" + this._depth[1][2];\n\t},\n\tadd: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet lbl = arguments[0];\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tfor (var j = 1; j < 3; j++) {\n\t\t\t\t\tvar loc = lbl.getLocation(i, j);\n\t\t\t\t\tif (loc === Location.EXTERIOR || loc === Location.INTERIOR) {\n\t\t\t\t\t\tif (this.isNull(i, j)) {\n\t\t\t\t\t\t\tthis._depth[i][j] = Depth.depthAtLocation(loc);\n\t\t\t\t\t\t} else this._depth[i][j] += Depth.depthAtLocation(loc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet geomIndex = arguments[0], posIndex = arguments[1], location = arguments[2];\n\t\t\tif (location === Location.INTERIOR) this._depth[geomIndex][posIndex]++;\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Depth;\n\t}\n});\nDepth.depthAtLocation = function (location) {\n\tif (location === Location.EXTERIOR) return 0;\n\tif (location === Location.INTERIOR) return 1;\n\treturn Depth.NULL_VALUE;\n};\nDepth.NULL_VALUE = -1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geomgraph/Depth.js\n// module id = 201\n// module chunks = 0","import hasInterface from '../../../../hasInterface';\nimport Collection from '../../../../java/util/Collection';\nimport Noder from './Noder';\nimport Coordinate from '../geom/Coordinate';\nimport NodedSegmentString from './NodedSegmentString';\nimport extend from '../../../../extend';\nimport System from '../../../../java/lang/System';\nimport CoordinateArrays from '../geom/CoordinateArrays';\nimport ArrayList from '../../../../java/util/ArrayList';\nexport default function ScaledNoder() {\n\tthis._noder = null;\n\tthis._scaleFactor = null;\n\tthis._offsetX = null;\n\tthis._offsetY = null;\n\tthis._isScaled = false;\n\tif (arguments.length === 2) {\n\t\tlet noder = arguments[0], scaleFactor = arguments[1];\n\t\tScaledNoder.call(this, noder, scaleFactor, 0, 0);\n\t} else if (arguments.length === 4) {\n\t\tlet noder = arguments[0], scaleFactor = arguments[1], offsetX = arguments[2], offsetY = arguments[3];\n\t\tthis._noder = noder;\n\t\tthis._scaleFactor = scaleFactor;\n\t\tthis._isScaled = !this.isIntegerPrecision();\n\t}\n}\nextend(ScaledNoder.prototype, {\n\trescale: function () {\n\t\tif (hasInterface(arguments[0], Collection)) {\n\t\t\tlet segStrings = arguments[0];\n\t\t\tfor (var i = segStrings.iterator(); i.hasNext(); ) {\n\t\t\t\tvar ss = i.next();\n\t\t\t\tthis.rescale(ss.getCoordinates());\n\t\t\t}\n\t\t} else if (arguments[0] instanceof Array) {\n\t\t\tlet pts = arguments[0];\n\t\t\tvar p0 = null;\n\t\t\tvar p1 = null;\n\t\t\tif (pts.length === 2) {\n\t\t\t\tp0 = new Coordinate(pts[0]);\n\t\t\t\tp1 = new Coordinate(pts[1]);\n\t\t\t}\n\t\t\tfor (var i = 0; i < pts.length; i++) {\n\t\t\t\tpts[i].x = pts[i].x / this._scaleFactor + this._offsetX;\n\t\t\t\tpts[i].y = pts[i].y / this._scaleFactor + this._offsetY;\n\t\t\t}\n\t\t\tif (pts.length === 2 && pts[0].equals2D(pts[1])) {\n\t\t\t\tSystem.out.println(pts);\n\t\t\t}\n\t\t}\n\t},\n\tscale: function () {\n\t\tif (hasInterface(arguments[0], Collection)) {\n\t\t\tlet segStrings = arguments[0];\n\t\t\tvar nodedSegmentStrings = new ArrayList(segStrings.size());\n\t\t\tfor (var i = segStrings.iterator(); i.hasNext(); ) {\n\t\t\t\tvar ss = i.next();\n\t\t\t\tnodedSegmentStrings.add(new NodedSegmentString(this.scale(ss.getCoordinates()), ss.getData()));\n\t\t\t}\n\t\t\treturn nodedSegmentStrings;\n\t\t} else if (arguments[0] instanceof Array) {\n\t\t\tlet pts = arguments[0];\n\t\t\tvar roundPts = new Array(pts.length).fill(null);\n\t\t\tfor (var i = 0; i < pts.length; i++) {\n\t\t\t\troundPts[i] = new Coordinate(Math.round((pts[i].x - this._offsetX) * this._scaleFactor), Math.round((pts[i].y - this._offsetY) * this._scaleFactor), pts[i].z);\n\t\t\t}\n\t\t\tvar roundPtsNoDup = CoordinateArrays.removeRepeatedPoints(roundPts);\n\t\t\treturn roundPtsNoDup;\n\t\t}\n\t},\n\tisIntegerPrecision: function () {\n\t\treturn this._scaleFactor === 1.0;\n\t},\n\tgetNodedSubstrings: function () {\n\t\tvar splitSS = this._noder.getNodedSubstrings();\n\t\tif (this._isScaled) this.rescale(splitSS);\n\t\treturn splitSS;\n\t},\n\tcomputeNodes: function (inputSegStrings) {\n\t\tvar intSegStrings = inputSegStrings;\n\t\tif (this._isScaled) intSegStrings = this.scale(inputSegStrings);\n\t\tthis._noder.computeNodes(intSegStrings);\n\t},\n\tinterfaces_: function () {\n\t\treturn [Noder];\n\t},\n\tgetClass: function () {\n\t\treturn ScaledNoder;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/noding/ScaledNoder.js\n// module id = 202\n// module chunks = 0","import NodingValidator from '../NodingValidator';\nimport hasInterface from '../../../../../hasInterface';\nimport Collection from '../../../../../java/util/Collection';\nimport Noder from '../Noder';\nimport MCIndexNoder from '../MCIndexNoder';\nimport NodedSegmentString from '../NodedSegmentString';\nimport HotPixel from './HotPixel';\nimport extend from '../../../../../extend';\nimport Exception from '../../../../../java/lang/Exception';\nimport MCIndexPointSnapper from './MCIndexPointSnapper';\nimport RobustLineIntersector from '../../algorithm/RobustLineIntersector';\nimport InteriorIntersectionFinderAdder from '../InteriorIntersectionFinderAdder';\nexport default function MCIndexSnapRounder() {\n\tthis._pm = null;\n\tthis._li = null;\n\tthis._scaleFactor = null;\n\tthis._noder = null;\n\tthis._pointSnapper = null;\n\tthis._nodedSegStrings = null;\n\tlet pm = arguments[0];\n\tthis._pm = pm;\n\tthis._li = new RobustLineIntersector();\n\tthis._li.setPrecisionModel(pm);\n\tthis._scaleFactor = pm.getScale();\n}\nextend(MCIndexSnapRounder.prototype, {\n\tcheckCorrectness: function (inputSegmentStrings) {\n\t\tvar resultSegStrings = NodedSegmentString.getNodedSubstrings(inputSegmentStrings);\n\t\tvar nv = new NodingValidator(resultSegStrings);\n\t\ttry {\n\t\t\tnv.checkValid();\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof Exception) {\n\t\t\t\tex.printStackTrace();\n\t\t\t} else throw ex;\n\t\t} finally {}\n\t},\n\tgetNodedSubstrings: function () {\n\t\treturn NodedSegmentString.getNodedSubstrings(this._nodedSegStrings);\n\t},\n\tsnapRound: function (segStrings, li) {\n\t\tvar intersections = this.findInteriorIntersections(segStrings, li);\n\t\tthis.computeIntersectionSnaps(intersections);\n\t\tthis.computeVertexSnaps(segStrings);\n\t},\n\tfindInteriorIntersections: function (segStrings, li) {\n\t\tvar intFinderAdder = new InteriorIntersectionFinderAdder(li);\n\t\tthis._noder.setSegmentIntersector(intFinderAdder);\n\t\tthis._noder.computeNodes(segStrings);\n\t\treturn intFinderAdder.getInteriorIntersections();\n\t},\n\tcomputeVertexSnaps: function () {\n\t\tif (hasInterface(arguments[0], Collection)) {\n\t\t\tlet edges = arguments[0];\n\t\t\tfor (var i0 = edges.iterator(); i0.hasNext(); ) {\n\t\t\t\tvar edge0 = i0.next();\n\t\t\t\tthis.computeVertexSnaps(edge0);\n\t\t\t}\n\t\t} else if (arguments[0] instanceof NodedSegmentString) {\n\t\t\tlet e = arguments[0];\n\t\t\tvar pts0 = e.getCoordinates();\n\t\t\tfor (var i = 0; i < pts0.length; i++) {\n\t\t\t\tvar hotPixel = new HotPixel(pts0[i], this._scaleFactor, this._li);\n\t\t\t\tvar isNodeAdded = this._pointSnapper.snap(hotPixel, e, i);\n\t\t\t\tif (isNodeAdded) {\n\t\t\t\t\te.addIntersection(pts0[i], i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tcomputeNodes: function (inputSegmentStrings) {\n\t\tthis._nodedSegStrings = inputSegmentStrings;\n\t\tthis._noder = new MCIndexNoder();\n\t\tthis._pointSnapper = new MCIndexPointSnapper(this._noder.getIndex());\n\t\tthis.snapRound(inputSegmentStrings, this._li);\n\t},\n\tcomputeIntersectionSnaps: function (snapPts) {\n\t\tfor (var it = snapPts.iterator(); it.hasNext(); ) {\n\t\t\tvar snapPt = it.next();\n\t\t\tvar hotPixel = new HotPixel(snapPt, this._scaleFactor, this._li);\n\t\t\tthis._pointSnapper.snap(hotPixel);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [Noder];\n\t},\n\tgetClass: function () {\n\t\treturn MCIndexSnapRounder;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/noding/snapround/MCIndexSnapRounder.js\n// module id = 203\n// module chunks = 0","import GeometryFactory from '../geom/GeometryFactory';\nimport extend from '../../../../extend';\nimport RobustLineIntersector from '../algorithm/RobustLineIntersector';\nimport RuntimeException from '../../../../java/lang/RuntimeException';\nexport default function NodingValidator() {\n\tthis._li = new RobustLineIntersector();\n\tthis._segStrings = null;\n\tlet segStrings = arguments[0];\n\tthis._segStrings = segStrings;\n}\nextend(NodingValidator.prototype, {\n\tcheckEndPtVertexIntersections: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tfor (var i = this._segStrings.iterator(); i.hasNext(); ) {\n\t\t\t\tvar ss = i.next();\n\t\t\t\tvar pts = ss.getCoordinates();\n\t\t\t\tthis.checkEndPtVertexIntersections(pts[0], this._segStrings);\n\t\t\t\tthis.checkEndPtVertexIntersections(pts[pts.length - 1], this._segStrings);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet testPt = arguments[0], segStrings = arguments[1];\n\t\t\tfor (var i = segStrings.iterator(); i.hasNext(); ) {\n\t\t\t\tvar ss = i.next();\n\t\t\t\tvar pts = ss.getCoordinates();\n\t\t\t\tfor (var j = 1; j < pts.length - 1; j++) {\n\t\t\t\t\tif (pts[j].equals(testPt)) throw new RuntimeException(\"found endpt/interior pt intersection at index \" + j + \" :pt \" + testPt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tcheckInteriorIntersections: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tfor (var i = this._segStrings.iterator(); i.hasNext(); ) {\n\t\t\t\tvar ss0 = i.next();\n\t\t\t\tfor (var j = this._segStrings.iterator(); j.hasNext(); ) {\n\t\t\t\t\tvar ss1 = j.next();\n\t\t\t\t\tthis.checkInteriorIntersections(ss0, ss1);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet ss0 = arguments[0], ss1 = arguments[1];\n\t\t\tvar pts0 = ss0.getCoordinates();\n\t\t\tvar pts1 = ss1.getCoordinates();\n\t\t\tfor (var i0 = 0; i0 < pts0.length - 1; i0++) {\n\t\t\t\tfor (var i1 = 0; i1 < pts1.length - 1; i1++) {\n\t\t\t\t\tthis.checkInteriorIntersections(ss0, i0, ss1, i1);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments.length === 4) {\n\t\t\tlet e0 = arguments[0], segIndex0 = arguments[1], e1 = arguments[2], segIndex1 = arguments[3];\n\t\t\tif (e0 === e1 && segIndex0 === segIndex1) return null;\n\t\t\tvar p00 = e0.getCoordinates()[segIndex0];\n\t\t\tvar p01 = e0.getCoordinates()[segIndex0 + 1];\n\t\t\tvar p10 = e1.getCoordinates()[segIndex1];\n\t\t\tvar p11 = e1.getCoordinates()[segIndex1 + 1];\n\t\t\tthis._li.computeIntersection(p00, p01, p10, p11);\n\t\t\tif (this._li.hasIntersection()) {\n\t\t\t\tif (this._li.isProper() || this.hasInteriorIntersection(this._li, p00, p01) || this.hasInteriorIntersection(this._li, p10, p11)) {\n\t\t\t\t\tthrow new RuntimeException(\"found non-noded intersection at \" + p00 + \"-\" + p01 + \" and \" + p10 + \"-\" + p11);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tcheckValid: function () {\n\t\tthis.checkEndPtVertexIntersections();\n\t\tthis.checkInteriorIntersections();\n\t\tthis.checkCollapses();\n\t},\n\tcheckCollapses: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tfor (var i = this._segStrings.iterator(); i.hasNext(); ) {\n\t\t\t\tvar ss = i.next();\n\t\t\t\tthis.checkCollapses(ss);\n\t\t\t}\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet ss = arguments[0];\n\t\t\tvar pts = ss.getCoordinates();\n\t\t\tfor (var i = 0; i < pts.length - 2; i++) {\n\t\t\t\tthis.checkCollapse(pts[i], pts[i + 1], pts[i + 2]);\n\t\t\t}\n\t\t}\n\t},\n\thasInteriorIntersection: function (li, p0, p1) {\n\t\tfor (var i = 0; i < li.getIntersectionNum(); i++) {\n\t\t\tvar intPt = li.getIntersection(i);\n\t\t\tif (!(intPt.equals(p0) || intPt.equals(p1))) return true;\n\t\t}\n\t\treturn false;\n\t},\n\tcheckCollapse: function (p0, p1, p2) {\n\t\tif (p0.equals(p2)) throw new RuntimeException(\"found non-noded collapse at \" + NodingValidator.fact.createLineString([p0, p1, p2]));\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn NodingValidator;\n\t}\n});\nNodingValidator.fact = new GeometryFactory();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/noding/NodingValidator.js\n// module id = 204\n// module chunks = 0","import Coordinate from '../../geom/Coordinate';\nimport IllegalArgumentException from '../../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../../extend';\nimport Envelope from '../../geom/Envelope';\nimport Assert from '../../util/Assert';\nexport default function HotPixel() {\n\tthis._li = null;\n\tthis._pt = null;\n\tthis._originalPt = null;\n\tthis._ptScaled = null;\n\tthis._p0Scaled = null;\n\tthis._p1Scaled = null;\n\tthis._scaleFactor = null;\n\tthis._minx = null;\n\tthis._maxx = null;\n\tthis._miny = null;\n\tthis._maxy = null;\n\tthis._corner = new Array(4).fill(null);\n\tthis._safeEnv = null;\n\tlet pt = arguments[0], scaleFactor = arguments[1], li = arguments[2];\n\tthis._originalPt = pt;\n\tthis._pt = pt;\n\tthis._scaleFactor = scaleFactor;\n\tthis._li = li;\n\tif (scaleFactor <= 0) throw new IllegalArgumentException(\"Scale factor must be non-zero\");\n\tif (scaleFactor !== 1.0) {\n\t\tthis._pt = new Coordinate(this.scale(pt.x), this.scale(pt.y));\n\t\tthis._p0Scaled = new Coordinate();\n\t\tthis._p1Scaled = new Coordinate();\n\t}\n\tthis.initCorners(this._pt);\n}\nextend(HotPixel.prototype, {\n\tintersectsScaled: function (p0, p1) {\n\t\tvar segMinx = Math.min(p0.x, p1.x);\n\t\tvar segMaxx = Math.max(p0.x, p1.x);\n\t\tvar segMiny = Math.min(p0.y, p1.y);\n\t\tvar segMaxy = Math.max(p0.y, p1.y);\n\t\tvar isOutsidePixelEnv = this._maxx < segMinx || this._minx > segMaxx || this._maxy < segMiny || this._miny > segMaxy;\n\t\tif (isOutsidePixelEnv) return false;\n\t\tvar intersects = this.intersectsToleranceSquare(p0, p1);\n\t\tAssert.isTrue(!(isOutsidePixelEnv && intersects), \"Found bad envelope test\");\n\t\treturn intersects;\n\t},\n\tinitCorners: function (pt) {\n\t\tvar tolerance = 0.5;\n\t\tthis._minx = pt.x - tolerance;\n\t\tthis._maxx = pt.x + tolerance;\n\t\tthis._miny = pt.y - tolerance;\n\t\tthis._maxy = pt.y + tolerance;\n\t\tthis._corner[0] = new Coordinate(this._maxx, this._maxy);\n\t\tthis._corner[1] = new Coordinate(this._minx, this._maxy);\n\t\tthis._corner[2] = new Coordinate(this._minx, this._miny);\n\t\tthis._corner[3] = new Coordinate(this._maxx, this._miny);\n\t},\n\tintersects: function (p0, p1) {\n\t\tif (this._scaleFactor === 1.0) return this.intersectsScaled(p0, p1);\n\t\tthis.copyScaled(p0, this._p0Scaled);\n\t\tthis.copyScaled(p1, this._p1Scaled);\n\t\treturn this.intersectsScaled(this._p0Scaled, this._p1Scaled);\n\t},\n\tscale: function (val) {\n\t\treturn Math.round(val * this._scaleFactor);\n\t},\n\tgetCoordinate: function () {\n\t\treturn this._originalPt;\n\t},\n\tcopyScaled: function (p, pScaled) {\n\t\tpScaled.x = this.scale(p.x);\n\t\tpScaled.y = this.scale(p.y);\n\t},\n\tgetSafeEnvelope: function () {\n\t\tif (this._safeEnv === null) {\n\t\t\tvar safeTolerance = HotPixel.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;\n\t\t\tthis._safeEnv = new Envelope(this._originalPt.x - safeTolerance, this._originalPt.x + safeTolerance, this._originalPt.y - safeTolerance, this._originalPt.y + safeTolerance);\n\t\t}\n\t\treturn this._safeEnv;\n\t},\n\tintersectsPixelClosure: function (p0, p1) {\n\t\tthis._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);\n\t\tif (this._li.hasIntersection()) return true;\n\t\tthis._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);\n\t\tif (this._li.hasIntersection()) return true;\n\t\tthis._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);\n\t\tif (this._li.hasIntersection()) return true;\n\t\tthis._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);\n\t\tif (this._li.hasIntersection()) return true;\n\t\treturn false;\n\t},\n\tintersectsToleranceSquare: function (p0, p1) {\n\t\tvar intersectsLeft = false;\n\t\tvar intersectsBottom = false;\n\t\tthis._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);\n\t\tif (this._li.isProper()) return true;\n\t\tthis._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);\n\t\tif (this._li.isProper()) return true;\n\t\tif (this._li.hasIntersection()) intersectsLeft = true;\n\t\tthis._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);\n\t\tif (this._li.isProper()) return true;\n\t\tif (this._li.hasIntersection()) intersectsBottom = true;\n\t\tthis._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);\n\t\tif (this._li.isProper()) return true;\n\t\tif (intersectsLeft && intersectsBottom) return true;\n\t\tif (p0.equals(this._pt)) return true;\n\t\tif (p1.equals(this._pt)) return true;\n\t\treturn false;\n\t},\n\taddSnappedNode: function (segStr, segIndex) {\n\t\tvar p0 = segStr.getCoordinate(segIndex);\n\t\tvar p1 = segStr.getCoordinate(segIndex + 1);\n\t\tif (this.intersects(p0, p1)) {\n\t\t\tsegStr.addIntersection(this.getCoordinate(), segIndex);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn HotPixel;\n\t}\n});\nHotPixel.SAFE_ENV_EXPANSION_FACTOR = 0.75;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/noding/snapround/HotPixel.js\n// module id = 205\n// module chunks = 0","import MonotoneChainSelectAction from '../../index/chain/MonotoneChainSelectAction';\nimport MonotoneChain from '../../index/chain/MonotoneChain';\nimport ItemVisitor from '../../index/ItemVisitor';\nimport extend from '../../../../../extend';\nimport inherits from '../../../../../inherits';\nexport default function MCIndexPointSnapper() {\n\tthis._index = null;\n\tlet index = arguments[0];\n\tthis._index = index;\n}\nextend(MCIndexPointSnapper.prototype, {\n\tsnap: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet hotPixel = arguments[0];\n\t\t\treturn this.snap(hotPixel, null, -1);\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet hotPixel = arguments[0], parentEdge = arguments[1], hotPixelVertexIndex = arguments[2];\n\t\t\tvar pixelEnv = hotPixel.getSafeEnvelope();\n\t\t\tvar hotPixelSnapAction = new HotPixelSnapAction(hotPixel, parentEdge, hotPixelVertexIndex);\n\t\t\tthis._index.query(pixelEnv, {\n\t\t\t\tinterfaces_: function () {\n\t\t\t\t\treturn [ItemVisitor];\n\t\t\t\t},\n\t\t\t\tvisitItem: function (item) {\n\t\t\t\t\tvar testChain = item;\n\t\t\t\t\ttestChain.select(pixelEnv, hotPixelSnapAction);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn hotPixelSnapAction.isNodeAdded();\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn MCIndexPointSnapper;\n\t}\n});\nfunction HotPixelSnapAction() {\n\tMonotoneChainSelectAction.apply(this);\n\tthis._hotPixel = null;\n\tthis._parentEdge = null;\n\tthis._hotPixelVertexIndex = null;\n\tthis._isNodeAdded = false;\n\tlet hotPixel = arguments[0], parentEdge = arguments[1], hotPixelVertexIndex = arguments[2];\n\tthis._hotPixel = hotPixel;\n\tthis._parentEdge = parentEdge;\n\tthis._hotPixelVertexIndex = hotPixelVertexIndex;\n}\ninherits(HotPixelSnapAction, MonotoneChainSelectAction);\nextend(HotPixelSnapAction.prototype, {\n\tisNodeAdded: function () {\n\t\treturn this._isNodeAdded;\n\t},\n\tselect: function () {\n\t\tif (arguments.length === 2 && (Number.isInteger(arguments[1]) && arguments[0] instanceof MonotoneChain)) {\n\t\t\tlet mc = arguments[0], startIndex = arguments[1];\n\t\t\tvar ss = mc.getContext();\n\t\t\tif (this._parentEdge !== null) {\n\t\t\t\tif (ss === this._parentEdge && startIndex === this._hotPixelVertexIndex) return null;\n\t\t\t}\n\t\t\tthis._isNodeAdded = this._hotPixel.addSnappedNode(ss, startIndex);\n\t\t} else return MonotoneChainSelectAction.prototype.select.apply(this, arguments);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn HotPixelSnapAction;\n\t}\n});\nMCIndexPointSnapper.HotPixelSnapAction = HotPixelSnapAction;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/noding/snapround/MCIndexPointSnapper.js\n// module id = 206\n// module chunks = 0","import extend from '../../../../../extend';\nimport LineSegment from '../../geom/LineSegment';\nexport default function MonotoneChainSelectAction() {\n\tthis.selectedSegment = new LineSegment();\n}\nextend(MonotoneChainSelectAction.prototype, {\n\tselect: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet seg = arguments[0];\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet mc = arguments[0], startIndex = arguments[1];\n\t\t\tmc.getLineSegment(startIndex, this.selectedSegment);\n\t\t\tthis.select(this.selectedSegment);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn MonotoneChainSelectAction;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/index/chain/MonotoneChainSelectAction.js\n// module id = 207\n// module chunks = 0","import extend from '../../../../extend';\nimport SegmentIntersector from './SegmentIntersector';\nimport ArrayList from '../../../../java/util/ArrayList';\nexport default function InteriorIntersectionFinderAdder() {\n\tthis._li = null;\n\tthis._interiorIntersections = null;\n\tlet li = arguments[0];\n\tthis._li = li;\n\tthis._interiorIntersections = new ArrayList();\n}\nextend(InteriorIntersectionFinderAdder.prototype, {\n\tprocessIntersections: function (e0, segIndex0, e1, segIndex1) {\n\t\tif (e0 === e1 && segIndex0 === segIndex1) return null;\n\t\tvar p00 = e0.getCoordinates()[segIndex0];\n\t\tvar p01 = e0.getCoordinates()[segIndex0 + 1];\n\t\tvar p10 = e1.getCoordinates()[segIndex1];\n\t\tvar p11 = e1.getCoordinates()[segIndex1 + 1];\n\t\tthis._li.computeIntersection(p00, p01, p10, p11);\n\t\tif (this._li.hasIntersection()) {\n\t\t\tif (this._li.isInteriorIntersection()) {\n\t\t\t\tfor (var intIndex = 0; intIndex < this._li.getIntersectionNum(); intIndex++) {\n\t\t\t\t\tthis._interiorIntersections.add(this._li.getIntersection(intIndex));\n\t\t\t\t}\n\t\t\t\te0.addIntersections(this._li, segIndex0, 0);\n\t\t\t\te1.addIntersections(this._li, segIndex1, 1);\n\t\t\t}\n\t\t}\n\t},\n\tisDone: function () {\n\t\treturn false;\n\t},\n\tgetInteriorIntersections: function () {\n\t\treturn this._interiorIntersections;\n\t},\n\tinterfaces_: function () {\n\t\treturn [SegmentIntersector];\n\t},\n\tgetClass: function () {\n\t\treturn InteriorIntersectionFinderAdder;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/noding/InteriorIntersectionFinderAdder.js\n// module id = 208\n// module chunks = 0","import OL3Parser from '../../node_modules/jsts/org/locationtech/jts/io/OL3Parser';\nimport UnionOp from '../../node_modules/jsts/org/locationtech/jts/operation/union/UnionOp';\nimport TopologyControl from './topology';\nimport unionSVG from '../../img/union.svg';\n\n/**\n * Control for creating a union of geometries.\n * @extends {ole.Control}\n * @alias ole.Union\n */\nclass Union extends TopologyControl {\n  /**\n   * @inheritdoc\n   * @param {Object} [options] Control options.\n   * @param {number} [options.hitTolerance] Select tolerance in pixels\n   *   (default is 10)\n   */\n  constructor(options) {\n    super(Object.assign({\n      title: 'Union',\n      className: 'ole-control-union',\n      image: unionSVG,\n    }, options));\n  }\n\n  /**\n   * Apply a union for given features.\n   * @param {Array.<ol.Feature>} features Features to union.\n   */\n  applyTopologyOperation(features) {\n    super.applyTopologyOperation(features);\n    const parser = new OL3Parser();\n\n    for (let i = 1; i < features.length; i += 1) {\n      const geom = parser.read(features[0].getGeometry());\n      const otherGeom = parser.read(features[i].getGeometry());\n      const unionGeom = UnionOp.union(geom, otherGeom);\n      features[0].setGeometry(parser.write(unionGeom));\n      features[i].setGeometry(null);\n    }\n  }\n}\n\nexport default Union;\n\n\n\n// WEBPACK FOOTER //\n// ./src/control/union.js","import SnapIfNeededOverlayOp from '../overlay/snap/SnapIfNeededOverlayOp';\nimport extend from '../../../../../extend';\nimport OverlayOp from '../overlay/OverlayOp';\nexport default function UnionOp() {}\nextend(UnionOp.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn UnionOp;\n\t}\n});\nUnionOp.union = function (g, other) {\n\tif (g.isEmpty() || other.isEmpty()) {\n\t\tif (g.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.UNION, g, other, g.getFactory());\n\t\tif (g.isEmpty()) return other.copy();\n\t\tif (other.isEmpty()) return g.copy();\n\t}\n\tg.checkNotGeometryCollection(g);\n\tg.checkNotGeometryCollection(other);\n\treturn SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.UNION);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/operation/union/UnionOp.js\n// module id = 210\n// module chunks = 0","import GeometrySnapper from './GeometrySnapper';\nimport extend from '../../../../../../extend';\nimport System from '../../../../../../java/lang/System';\nimport CommonBitsRemover from '../../../precision/CommonBitsRemover';\nimport OverlayOp from '../OverlayOp';\nexport default function SnapOverlayOp() {\n\tthis._geom = new Array(2).fill(null);\n\tthis._snapTolerance = null;\n\tthis._cbr = null;\n\tlet g1 = arguments[0], g2 = arguments[1];\n\tthis._geom[0] = g1;\n\tthis._geom[1] = g2;\n\tthis.computeSnapTolerance();\n}\nextend(SnapOverlayOp.prototype, {\n\tselfSnap: function (geom) {\n\t\tvar snapper0 = new GeometrySnapper(geom);\n\t\tvar snapGeom = snapper0.snapTo(geom, this._snapTolerance);\n\t\treturn snapGeom;\n\t},\n\tremoveCommonBits: function (geom) {\n\t\tthis._cbr = new CommonBitsRemover();\n\t\tthis._cbr.add(geom[0]);\n\t\tthis._cbr.add(geom[1]);\n\t\tvar remGeom = new Array(2).fill(null);\n\t\tremGeom[0] = this._cbr.removeCommonBits(geom[0].copy());\n\t\tremGeom[1] = this._cbr.removeCommonBits(geom[1].copy());\n\t\treturn remGeom;\n\t},\n\tprepareResult: function (geom) {\n\t\tthis._cbr.addCommonBits(geom);\n\t\treturn geom;\n\t},\n\tgetResultGeometry: function (opCode) {\n\t\tvar prepGeom = this.snap(this._geom);\n\t\tvar result = OverlayOp.overlayOp(prepGeom[0], prepGeom[1], opCode);\n\t\treturn this.prepareResult(result);\n\t},\n\tcheckValid: function (g) {\n\t\tif (!g.isValid()) {\n\t\t\tSystem.out.println(\"Snapped geometry is invalid\");\n\t\t}\n\t},\n\tcomputeSnapTolerance: function () {\n\t\tthis._snapTolerance = GeometrySnapper.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);\n\t},\n\tsnap: function (geom) {\n\t\tvar remGeom = this.removeCommonBits(geom);\n\t\tvar snapGeom = GeometrySnapper.snap(remGeom[0], remGeom[1], this._snapTolerance);\n\t\treturn snapGeom;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn SnapOverlayOp;\n\t}\n});\nSnapOverlayOp.overlayOp = function (g0, g1, opCode) {\n\tvar op = new SnapOverlayOp(g0, g1);\n\treturn op.getResultGeometry(opCode);\n};\nSnapOverlayOp.union = function (g0, g1) {\n\treturn SnapOverlayOp.overlayOp(g0, g1, OverlayOp.UNION);\n};\nSnapOverlayOp.intersection = function (g0, g1) {\n\treturn SnapOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION);\n};\nSnapOverlayOp.symDifference = function (g0, g1) {\n\treturn SnapOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE);\n};\nSnapOverlayOp.difference = function (g0, g1) {\n\treturn SnapOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/operation/overlay/snap/SnapOverlayOp.js\n// module id = 211\n// module chunks = 0","import TreeSet from '../../../../../../java/util/TreeSet';\nimport GeometryTransformer from '../../../geom/util/GeometryTransformer';\nimport hasInterface from '../../../../../../hasInterface';\nimport Double from '../../../../../../java/lang/Double';\nimport extend from '../../../../../../extend';\nimport LineStringSnapper from './LineStringSnapper';\nimport PrecisionModel from '../../../geom/PrecisionModel';\nimport Polygonal from '../../../geom/Polygonal';\nimport inherits from '../../../../../../inherits';\nexport default function GeometrySnapper() {\n\tthis._srcGeom = null;\n\tlet srcGeom = arguments[0];\n\tthis._srcGeom = srcGeom;\n}\nextend(GeometrySnapper.prototype, {\n\tsnapTo: function (snapGeom, snapTolerance) {\n\t\tvar snapPts = this.extractTargetCoordinates(snapGeom);\n\t\tvar snapTrans = new SnapTransformer(snapTolerance, snapPts);\n\t\treturn snapTrans.transform(this._srcGeom);\n\t},\n\tsnapToSelf: function (snapTolerance, cleanResult) {\n\t\tvar snapPts = this.extractTargetCoordinates(this._srcGeom);\n\t\tvar snapTrans = new SnapTransformer(snapTolerance, snapPts, true);\n\t\tvar snappedGeom = snapTrans.transform(this._srcGeom);\n\t\tvar result = snappedGeom;\n\t\tif (cleanResult && hasInterface(result, Polygonal)) {\n\t\t\tresult = snappedGeom.buffer(0);\n\t\t}\n\t\treturn result;\n\t},\n\tcomputeSnapTolerance: function (ringPts) {\n\t\tvar minSegLen = this.computeMinimumSegmentLength(ringPts);\n\t\tvar snapTol = minSegLen / 10;\n\t\treturn snapTol;\n\t},\n\textractTargetCoordinates: function (g) {\n\t\tvar ptSet = new TreeSet();\n\t\tvar pts = g.getCoordinates();\n\t\tfor (var i = 0; i < pts.length; i++) {\n\t\t\tptSet.add(pts[i]);\n\t\t}\n\t\treturn ptSet.toArray(new Array(0).fill(null));\n\t},\n\tcomputeMinimumSegmentLength: function (pts) {\n\t\tvar minSegLen = Double.MAX_VALUE;\n\t\tfor (var i = 0; i < pts.length - 1; i++) {\n\t\t\tvar segLen = pts[i].distance(pts[i + 1]);\n\t\t\tif (segLen < minSegLen) minSegLen = segLen;\n\t\t}\n\t\treturn minSegLen;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn GeometrySnapper;\n\t}\n});\nGeometrySnapper.snap = function (g0, g1, snapTolerance) {\n\tvar snapGeom = new Array(2).fill(null);\n\tvar snapper0 = new GeometrySnapper(g0);\n\tsnapGeom[0] = snapper0.snapTo(g1, snapTolerance);\n\tvar snapper1 = new GeometrySnapper(g1);\n\tsnapGeom[1] = snapper1.snapTo(snapGeom[0], snapTolerance);\n\treturn snapGeom;\n};\nGeometrySnapper.computeOverlaySnapTolerance = function () {\n\tif (arguments.length === 1) {\n\t\tlet g = arguments[0];\n\t\tvar snapTolerance = GeometrySnapper.computeSizeBasedSnapTolerance(g);\n\t\tvar pm = g.getPrecisionModel();\n\t\tif (pm.getType() === PrecisionModel.FIXED) {\n\t\t\tvar fixedSnapTol = 1 / pm.getScale() * 2 / 1.415;\n\t\t\tif (fixedSnapTol > snapTolerance) snapTolerance = fixedSnapTol;\n\t\t}\n\t\treturn snapTolerance;\n\t} else if (arguments.length === 2) {\n\t\tlet g0 = arguments[0], g1 = arguments[1];\n\t\treturn Math.min(GeometrySnapper.computeOverlaySnapTolerance(g0), GeometrySnapper.computeOverlaySnapTolerance(g1));\n\t}\n};\nGeometrySnapper.computeSizeBasedSnapTolerance = function (g) {\n\tvar env = g.getEnvelopeInternal();\n\tvar minDimension = Math.min(env.getHeight(), env.getWidth());\n\tvar snapTol = minDimension * GeometrySnapper.SNAP_PRECISION_FACTOR;\n\treturn snapTol;\n};\nGeometrySnapper.snapToSelf = function (geom, snapTolerance, cleanResult) {\n\tvar snapper0 = new GeometrySnapper(geom);\n\treturn snapper0.snapToSelf(snapTolerance, cleanResult);\n};\nGeometrySnapper.SNAP_PRECISION_FACTOR = 1e-9;\nfunction SnapTransformer() {\n\tGeometryTransformer.apply(this);\n\tthis._snapTolerance = null;\n\tthis._snapPts = null;\n\tthis._isSelfSnap = false;\n\tif (arguments.length === 2) {\n\t\tlet snapTolerance = arguments[0], snapPts = arguments[1];\n\t\tthis._snapTolerance = snapTolerance;\n\t\tthis._snapPts = snapPts;\n\t} else if (arguments.length === 3) {\n\t\tlet snapTolerance = arguments[0], snapPts = arguments[1], isSelfSnap = arguments[2];\n\t\tthis._snapTolerance = snapTolerance;\n\t\tthis._snapPts = snapPts;\n\t\tthis._isSelfSnap = isSelfSnap;\n\t}\n}\ninherits(SnapTransformer, GeometryTransformer);\nextend(SnapTransformer.prototype, {\n\tsnapLine: function (srcPts, snapPts) {\n\t\tvar snapper = new LineStringSnapper(srcPts, this._snapTolerance);\n\t\tsnapper.setAllowSnappingToSourceVertices(this._isSelfSnap);\n\t\treturn snapper.snapTo(snapPts);\n\t},\n\ttransformCoordinates: function (coords, parent) {\n\t\tvar srcPts = coords.toCoordinateArray();\n\t\tvar newPts = this.snapLine(srcPts, this._snapPts);\n\t\treturn this._factory.getCoordinateSequenceFactory().create(newPts);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn SnapTransformer;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/operation/overlay/snap/GeometrySnapper.js\n// module id = 212\n// module chunks = 0","import LineString from '../LineString';\nimport GeometryFactory from '../GeometryFactory';\nimport IllegalArgumentException from '../../../../../java/lang/IllegalArgumentException';\nimport Point from '../Point';\nimport Polygon from '../Polygon';\nimport MultiPoint from '../MultiPoint';\nimport LinearRing from '../LinearRing';\nimport extend from '../../../../../extend';\nimport MultiPolygon from '../MultiPolygon';\nimport GeometryCollection from '../GeometryCollection';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport MultiLineString from '../MultiLineString';\nexport default function GeometryTransformer() {\n\tthis._inputGeom = null;\n\tthis._factory = null;\n\tthis._pruneEmptyGeometry = true;\n\tthis._preserveGeometryCollectionType = true;\n\tthis._preserveCollections = false;\n\tthis._preserveType = false;\n}\nextend(GeometryTransformer.prototype, {\n\ttransformPoint: function (geom, parent) {\n\t\treturn this._factory.createPoint(this.transformCoordinates(geom.getCoordinateSequence(), geom));\n\t},\n\ttransformPolygon: function (geom, parent) {\n\t\tvar isAllValidLinearRings = true;\n\t\tvar shell = this.transformLinearRing(geom.getExteriorRing(), geom);\n\t\tif (shell === null || !(shell instanceof LinearRing) || shell.isEmpty()) isAllValidLinearRings = false;\n\t\tvar holes = new ArrayList();\n\t\tfor (var i = 0; i < geom.getNumInteriorRing(); i++) {\n\t\t\tvar hole = this.transformLinearRing(geom.getInteriorRingN(i), geom);\n\t\t\tif (hole === null || hole.isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(hole instanceof LinearRing)) isAllValidLinearRings = false;\n\t\t\tholes.add(hole);\n\t\t}\n\t\tif (isAllValidLinearRings) return this._factory.createPolygon(shell, holes.toArray([])); else {\n\t\t\tvar components = new ArrayList();\n\t\t\tif (shell !== null) components.add(shell);\n\t\t\tcomponents.addAll(holes);\n\t\t\treturn this._factory.buildGeometry(components);\n\t\t}\n\t},\n\tcreateCoordinateSequence: function (coords) {\n\t\treturn this._factory.getCoordinateSequenceFactory().create(coords);\n\t},\n\tgetInputGeometry: function () {\n\t\treturn this._inputGeom;\n\t},\n\ttransformMultiLineString: function (geom, parent) {\n\t\tvar transGeomList = new ArrayList();\n\t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n\t\t\tvar transformGeom = this.transformLineString(geom.getGeometryN(i), geom);\n\t\t\tif (transformGeom === null) continue;\n\t\t\tif (transformGeom.isEmpty()) continue;\n\t\t\ttransGeomList.add(transformGeom);\n\t\t}\n\t\treturn this._factory.buildGeometry(transGeomList);\n\t},\n\ttransformCoordinates: function (coords, parent) {\n\t\treturn this.copy(coords);\n\t},\n\ttransformLineString: function (geom, parent) {\n\t\treturn this._factory.createLineString(this.transformCoordinates(geom.getCoordinateSequence(), geom));\n\t},\n\ttransformMultiPoint: function (geom, parent) {\n\t\tvar transGeomList = new ArrayList();\n\t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n\t\t\tvar transformGeom = this.transformPoint(geom.getGeometryN(i), geom);\n\t\t\tif (transformGeom === null) continue;\n\t\t\tif (transformGeom.isEmpty()) continue;\n\t\t\ttransGeomList.add(transformGeom);\n\t\t}\n\t\treturn this._factory.buildGeometry(transGeomList);\n\t},\n\ttransformMultiPolygon: function (geom, parent) {\n\t\tvar transGeomList = new ArrayList();\n\t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n\t\t\tvar transformGeom = this.transformPolygon(geom.getGeometryN(i), geom);\n\t\t\tif (transformGeom === null) continue;\n\t\t\tif (transformGeom.isEmpty()) continue;\n\t\t\ttransGeomList.add(transformGeom);\n\t\t}\n\t\treturn this._factory.buildGeometry(transGeomList);\n\t},\n\tcopy: function (seq) {\n\t\treturn seq.copy();\n\t},\n\ttransformGeometryCollection: function (geom, parent) {\n\t\tvar transGeomList = new ArrayList();\n\t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n\t\t\tvar transformGeom = this.transform(geom.getGeometryN(i));\n\t\t\tif (transformGeom === null) continue;\n\t\t\tif (this._pruneEmptyGeometry && transformGeom.isEmpty()) continue;\n\t\t\ttransGeomList.add(transformGeom);\n\t\t}\n\t\tif (this._preserveGeometryCollectionType) return this._factory.createGeometryCollection(GeometryFactory.toGeometryArray(transGeomList));\n\t\treturn this._factory.buildGeometry(transGeomList);\n\t},\n\ttransform: function (inputGeom) {\n\t\tthis._inputGeom = inputGeom;\n\t\tthis._factory = inputGeom.getFactory();\n\t\tif (inputGeom instanceof Point) return this.transformPoint(inputGeom, null);\n\t\tif (inputGeom instanceof MultiPoint) return this.transformMultiPoint(inputGeom, null);\n\t\tif (inputGeom instanceof LinearRing) return this.transformLinearRing(inputGeom, null);\n\t\tif (inputGeom instanceof LineString) return this.transformLineString(inputGeom, null);\n\t\tif (inputGeom instanceof MultiLineString) return this.transformMultiLineString(inputGeom, null);\n\t\tif (inputGeom instanceof Polygon) return this.transformPolygon(inputGeom, null);\n\t\tif (inputGeom instanceof MultiPolygon) return this.transformMultiPolygon(inputGeom, null);\n\t\tif (inputGeom instanceof GeometryCollection) return this.transformGeometryCollection(inputGeom, null);\n\t\tthrow new IllegalArgumentException(\"Unknown Geometry subtype: \" + inputGeom.getClass().getName());\n\t},\n\ttransformLinearRing: function (geom, parent) {\n\t\tvar seq = this.transformCoordinates(geom.getCoordinateSequence(), geom);\n\t\tif (seq === null) return this._factory.createLinearRing(null);\n\t\tvar seqSize = seq.size();\n\t\tif (seqSize > 0 && seqSize < 4 && !this._preserveType) return this._factory.createLineString(seq);\n\t\treturn this._factory.createLinearRing(seq);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn GeometryTransformer;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/util/GeometryTransformer.js\n// module id = 213\n// module chunks = 0","import LineString from '../../../geom/LineString';\nimport CoordinateList from '../../../geom/CoordinateList';\nimport Coordinate from '../../../geom/Coordinate';\nimport Double from '../../../../../../java/lang/Double';\nimport extend from '../../../../../../extend';\nimport LineSegment from '../../../geom/LineSegment';\nexport default function LineStringSnapper() {\n\tthis._snapTolerance = 0.0;\n\tthis._srcPts = null;\n\tthis._seg = new LineSegment();\n\tthis._allowSnappingToSourceVertices = false;\n\tthis._isClosed = false;\n\tif (arguments[0] instanceof LineString && typeof arguments[1] === \"number\") {\n\t\tlet srcLine = arguments[0], snapTolerance = arguments[1];\n\t\tLineStringSnapper.call(this, srcLine.getCoordinates(), snapTolerance);\n\t} else if (arguments[0] instanceof Array && typeof arguments[1] === \"number\") {\n\t\tlet srcPts = arguments[0], snapTolerance = arguments[1];\n\t\tthis._srcPts = srcPts;\n\t\tthis._isClosed = LineStringSnapper.isClosed(srcPts);\n\t\tthis._snapTolerance = snapTolerance;\n\t}\n}\nextend(LineStringSnapper.prototype, {\n\tsnapVertices: function (srcCoords, snapPts) {\n\t\tvar end = this._isClosed ? srcCoords.size() - 1 : srcCoords.size();\n\t\tfor (var i = 0; i < end; i++) {\n\t\t\tvar srcPt = srcCoords.get(i);\n\t\t\tvar snapVert = this.findSnapForVertex(srcPt, snapPts);\n\t\t\tif (snapVert !== null) {\n\t\t\t\tsrcCoords.set(i, new Coordinate(snapVert));\n\t\t\t\tif (i === 0 && this._isClosed) srcCoords.set(srcCoords.size() - 1, new Coordinate(snapVert));\n\t\t\t}\n\t\t}\n\t},\n\tfindSnapForVertex: function (pt, snapPts) {\n\t\tfor (var i = 0; i < snapPts.length; i++) {\n\t\t\tif (pt.equals2D(snapPts[i])) return null;\n\t\t\tif (pt.distance(snapPts[i]) < this._snapTolerance) return snapPts[i];\n\t\t}\n\t\treturn null;\n\t},\n\tsnapTo: function (snapPts) {\n\t\tvar coordList = new CoordinateList(this._srcPts);\n\t\tthis.snapVertices(coordList, snapPts);\n\t\tthis.snapSegments(coordList, snapPts);\n\t\tvar newPts = coordList.toCoordinateArray();\n\t\treturn newPts;\n\t},\n\tsnapSegments: function (srcCoords, snapPts) {\n\t\tif (snapPts.length === 0) return null;\n\t\tvar distinctPtCount = snapPts.length;\n\t\tif (snapPts[0].equals2D(snapPts[snapPts.length - 1])) distinctPtCount = snapPts.length - 1;\n\t\tfor (var i = 0; i < distinctPtCount; i++) {\n\t\t\tvar snapPt = snapPts[i];\n\t\t\tvar index = this.findSegmentIndexToSnap(snapPt, srcCoords);\n\t\t\tif (index >= 0) {\n\t\t\t\tsrcCoords.add(index + 1, new Coordinate(snapPt), false);\n\t\t\t}\n\t\t}\n\t},\n\tfindSegmentIndexToSnap: function (snapPt, srcCoords) {\n\t\tvar minDist = Double.MAX_VALUE;\n\t\tvar snapIndex = -1;\n\t\tfor (var i = 0; i < srcCoords.size() - 1; i++) {\n\t\t\tthis._seg.p0 = srcCoords.get(i);\n\t\t\tthis._seg.p1 = srcCoords.get(i + 1);\n\t\t\tif (this._seg.p0.equals2D(snapPt) || this._seg.p1.equals2D(snapPt)) {\n\t\t\t\tif (this._allowSnappingToSourceVertices) continue; else return -1;\n\t\t\t}\n\t\t\tvar dist = this._seg.distance(snapPt);\n\t\t\tif (dist < this._snapTolerance && dist < minDist) {\n\t\t\t\tminDist = dist;\n\t\t\t\tsnapIndex = i;\n\t\t\t}\n\t\t}\n\t\treturn snapIndex;\n\t},\n\tsetAllowSnappingToSourceVertices: function (allowSnappingToSourceVertices) {\n\t\tthis._allowSnappingToSourceVertices = allowSnappingToSourceVertices;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn LineStringSnapper;\n\t}\n});\nLineStringSnapper.isClosed = function (pts) {\n\tif (pts.length <= 1) return false;\n\treturn pts[0].equals2D(pts[pts.length - 1]);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/operation/overlay/snap/LineStringSnapper.js\n// module id = 214\n// module chunks = 0","import CommonBits from './CommonBits';\nimport CoordinateFilter from '../geom/CoordinateFilter';\nimport Coordinate from '../geom/Coordinate';\nimport extend from '../../../../extend';\nimport CoordinateSequenceFilter from '../geom/CoordinateSequenceFilter';\nexport default function CommonBitsRemover() {\n\tthis._commonCoord = null;\n\tthis._ccFilter = new CommonCoordinateFilter();\n}\nextend(CommonBitsRemover.prototype, {\n\taddCommonBits: function (geom) {\n\t\tvar trans = new Translater(this._commonCoord);\n\t\tgeom.apply(trans);\n\t\tgeom.geometryChanged();\n\t},\n\tremoveCommonBits: function (geom) {\n\t\tif (this._commonCoord.x === 0.0 && this._commonCoord.y === 0.0) return geom;\n\t\tvar invCoord = new Coordinate(this._commonCoord);\n\t\tinvCoord.x = -invCoord.x;\n\t\tinvCoord.y = -invCoord.y;\n\t\tvar trans = new Translater(invCoord);\n\t\tgeom.apply(trans);\n\t\tgeom.geometryChanged();\n\t\treturn geom;\n\t},\n\tgetCommonCoordinate: function () {\n\t\treturn this._commonCoord;\n\t},\n\tadd: function (geom) {\n\t\tgeom.apply(this._ccFilter);\n\t\tthis._commonCoord = this._ccFilter.getCommonCoordinate();\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn CommonBitsRemover;\n\t}\n});\nfunction CommonCoordinateFilter() {\n\tthis._commonBitsX = new CommonBits();\n\tthis._commonBitsY = new CommonBits();\n}\nextend(CommonCoordinateFilter.prototype, {\n\tfilter: function (coord) {\n\t\tthis._commonBitsX.add(coord.x);\n\t\tthis._commonBitsY.add(coord.y);\n\t},\n\tgetCommonCoordinate: function () {\n\t\treturn new Coordinate(this._commonBitsX.getCommon(), this._commonBitsY.getCommon());\n\t},\n\tinterfaces_: function () {\n\t\treturn [CoordinateFilter];\n\t},\n\tgetClass: function () {\n\t\treturn CommonCoordinateFilter;\n\t}\n});\nfunction Translater() {\n\tthis.trans = null;\n\tlet trans = arguments[0];\n\tthis.trans = trans;\n}\nextend(Translater.prototype, {\n\tfilter: function (seq, i) {\n\t\tvar xp = seq.getOrdinate(i, 0) + this.trans.x;\n\t\tvar yp = seq.getOrdinate(i, 1) + this.trans.y;\n\t\tseq.setOrdinate(i, 0, xp);\n\t\tseq.setOrdinate(i, 1, yp);\n\t},\n\tisDone: function () {\n\t\treturn false;\n\t},\n\tisGeometryChanged: function () {\n\t\treturn true;\n\t},\n\tinterfaces_: function () {\n\t\treturn [CoordinateSequenceFilter];\n\t},\n\tgetClass: function () {\n\t\treturn Translater;\n\t}\n});\nCommonBitsRemover.CommonCoordinateFilter = CommonCoordinateFilter;\nCommonBitsRemover.Translater = Translater;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/precision/CommonBitsRemover.js\n// module id = 215\n// module chunks = 0","import Double from '../../../../java/lang/Double';\nimport Long from '../../../../java/lang/Long';\nimport extend from '../../../../extend';\nexport default function CommonBits() {\n\tthis._isFirst = true;\n\tthis._commonMantissaBitsCount = 53;\n\tthis._commonBits = new Long();\n\tthis._commonSignExp = null;\n}\nextend(CommonBits.prototype, {\n\tgetCommon: function () {\n\t\treturn Double.longBitsToDouble(this._commonBits);\n\t},\n\tadd: function (num) {\n\t\tvar numBits = Double.doubleToLongBits(num);\n\t\tif (this._isFirst) {\n\t\t\tthis._commonBits = numBits;\n\t\t\tthis._commonSignExp = CommonBits.signExpBits(this._commonBits);\n\t\t\tthis._isFirst = false;\n\t\t\treturn null;\n\t\t}\n\t\tvar numSignExp = CommonBits.signExpBits(numBits);\n\t\tif (numSignExp !== this._commonSignExp) {\n\t\t\tthis._commonBits.high = 0 | 0;\n\t\t\tthis._commonBits.low = 0 | 0;\n\t\t\treturn null;\n\t\t}\n\t\tthis._commonMantissaBitsCount = CommonBits.numCommonMostSigMantissaBits(this._commonBits, numBits);\n\t\tthis._commonBits = CommonBits.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));\n\t},\n\ttoString: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet bits = arguments[0];\n\t\t\tvar x = Double.longBitsToDouble(bits);\n\t\t\tvar numStr = Long.toBinaryString(bits);\n\t\t\tvar padStr = \"0000000000000000000000000000000000000000000000000000000000000000\" + numStr;\n\t\t\tvar bitStr = padStr.substring(padStr.length - 64);\n\t\t\tvar str = bitStr.substring(0, 1) + \"  \" + bitStr.substring(1, 12) + \"(exp) \" + bitStr.substring(12) + \" [ \" + x + \" ]\";\n\t\t\treturn str;\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn CommonBits;\n\t}\n});\nCommonBits.getBit = function (bits, i) {\n\tvar mask = (1 << (i % 32));\n\tif (i < 32) {\n\t\treturn (bits.low & mask) != 0 ? 1 : 0;\n\t}\n\treturn (bits.high & mask) != 0 ? 1 : 0;\n};\nCommonBits.signExpBits = function (num) {\n\treturn num.high >>> 20;\n};\nCommonBits.zeroLowerBits = function (bits, nBits) {\n\tvar prop = 'low';\n\tif (nBits > 32) {\n\t\tbits.low = 0 | 0;\n\t\tnBits %= 32;\n\t\tprop = 'high';\n\t}\n\tif (nBits > 0) {\n\t\tvar mask = (nBits < 32) ? (~((1 << nBits) - 1)) : 0;\n\t\tbits[prop] &= mask;\n\t}\n\treturn bits;\n};\nCommonBits.numCommonMostSigMantissaBits = function (num1, num2) {\n\tvar count = 0;\n\tfor (var i = 52; i >= 0; i--) {\n\t\tif (CommonBits.getBit(num1, i) !== CommonBits.getBit(num2, i)) return count;\n\t\tcount++;\n\t}\n\treturn 52;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/precision/CommonBits.js\n// module id = 216\n// module chunks = 0","import BasicSegmentString from '../noding/BasicSegmentString';\nimport extend from '../../../../extend';\nimport FastNodingValidator from '../noding/FastNodingValidator';\nimport ArrayList from '../../../../java/util/ArrayList';\nexport default function EdgeNodingValidator() {\n\tthis._nv = null;\n\tlet edges = arguments[0];\n\tthis._nv = new FastNodingValidator(EdgeNodingValidator.toSegmentStrings(edges));\n}\nextend(EdgeNodingValidator.prototype, {\n\tcheckValid: function () {\n\t\tthis._nv.checkValid();\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn EdgeNodingValidator;\n\t}\n});\nEdgeNodingValidator.toSegmentStrings = function (edges) {\n\tvar segStrings = new ArrayList();\n\tfor (var i = edges.iterator(); i.hasNext(); ) {\n\t\tvar e = i.next();\n\t\tsegStrings.add(new BasicSegmentString(e.getCoordinates(), e));\n\t}\n\treturn segStrings;\n};\nEdgeNodingValidator.checkValid = function (edges) {\n\tvar validator = new EdgeNodingValidator(edges);\n\tvalidator.checkValid();\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeNodingValidator.js\n// module id = 217\n// module chunks = 0","import WKTWriter from '../io/WKTWriter';\nimport CoordinateArraySequence from '../geom/impl/CoordinateArraySequence';\nimport Octant from './Octant';\nimport extend from '../../../../extend';\nimport SegmentString from './SegmentString';\nexport default function BasicSegmentString() {\n\tthis._pts = null;\n\tthis._data = null;\n\tlet pts = arguments[0], data = arguments[1];\n\tthis._pts = pts;\n\tthis._data = data;\n}\nextend(BasicSegmentString.prototype, {\n\tgetCoordinates: function () {\n\t\treturn this._pts;\n\t},\n\tsize: function () {\n\t\treturn this._pts.length;\n\t},\n\tgetCoordinate: function (i) {\n\t\treturn this._pts[i];\n\t},\n\tisClosed: function () {\n\t\treturn this._pts[0].equals(this._pts[this._pts.length - 1]);\n\t},\n\tgetSegmentOctant: function (index) {\n\t\tif (index === this._pts.length - 1) return -1;\n\t\treturn Octant.octant(this.getCoordinate(index), this.getCoordinate(index + 1));\n\t},\n\tsetData: function (data) {\n\t\tthis._data = data;\n\t},\n\tgetData: function () {\n\t\treturn this._data;\n\t},\n\ttoString: function () {\n\t\treturn WKTWriter.toLineString(new CoordinateArraySequence(this._pts));\n\t},\n\tinterfaces_: function () {\n\t\treturn [SegmentString];\n\t},\n\tgetClass: function () {\n\t\treturn BasicSegmentString;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/noding/BasicSegmentString.js\n// module id = 218\n// module chunks = 0","import WKTWriter from '../io/WKTWriter';\nimport MCIndexNoder from './MCIndexNoder';\nimport TopologyException from '../geom/TopologyException';\nimport extend from '../../../../extend';\nimport RobustLineIntersector from '../algorithm/RobustLineIntersector';\nimport InteriorIntersectionFinder from './InteriorIntersectionFinder';\nexport default function FastNodingValidator() {\n\tthis._li = new RobustLineIntersector();\n\tthis._segStrings = null;\n\tthis._findAllIntersections = false;\n\tthis._segInt = null;\n\tthis._isValid = true;\n\tlet segStrings = arguments[0];\n\tthis._segStrings = segStrings;\n}\nextend(FastNodingValidator.prototype, {\n\texecute: function () {\n\t\tif (this._segInt !== null) return null;\n\t\tthis.checkInteriorIntersections();\n\t},\n\tgetIntersections: function () {\n\t\treturn this._segInt.getIntersections();\n\t},\n\tisValid: function () {\n\t\tthis.execute();\n\t\treturn this._isValid;\n\t},\n\tsetFindAllIntersections: function (findAllIntersections) {\n\t\tthis._findAllIntersections = findAllIntersections;\n\t},\n\tcheckInteriorIntersections: function () {\n\t\tthis._isValid = true;\n\t\tthis._segInt = new InteriorIntersectionFinder(this._li);\n\t\tthis._segInt.setFindAllIntersections(this._findAllIntersections);\n\t\tvar noder = new MCIndexNoder();\n\t\tnoder.setSegmentIntersector(this._segInt);\n\t\tnoder.computeNodes(this._segStrings);\n\t\tif (this._segInt.hasIntersection()) {\n\t\t\tthis._isValid = false;\n\t\t\treturn null;\n\t\t}\n\t},\n\tcheckValid: function () {\n\t\tthis.execute();\n\t\tif (!this._isValid) throw new TopologyException(this.getErrorMessage(), this._segInt.getInteriorIntersection());\n\t},\n\tgetErrorMessage: function () {\n\t\tif (this._isValid) return \"no intersections found\";\n\t\tvar intSegs = this._segInt.getIntersectionSegments();\n\t\treturn \"found non-noded intersection between \" + WKTWriter.toLineString(intSegs[0], intSegs[1]) + \" and \" + WKTWriter.toLineString(intSegs[2], intSegs[3]);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn FastNodingValidator;\n\t}\n});\nFastNodingValidator.computeIntersections = function (segStrings) {\n\tvar nv = new FastNodingValidator(segStrings);\n\tnv.setFindAllIntersections(true);\n\tnv.isValid();\n\treturn nv.getIntersections();\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/noding/FastNodingValidator.js\n// module id = 219\n// module chunks = 0","import extend from '../../../../extend';\nimport SegmentIntersector from './SegmentIntersector';\nimport ArrayList from '../../../../java/util/ArrayList';\nexport default function InteriorIntersectionFinder() {\n\tthis._findAllIntersections = false;\n\tthis._isCheckEndSegmentsOnly = false;\n\tthis._li = null;\n\tthis._interiorIntersection = null;\n\tthis._intSegments = null;\n\tthis._intersections = new ArrayList();\n\tthis._intersectionCount = 0;\n\tthis._keepIntersections = true;\n\tlet li = arguments[0];\n\tthis._li = li;\n\tthis._interiorIntersection = null;\n}\nextend(InteriorIntersectionFinder.prototype, {\n\tgetInteriorIntersection: function () {\n\t\treturn this._interiorIntersection;\n\t},\n\tsetCheckEndSegmentsOnly: function (isCheckEndSegmentsOnly) {\n\t\tthis._isCheckEndSegmentsOnly = isCheckEndSegmentsOnly;\n\t},\n\tgetIntersectionSegments: function () {\n\t\treturn this._intSegments;\n\t},\n\tcount: function () {\n\t\treturn this._intersectionCount;\n\t},\n\tgetIntersections: function () {\n\t\treturn this._intersections;\n\t},\n\tsetFindAllIntersections: function (findAllIntersections) {\n\t\tthis._findAllIntersections = findAllIntersections;\n\t},\n\tsetKeepIntersections: function (keepIntersections) {\n\t\tthis._keepIntersections = keepIntersections;\n\t},\n\tprocessIntersections: function (e0, segIndex0, e1, segIndex1) {\n\t\tif (!this._findAllIntersections && this.hasIntersection()) return null;\n\t\tif (e0 === e1 && segIndex0 === segIndex1) return null;\n\t\tif (this._isCheckEndSegmentsOnly) {\n\t\t\tvar isEndSegPresent = this.isEndSegment(e0, segIndex0) || this.isEndSegment(e1, segIndex1);\n\t\t\tif (!isEndSegPresent) return null;\n\t\t}\n\t\tvar p00 = e0.getCoordinates()[segIndex0];\n\t\tvar p01 = e0.getCoordinates()[segIndex0 + 1];\n\t\tvar p10 = e1.getCoordinates()[segIndex1];\n\t\tvar p11 = e1.getCoordinates()[segIndex1 + 1];\n\t\tthis._li.computeIntersection(p00, p01, p10, p11);\n\t\tif (this._li.hasIntersection()) {\n\t\t\tif (this._li.isInteriorIntersection()) {\n\t\t\t\tthis._intSegments = new Array(4).fill(null);\n\t\t\t\tthis._intSegments[0] = p00;\n\t\t\t\tthis._intSegments[1] = p01;\n\t\t\t\tthis._intSegments[2] = p10;\n\t\t\t\tthis._intSegments[3] = p11;\n\t\t\t\tthis._interiorIntersection = this._li.getIntersection(0);\n\t\t\t\tif (this._keepIntersections) this._intersections.add(this._interiorIntersection);\n\t\t\t\tthis._intersectionCount++;\n\t\t\t}\n\t\t}\n\t},\n\tisEndSegment: function (segStr, index) {\n\t\tif (index === 0) return true;\n\t\tif (index >= segStr.size() - 2) return true;\n\t\treturn false;\n\t},\n\thasIntersection: function () {\n\t\treturn this._interiorIntersection !== null;\n\t},\n\tisDone: function () {\n\t\tif (this._findAllIntersections) return false;\n\t\treturn this._interiorIntersection !== null;\n\t},\n\tinterfaces_: function () {\n\t\treturn [SegmentIntersector];\n\t},\n\tgetClass: function () {\n\t\treturn InteriorIntersectionFinder;\n\t}\n});\nInteriorIntersectionFinder.createAllIntersectionsFinder = function (li) {\n\tvar finder = new InteriorIntersectionFinder(li);\n\tfinder.setFindAllIntersections(true);\n\treturn finder;\n};\nInteriorIntersectionFinder.createAnyIntersectionFinder = function (li) {\n\treturn new InteriorIntersectionFinder(li);\n};\nInteriorIntersectionFinder.createIntersectionCounter = function (li) {\n\tvar finder = new InteriorIntersectionFinder(li);\n\tfinder.setFindAllIntersections(true);\n\tfinder.setKeepIntersections(false);\n\treturn finder;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/noding/InteriorIntersectionFinder.js\n// module id = 220\n// module chunks = 0","import GeometryFactory from '../GeometryFactory';\nimport extend from '../../../../../extend';\nimport ArrayList from '../../../../../java/util/ArrayList';\nexport default function GeometryCollectionMapper() {\n\tthis._mapOp = null;\n\tlet mapOp = arguments[0];\n\tthis._mapOp = mapOp;\n}\nextend(GeometryCollectionMapper.prototype, {\n\tmap: function (gc) {\n\t\tvar mapped = new ArrayList();\n\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n\t\t\tvar g = this._mapOp.map(gc.getGeometryN(i));\n\t\t\tif (!g.isEmpty()) mapped.add(g);\n\t\t}\n\t\treturn gc.getFactory().createGeometryCollection(GeometryFactory.toGeometryArray(mapped));\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn GeometryCollectionMapper;\n\t}\n});\nGeometryCollectionMapper.map = function (gc, op) {\n\tvar mapper = new GeometryCollectionMapper(op);\n\treturn mapper.map(gc);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/util/GeometryCollectionMapper.js\n// module id = 221\n// module chunks = 0","import extend from '../../../../../extend';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Assert from '../../util/Assert';\nimport OverlayOp from './OverlayOp';\nexport default function LineBuilder() {\n\tthis._op = null;\n\tthis._geometryFactory = null;\n\tthis._ptLocator = null;\n\tthis._lineEdgesList = new ArrayList();\n\tthis._resultLineList = new ArrayList();\n\tlet op = arguments[0], geometryFactory = arguments[1], ptLocator = arguments[2];\n\tthis._op = op;\n\tthis._geometryFactory = geometryFactory;\n\tthis._ptLocator = ptLocator;\n}\nextend(LineBuilder.prototype, {\n\tcollectLines: function (opCode) {\n\t\tfor (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tthis.collectLineEdge(de, opCode, this._lineEdgesList);\n\t\t\tthis.collectBoundaryTouchEdge(de, opCode, this._lineEdgesList);\n\t\t}\n\t},\n\tlabelIsolatedLine: function (e, targetIndex) {\n\t\tvar loc = this._ptLocator.locate(e.getCoordinate(), this._op.getArgGeometry(targetIndex));\n\t\te.getLabel().setLocation(targetIndex, loc);\n\t},\n\tbuild: function (opCode) {\n\t\tthis.findCoveredLineEdges();\n\t\tthis.collectLines(opCode);\n\t\tthis.buildLines(opCode);\n\t\treturn this._resultLineList;\n\t},\n\tcollectLineEdge: function (de, opCode, edges) {\n\t\tvar label = de.getLabel();\n\t\tvar e = de.getEdge();\n\t\tif (de.isLineEdge()) {\n\t\t\tif (!de.isVisited() && OverlayOp.isResultOfOp(label, opCode) && !e.isCovered()) {\n\t\t\t\tedges.add(e);\n\t\t\t\tde.setVisitedEdge(true);\n\t\t\t}\n\t\t}\n\t},\n\tfindCoveredLineEdges: function () {\n\t\tfor (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext(); ) {\n\t\t\tvar node = nodeit.next();\n\t\t\tnode.getEdges().findCoveredLineEdges();\n\t\t}\n\t\tfor (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tvar e = de.getEdge();\n\t\t\tif (de.isLineEdge() && !e.isCoveredSet()) {\n\t\t\t\tvar isCovered = this._op.isCoveredByA(de.getCoordinate());\n\t\t\t\te.setCovered(isCovered);\n\t\t\t}\n\t\t}\n\t},\n\tlabelIsolatedLines: function (edgesList) {\n\t\tfor (var it = edgesList.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tif (e.isIsolated()) {\n\t\t\t\tif (label.isNull(0)) this.labelIsolatedLine(e, 0); else this.labelIsolatedLine(e, 1);\n\t\t\t}\n\t\t}\n\t},\n\tbuildLines: function (opCode) {\n\t\tfor (var it = this._lineEdgesList.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tvar line = this._geometryFactory.createLineString(e.getCoordinates());\n\t\t\tthis._resultLineList.add(line);\n\t\t\te.setInResult(true);\n\t\t}\n\t},\n\tcollectBoundaryTouchEdge: function (de, opCode, edges) {\n\t\tvar label = de.getLabel();\n\t\tif (de.isLineEdge()) return null;\n\t\tif (de.isVisited()) return null;\n\t\tif (de.isInteriorAreaEdge()) return null;\n\t\tif (de.getEdge().isInResult()) return null;\n\t\tAssert.isTrue(!(de.isInResult() || de.getSym().isInResult()) || !de.getEdge().isInResult());\n\t\tif (OverlayOp.isResultOfOp(label, opCode) && opCode === OverlayOp.INTERSECTION) {\n\t\t\tedges.add(de.getEdge());\n\t\t\tde.setVisitedEdge(true);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn LineBuilder;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/operation/overlay/LineBuilder.js\n// module id = 222\n// module chunks = 0","import extend from '../../../../../extend';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport OverlayOp from './OverlayOp';\nexport default function PointBuilder() {\n\tthis._op = null;\n\tthis._geometryFactory = null;\n\tthis._resultPointList = new ArrayList();\n\tlet op = arguments[0], geometryFactory = arguments[1], ptLocator = arguments[2];\n\tthis._op = op;\n\tthis._geometryFactory = geometryFactory;\n}\nextend(PointBuilder.prototype, {\n\tfilterCoveredNodeToPoint: function (n) {\n\t\tvar coord = n.getCoordinate();\n\t\tif (!this._op.isCoveredByLA(coord)) {\n\t\t\tvar pt = this._geometryFactory.createPoint(coord);\n\t\t\tthis._resultPointList.add(pt);\n\t\t}\n\t},\n\textractNonCoveredResultNodes: function (opCode) {\n\t\tfor (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext(); ) {\n\t\t\tvar n = nodeit.next();\n\t\t\tif (n.isInResult()) continue;\n\t\t\tif (n.isIncidentEdgeInResult()) continue;\n\t\t\tif (n.getEdges().getDegree() === 0 || opCode === OverlayOp.INTERSECTION) {\n\t\t\t\tvar label = n.getLabel();\n\t\t\t\tif (OverlayOp.isResultOfOp(label, opCode)) {\n\t\t\t\t\tthis.filterCoveredNodeToPoint(n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tbuild: function (opCode) {\n\t\tthis.extractNonCoveredResultNodes(opCode);\n\t\treturn this._resultPointList;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn PointBuilder;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/operation/overlay/PointBuilder.js\n// module id = 223\n// module chunks = 0","import BoundaryNodeRule from '../algorithm/BoundaryNodeRule';\nimport extend from '../../../../extend';\nimport GeometryGraph from '../geomgraph/GeometryGraph';\nimport RobustLineIntersector from '../algorithm/RobustLineIntersector';\nexport default function GeometryGraphOperation() {\n\tthis._li = new RobustLineIntersector();\n\tthis._resultPrecisionModel = null;\n\tthis._arg = null;\n\tif (arguments.length === 1) {\n\t\tlet g0 = arguments[0];\n\t\tthis.setComputationPrecision(g0.getPrecisionModel());\n\t\tthis._arg = new Array(1).fill(null);\n\t\tthis._arg[0] = new GeometryGraph(0, g0);\n\t\t;\n\t} else if (arguments.length === 2) {\n\t\tlet g0 = arguments[0], g1 = arguments[1];\n\t\tGeometryGraphOperation.call(this, g0, g1, BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE);\n\t} else if (arguments.length === 3) {\n\t\tlet g0 = arguments[0], g1 = arguments[1], boundaryNodeRule = arguments[2];\n\t\tif (g0.getPrecisionModel().compareTo(g1.getPrecisionModel()) >= 0) this.setComputationPrecision(g0.getPrecisionModel()); else this.setComputationPrecision(g1.getPrecisionModel());\n\t\tthis._arg = new Array(2).fill(null);\n\t\tthis._arg[0] = new GeometryGraph(0, g0, boundaryNodeRule);\n\t\tthis._arg[1] = new GeometryGraph(1, g1, boundaryNodeRule);\n\t}\n}\nextend(GeometryGraphOperation.prototype, {\n\tgetArgGeometry: function (i) {\n\t\treturn this._arg[i].getGeometry();\n\t},\n\tsetComputationPrecision: function (pm) {\n\t\tthis._resultPrecisionModel = pm;\n\t\tthis._li.setPrecisionModel(this._resultPrecisionModel);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn GeometryGraphOperation;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/operation/GeometryGraphOperation.js\n// module id = 224\n// module chunks = 0","import PointLocator from '../algorithm/PointLocator';\nimport Location from '../geom/Location';\nimport LineString from '../geom/LineString';\nimport HashMap from '../../../../java/util/HashMap';\nimport Geometry from '../geom/Geometry';\nimport hasInterface from '../../../../hasInterface';\nimport Position from './Position';\nimport Coordinate from '../geom/Coordinate';\nimport Point from '../geom/Point';\nimport Polygon from '../geom/Polygon';\nimport MultiPoint from '../geom/MultiPoint';\nimport SimpleMCSweepLineIntersector from './index/SimpleMCSweepLineIntersector';\nimport LinearRing from '../geom/LinearRing';\nimport BoundaryNodeRule from '../algorithm/BoundaryNodeRule';\nimport extend from '../../../../extend';\nimport Orientation from '../algorithm/Orientation';\nimport SegmentIntersector from './index/SegmentIntersector';\nimport MultiPolygon from '../geom/MultiPolygon';\nimport Label from './Label';\nimport GeometryCollection from '../geom/GeometryCollection';\nimport CoordinateArrays from '../geom/CoordinateArrays';\nimport Polygonal from '../geom/Polygonal';\nimport IndexedPointInAreaLocator from '../algorithm/locate/IndexedPointInAreaLocator';\nimport Assert from '../util/Assert';\nimport Edge from './Edge';\nimport inherits from '../../../../inherits';\nimport MultiLineString from '../geom/MultiLineString';\nimport PlanarGraph from './PlanarGraph';\nexport default function GeometryGraph() {\n\tPlanarGraph.apply(this);\n\tthis._parentGeom = null;\n\tthis._lineEdgeMap = new HashMap();\n\tthis._boundaryNodeRule = null;\n\tthis._useBoundaryDeterminationRule = true;\n\tthis._argIndex = null;\n\tthis._boundaryNodes = null;\n\tthis._hasTooFewPoints = false;\n\tthis._invalidPoint = null;\n\tthis._areaPtLocator = null;\n\tthis._ptLocator = new PointLocator();\n\tif (arguments.length === 2) {\n\t\tlet argIndex = arguments[0], parentGeom = arguments[1];\n\t\tGeometryGraph.call(this, argIndex, parentGeom, BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE);\n\t} else if (arguments.length === 3) {\n\t\tlet argIndex = arguments[0], parentGeom = arguments[1], boundaryNodeRule = arguments[2];\n\t\tthis._argIndex = argIndex;\n\t\tthis._parentGeom = parentGeom;\n\t\tthis._boundaryNodeRule = boundaryNodeRule;\n\t\tif (parentGeom !== null) {\n\t\t\tthis.add(parentGeom);\n\t\t}\n\t}\n}\ninherits(GeometryGraph, PlanarGraph);\nextend(GeometryGraph.prototype, {\n\tinsertBoundaryPoint: function (argIndex, coord) {\n\t\tvar n = this._nodes.addNode(coord);\n\t\tvar lbl = n.getLabel();\n\t\tvar boundaryCount = 1;\n\t\tvar loc = Location.NONE;\n\t\tloc = lbl.getLocation(argIndex, Position.ON);\n\t\tif (loc === Location.BOUNDARY) boundaryCount++;\n\t\tvar newLoc = GeometryGraph.determineBoundary(this._boundaryNodeRule, boundaryCount);\n\t\tlbl.setLocation(argIndex, newLoc);\n\t},\n\tcomputeSelfNodes: function () {\n\t\tif (arguments.length === 2) {\n\t\t\tlet li = arguments[0], computeRingSelfNodes = arguments[1];\n\t\t\treturn this.computeSelfNodes(li, computeRingSelfNodes, false);\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet li = arguments[0], computeRingSelfNodes = arguments[1], isDoneIfProperInt = arguments[2];\n\t\t\tvar si = new SegmentIntersector(li, true, false);\n\t\t\tsi.setIsDoneIfProperInt(isDoneIfProperInt);\n\t\t\tvar esi = this.createEdgeSetIntersector();\n\t\t\tvar isRings = this._parentGeom instanceof LinearRing || this._parentGeom instanceof Polygon || this._parentGeom instanceof MultiPolygon;\n\t\t\tvar computeAllSegments = computeRingSelfNodes || !isRings;\n\t\t\tesi.computeIntersections(this._edges, si, computeAllSegments);\n\t\t\tthis.addSelfIntersectionNodes(this._argIndex);\n\t\t\treturn si;\n\t\t}\n\t},\n\tcomputeSplitEdges: function (edgelist) {\n\t\tfor (var i = this._edges.iterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\te.eiList.addSplitEdges(edgelist);\n\t\t}\n\t},\n\tcomputeEdgeIntersections: function (g, li, includeProper) {\n\t\tvar si = new SegmentIntersector(li, includeProper, true);\n\t\tsi.setBoundaryNodes(this.getBoundaryNodes(), g.getBoundaryNodes());\n\t\tvar esi = this.createEdgeSetIntersector();\n\t\tesi.computeIntersections(this._edges, g._edges, si);\n\t\treturn si;\n\t},\n\tgetGeometry: function () {\n\t\treturn this._parentGeom;\n\t},\n\tgetBoundaryNodeRule: function () {\n\t\treturn this._boundaryNodeRule;\n\t},\n\thasTooFewPoints: function () {\n\t\treturn this._hasTooFewPoints;\n\t},\n\taddPoint: function () {\n\t\tif (arguments[0] instanceof Point) {\n\t\t\tlet p = arguments[0];\n\t\t\tvar coord = p.getCoordinate();\n\t\t\tthis.insertPoint(this._argIndex, coord, Location.INTERIOR);\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet pt = arguments[0];\n\t\t\tthis.insertPoint(this._argIndex, pt, Location.INTERIOR);\n\t\t}\n\t},\n\taddPolygon: function (p) {\n\t\tthis.addPolygonRing(p.getExteriorRing(), Location.EXTERIOR, Location.INTERIOR);\n\t\tfor (var i = 0; i < p.getNumInteriorRing(); i++) {\n\t\t\tvar hole = p.getInteriorRingN(i);\n\t\t\tthis.addPolygonRing(hole, Location.INTERIOR, Location.EXTERIOR);\n\t\t}\n\t},\n\taddEdge: function (e) {\n\t\tthis.insertEdge(e);\n\t\tvar coord = e.getCoordinates();\n\t\tthis.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);\n\t\tthis.insertPoint(this._argIndex, coord[coord.length - 1], Location.BOUNDARY);\n\t},\n\taddLineString: function (line) {\n\t\tvar coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n\t\tif (coord.length < 2) {\n\t\t\tthis._hasTooFewPoints = true;\n\t\t\tthis._invalidPoint = coord[0];\n\t\t\treturn null;\n\t\t}\n\t\tvar e = new Edge(coord, new Label(this._argIndex, Location.INTERIOR));\n\t\tthis._lineEdgeMap.put(line, e);\n\t\tthis.insertEdge(e);\n\t\tAssert.isTrue(coord.length >= 2, \"found LineString with single point\");\n\t\tthis.insertBoundaryPoint(this._argIndex, coord[0]);\n\t\tthis.insertBoundaryPoint(this._argIndex, coord[coord.length - 1]);\n\t},\n\tgetInvalidPoint: function () {\n\t\treturn this._invalidPoint;\n\t},\n\tgetBoundaryPoints: function () {\n\t\tvar coll = this.getBoundaryNodes();\n\t\tvar pts = new Array(coll.size()).fill(null);\n\t\tvar i = 0;\n\t\tfor (var it = coll.iterator(); it.hasNext(); ) {\n\t\t\tvar node = it.next();\n\t\t\tpts[i++] = node.getCoordinate().copy();\n\t\t}\n\t\treturn pts;\n\t},\n\tgetBoundaryNodes: function () {\n\t\tif (this._boundaryNodes === null) this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex);\n\t\treturn this._boundaryNodes;\n\t},\n\taddSelfIntersectionNode: function (argIndex, coord, loc) {\n\t\tif (this.isBoundaryNode(argIndex, coord)) return null;\n\t\tif (loc === Location.BOUNDARY && this._useBoundaryDeterminationRule) this.insertBoundaryPoint(argIndex, coord); else this.insertPoint(argIndex, coord, loc);\n\t},\n\taddPolygonRing: function (lr, cwLeft, cwRight) {\n\t\tif (lr.isEmpty()) return null;\n\t\tvar coord = CoordinateArrays.removeRepeatedPoints(lr.getCoordinates());\n\t\tif (coord.length < 4) {\n\t\t\tthis._hasTooFewPoints = true;\n\t\t\tthis._invalidPoint = coord[0];\n\t\t\treturn null;\n\t\t}\n\t\tvar left = cwLeft;\n\t\tvar right = cwRight;\n\t\tif (Orientation.isCCW(coord)) {\n\t\t\tleft = cwRight;\n\t\t\tright = cwLeft;\n\t\t}\n\t\tvar e = new Edge(coord, new Label(this._argIndex, Location.BOUNDARY, left, right));\n\t\tthis._lineEdgeMap.put(lr, e);\n\t\tthis.insertEdge(e);\n\t\tthis.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);\n\t},\n\tinsertPoint: function (argIndex, coord, onLocation) {\n\t\tvar n = this._nodes.addNode(coord);\n\t\tvar lbl = n.getLabel();\n\t\tif (lbl === null) {\n\t\t\tn._label = new Label(argIndex, onLocation);\n\t\t} else lbl.setLocation(argIndex, onLocation);\n\t},\n\tcreateEdgeSetIntersector: function () {\n\t\treturn new SimpleMCSweepLineIntersector();\n\t},\n\taddSelfIntersectionNodes: function (argIndex) {\n\t\tfor (var i = this._edges.iterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\tvar eLoc = e.getLabel().getLocation(argIndex);\n\t\t\tfor (var eiIt = e.eiList.iterator(); eiIt.hasNext(); ) {\n\t\t\t\tvar ei = eiIt.next();\n\t\t\t\tthis.addSelfIntersectionNode(argIndex, ei.coord, eLoc);\n\t\t\t}\n\t\t}\n\t},\n\tadd: function () {\n\t\tif (arguments.length === 1 && arguments[0] instanceof Geometry) {\n\t\t\tlet g = arguments[0];\n\t\t\tif (g.isEmpty()) return null;\n\t\t\tif (g instanceof MultiPolygon) this._useBoundaryDeterminationRule = false;\n\t\t\tif (g instanceof Polygon) this.addPolygon(g); else if (g instanceof LineString) this.addLineString(g); else if (g instanceof Point) this.addPoint(g); else if (g instanceof MultiPoint) this.addCollection(g); else if (g instanceof MultiLineString) this.addCollection(g); else if (g instanceof MultiPolygon) this.addCollection(g); else if (g instanceof GeometryCollection) this.addCollection(g); else throw new UnsupportedOperationException(g.getClass().getName());\n\t\t} else return PlanarGraph.prototype.add.apply(this, arguments);\n\t},\n\taddCollection: function (gc) {\n\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n\t\t\tvar g = gc.getGeometryN(i);\n\t\t\tthis.add(g);\n\t\t}\n\t},\n\tlocate: function (pt) {\n\t\tif (hasInterface(this._parentGeom, Polygonal) && this._parentGeom.getNumGeometries() > 50) {\n\t\t\tif (this._areaPtLocator === null) {\n\t\t\t\tthis._areaPtLocator = new IndexedPointInAreaLocator(this._parentGeom);\n\t\t\t}\n\t\t\treturn this._areaPtLocator.locate(pt);\n\t\t}\n\t\treturn this._ptLocator.locate(pt, this._parentGeom);\n\t},\n\tfindEdge: function () {\n\t\tif (arguments.length === 1 && arguments[0] instanceof LineString) {\n\t\t\tlet line = arguments[0];\n\t\t\treturn this._lineEdgeMap.get(line);\n\t\t} else return PlanarGraph.prototype.findEdge.apply(this, arguments);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn GeometryGraph;\n\t}\n});\nGeometryGraph.determineBoundary = function (boundaryNodeRule, boundaryCount) {\n\treturn boundaryNodeRule.isInBoundary(boundaryCount) ? Location.BOUNDARY : Location.INTERIOR;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geomgraph/GeometryGraph.js\n// module id = 225\n// module chunks = 0","import hasInterface from '../../../../../hasInterface';\nimport MonotoneChain from './MonotoneChain';\nimport SweepLineEvent from './SweepLineEvent';\nimport EdgeSetIntersector from './EdgeSetIntersector';\nimport extend from '../../../../../extend';\nimport Collections from '../../../../../java/util/Collections';\nimport SegmentIntersector from './SegmentIntersector';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport inherits from '../../../../../inherits';\nimport List from '../../../../../java/util/List';\nexport default function SimpleMCSweepLineIntersector() {\n\tEdgeSetIntersector.apply(this);\n\tthis.events = new ArrayList();\n\tthis.nOverlaps = null;\n}\ninherits(SimpleMCSweepLineIntersector, EdgeSetIntersector);\nextend(SimpleMCSweepLineIntersector.prototype, {\n\tprepareEvents: function () {\n\t\tCollections.sort(this.events);\n\t\tfor (var i = 0; i < this.events.size(); i++) {\n\t\t\tvar ev = this.events.get(i);\n\t\t\tif (ev.isDelete()) {\n\t\t\t\tev.getInsertEvent().setDeleteEventIndex(i);\n\t\t\t}\n\t\t}\n\t},\n\tcomputeIntersections: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet si = arguments[0];\n\t\t\tthis.nOverlaps = 0;\n\t\t\tthis.prepareEvents();\n\t\t\tfor (var i = 0; i < this.events.size(); i++) {\n\t\t\t\tvar ev = this.events.get(i);\n\t\t\t\tif (ev.isInsert()) {\n\t\t\t\t\tthis.processOverlaps(i, ev.getDeleteEventIndex(), ev, si);\n\t\t\t\t}\n\t\t\t\tif (si.isDone()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tif (arguments[2] instanceof SegmentIntersector && (hasInterface(arguments[0], List) && hasInterface(arguments[1], List))) {\n\t\t\t\tlet edges0 = arguments[0], edges1 = arguments[1], si = arguments[2];\n\t\t\t\tthis.addEdges(edges0, edges0);\n\t\t\t\tthis.addEdges(edges1, edges1);\n\t\t\t\tthis.computeIntersections(si);\n\t\t\t} else if (typeof arguments[2] === \"boolean\" && (hasInterface(arguments[0], List) && arguments[1] instanceof SegmentIntersector)) {\n\t\t\t\tlet edges = arguments[0], si = arguments[1], testAllSegments = arguments[2];\n\t\t\t\tif (testAllSegments) this.addEdges(edges, null); else this.addEdges(edges);\n\t\t\t\tthis.computeIntersections(si);\n\t\t\t}\n\t\t}\n\t},\n\taddEdge: function (edge, edgeSet) {\n\t\tvar mce = edge.getMonotoneChainEdge();\n\t\tvar startIndex = mce.getStartIndexes();\n\t\tfor (var i = 0; i < startIndex.length - 1; i++) {\n\t\t\tvar mc = new MonotoneChain(mce, i);\n\t\t\tvar insertEvent = new SweepLineEvent(edgeSet, mce.getMinX(i), mc);\n\t\t\tthis.events.add(insertEvent);\n\t\t\tthis.events.add(new SweepLineEvent(mce.getMaxX(i), insertEvent));\n\t\t}\n\t},\n\tprocessOverlaps: function (start, end, ev0, si) {\n\t\tvar mc0 = ev0.getObject();\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar ev1 = this.events.get(i);\n\t\t\tif (ev1.isInsert()) {\n\t\t\t\tvar mc1 = ev1.getObject();\n\t\t\t\tif (!ev0.isSameLabel(ev1)) {\n\t\t\t\t\tmc0.computeIntersections(mc1, si);\n\t\t\t\t\tthis.nOverlaps++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\taddEdges: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet edges = arguments[0];\n\t\t\tfor (var i = edges.iterator(); i.hasNext(); ) {\n\t\t\t\tvar edge = i.next();\n\t\t\t\tthis.addEdge(edge, edge);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet edges = arguments[0], edgeSet = arguments[1];\n\t\t\tfor (var i = edges.iterator(); i.hasNext(); ) {\n\t\t\t\tvar edge = i.next();\n\t\t\t\tthis.addEdge(edge, edgeSet);\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn SimpleMCSweepLineIntersector;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geomgraph/index/SimpleMCSweepLineIntersector.js\n// module id = 226\n// module chunks = 0","import extend from '../../../../../extend';\nexport default function MonotoneChain() {\n\tthis.mce = null;\n\tthis.chainIndex = null;\n\tlet mce = arguments[0], chainIndex = arguments[1];\n\tthis.mce = mce;\n\tthis.chainIndex = chainIndex;\n}\nextend(MonotoneChain.prototype, {\n\tcomputeIntersections: function (mc, si) {\n\t\tthis.mce.computeIntersectsForChain(this.chainIndex, mc.mce, mc.chainIndex, si);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn MonotoneChain;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geomgraph/index/MonotoneChain.js\n// module id = 227\n// module chunks = 0","import extend from '../../../../../extend';\nimport Comparable from '../../../../../java/lang/Comparable';\nexport default function SweepLineEvent() {\n\tthis._label = null;\n\tthis._xValue = null;\n\tthis._eventType = null;\n\tthis._insertEvent = null;\n\tthis._deleteEventIndex = null;\n\tthis._obj = null;\n\tif (arguments.length === 2) {\n\t\tlet x = arguments[0], insertEvent = arguments[1];\n\t\tthis._eventType = SweepLineEvent.DELETE;\n\t\tthis._xValue = x;\n\t\tthis._insertEvent = insertEvent;\n\t} else if (arguments.length === 3) {\n\t\tlet label = arguments[0], x = arguments[1], obj = arguments[2];\n\t\tthis._eventType = SweepLineEvent.INSERT;\n\t\tthis._label = label;\n\t\tthis._xValue = x;\n\t\tthis._obj = obj;\n\t}\n}\nextend(SweepLineEvent.prototype, {\n\tisDelete: function () {\n\t\treturn this._eventType === SweepLineEvent.DELETE;\n\t},\n\tsetDeleteEventIndex: function (deleteEventIndex) {\n\t\tthis._deleteEventIndex = deleteEventIndex;\n\t},\n\tgetObject: function () {\n\t\treturn this._obj;\n\t},\n\tcompareTo: function (o) {\n\t\tvar pe = o;\n\t\tif (this._xValue < pe._xValue) return -1;\n\t\tif (this._xValue > pe._xValue) return 1;\n\t\tif (this._eventType < pe._eventType) return -1;\n\t\tif (this._eventType > pe._eventType) return 1;\n\t\treturn 0;\n\t},\n\tgetInsertEvent: function () {\n\t\treturn this._insertEvent;\n\t},\n\tisInsert: function () {\n\t\treturn this._eventType === SweepLineEvent.INSERT;\n\t},\n\tisSameLabel: function (ev) {\n\t\tif (this._label === null) return false;\n\t\treturn this._label === ev._label;\n\t},\n\tgetDeleteEventIndex: function () {\n\t\treturn this._deleteEventIndex;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparable];\n\t},\n\tgetClass: function () {\n\t\treturn SweepLineEvent;\n\t}\n});\nSweepLineEvent.INSERT = 1;\nSweepLineEvent.DELETE = 2;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geomgraph/index/SweepLineEvent.js\n// module id = 228\n// module chunks = 0","import extend from '../../../../../extend';\nexport default function EdgeSetIntersector() {}\nextend(EdgeSetIntersector.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn EdgeSetIntersector;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geomgraph/index/EdgeSetIntersector.js\n// module id = 229\n// module chunks = 0","import hasInterface from '../../../../../hasInterface';\nimport IllegalArgumentException from '../../../../../java/lang/IllegalArgumentException';\nimport ItemVisitor from '../../index/ItemVisitor';\nimport PointOnGeometryLocator from './PointOnGeometryLocator';\nimport LinearRing from '../../geom/LinearRing';\nimport extend from '../../../../../extend';\nimport SortedPackedIntervalRTree from '../../index/intervalrtree/SortedPackedIntervalRTree';\nimport LineSegment from '../../geom/LineSegment';\nimport Polygonal from '../../geom/Polygonal';\nimport LinearComponentExtracter from '../../geom/util/LinearComponentExtracter';\nimport ArrayListVisitor from '../../index/ArrayListVisitor';\nimport RayCrossingCounter from '../RayCrossingCounter';\nexport default function IndexedPointInAreaLocator() {\n\tthis._index = null;\n\tlet g = arguments[0];\n\tif (!(hasInterface(g, Polygonal) || g instanceof LinearRing)) throw new IllegalArgumentException(\"Argument must be Polygonal or LinearRing\");\n\tthis._index = new IntervalIndexedGeometry(g);\n}\nextend(IndexedPointInAreaLocator.prototype, {\n\tlocate: function (p) {\n\t\tvar rcc = new RayCrossingCounter(p);\n\t\tvar visitor = new SegmentVisitor(rcc);\n\t\tthis._index.query(p.y, p.y, visitor);\n\t\treturn rcc.getLocation();\n\t},\n\tinterfaces_: function () {\n\t\treturn [PointOnGeometryLocator];\n\t},\n\tgetClass: function () {\n\t\treturn IndexedPointInAreaLocator;\n\t}\n});\nfunction SegmentVisitor() {\n\tthis._counter = null;\n\tlet counter = arguments[0];\n\tthis._counter = counter;\n}\nextend(SegmentVisitor.prototype, {\n\tvisitItem: function (item) {\n\t\tvar seg = item;\n\t\tthis._counter.countSegment(seg.getCoordinate(0), seg.getCoordinate(1));\n\t},\n\tinterfaces_: function () {\n\t\treturn [ItemVisitor];\n\t},\n\tgetClass: function () {\n\t\treturn SegmentVisitor;\n\t}\n});\nfunction IntervalIndexedGeometry() {\n\tthis._index = new SortedPackedIntervalRTree();\n\tlet geom = arguments[0];\n\tthis.init(geom);\n}\nextend(IntervalIndexedGeometry.prototype, {\n\tinit: function (geom) {\n\t\tvar lines = LinearComponentExtracter.getLines(geom);\n\t\tfor (var i = lines.iterator(); i.hasNext(); ) {\n\t\t\tvar line = i.next();\n\t\t\tvar pts = line.getCoordinates();\n\t\t\tthis.addLine(pts);\n\t\t}\n\t},\n\taddLine: function (pts) {\n\t\tfor (var i = 1; i < pts.length; i++) {\n\t\t\tvar seg = new LineSegment(pts[i - 1], pts[i]);\n\t\t\tvar min = Math.min(seg.p0.y, seg.p1.y);\n\t\t\tvar max = Math.max(seg.p0.y, seg.p1.y);\n\t\t\tthis._index.insert(min, max, seg);\n\t\t}\n\t},\n\tquery: function () {\n\t\tif (arguments.length === 2) {\n\t\t\tlet min = arguments[0], max = arguments[1];\n\t\t\tvar visitor = new ArrayListVisitor();\n\t\t\tthis._index.query(min, max, visitor);\n\t\t\treturn visitor.getItems();\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet min = arguments[0], max = arguments[1], visitor = arguments[2];\n\t\t\tthis._index.query(min, max, visitor);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn IntervalIndexedGeometry;\n\t}\n});\nIndexedPointInAreaLocator.SegmentVisitor = SegmentVisitor;\nIndexedPointInAreaLocator.IntervalIndexedGeometry = IntervalIndexedGeometry;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/algorithm/locate/IndexedPointInAreaLocator.js\n// module id = 230\n// module chunks = 0","import WKTWriter from '../../io/WKTWriter';\nimport Coordinate from '../../geom/Coordinate';\nimport IntervalRTreeLeafNode from './IntervalRTreeLeafNode';\nimport IntervalRTreeNode from './IntervalRTreeNode';\nimport extend from '../../../../../extend';\nimport Collections from '../../../../../java/util/Collections';\nimport System from '../../../../../java/lang/System';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport IntervalRTreeBranchNode from './IntervalRTreeBranchNode';\nexport default function SortedPackedIntervalRTree() {\n\tthis._leaves = new ArrayList();\n\tthis._root = null;\n\tthis._level = 0;\n}\nextend(SortedPackedIntervalRTree.prototype, {\n\tbuildTree: function () {\n\t\tCollections.sort(this._leaves, new IntervalRTreeNode.NodeComparator());\n\t\tvar src = this._leaves;\n\t\tvar temp = null;\n\t\tvar dest = new ArrayList();\n\t\twhile (true) {\n\t\t\tthis.buildLevel(src, dest);\n\t\t\tif (dest.size() === 1) return dest.get(0);\n\t\t\ttemp = src;\n\t\t\tsrc = dest;\n\t\t\tdest = temp;\n\t\t}\n\t},\n\tinsert: function (min, max, item) {\n\t\tif (this._root !== null) throw new IllegalStateException(\"Index cannot be added to once it has been queried\");\n\t\tthis._leaves.add(new IntervalRTreeLeafNode(min, max, item));\n\t},\n\tquery: function (min, max, visitor) {\n\t\tthis.init();\n\t\tthis._root.query(min, max, visitor);\n\t},\n\tbuildRoot: function () {\n\t\tif (this._root !== null) return null;\n\t\tthis._root = this.buildTree();\n\t},\n\tprintNode: function (node) {\n\t\tSystem.out.println(WKTWriter.toLineString(new Coordinate(node._min, this._level), new Coordinate(node._max, this._level)));\n\t},\n\tinit: function () {\n\t\tif (this._root !== null) return null;\n\t\tthis.buildRoot();\n\t},\n\tbuildLevel: function (src, dest) {\n\t\tthis._level++;\n\t\tdest.clear();\n\t\tfor (var i = 0; i < src.size(); i += 2) {\n\t\t\tvar n1 = src.get(i);\n\t\t\tvar n2 = i + 1 < src.size() ? src.get(i) : null;\n\t\t\tif (n2 === null) {\n\t\t\t\tdest.add(n1);\n\t\t\t} else {\n\t\t\t\tvar node = new IntervalRTreeBranchNode(src.get(i), src.get(i + 1));\n\t\t\t\tdest.add(node);\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn SortedPackedIntervalRTree;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/index/intervalrtree/SortedPackedIntervalRTree.js\n// module id = 231\n// module chunks = 0","import IntervalRTreeNode from './IntervalRTreeNode';\nimport extend from '../../../../../extend';\nimport inherits from '../../../../../inherits';\nexport default function IntervalRTreeLeafNode() {\n\tIntervalRTreeNode.apply(this);\n\tthis._item = null;\n\tlet min = arguments[0], max = arguments[1], item = arguments[2];\n\tthis._min = min;\n\tthis._max = max;\n\tthis._item = item;\n}\ninherits(IntervalRTreeLeafNode, IntervalRTreeNode);\nextend(IntervalRTreeLeafNode.prototype, {\n\tquery: function (queryMin, queryMax, visitor) {\n\t\tif (!this.intersects(queryMin, queryMax)) return null;\n\t\tvisitor.visitItem(this._item);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn IntervalRTreeLeafNode;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/index/intervalrtree/IntervalRTreeLeafNode.js\n// module id = 232\n// module chunks = 0","import IntervalRTreeNode from './IntervalRTreeNode';\nimport extend from '../../../../../extend';\nimport inherits from '../../../../../inherits';\nexport default function IntervalRTreeBranchNode() {\n\tIntervalRTreeNode.apply(this);\n\tthis._node1 = null;\n\tthis._node2 = null;\n\tlet n1 = arguments[0], n2 = arguments[1];\n\tthis._node1 = n1;\n\tthis._node2 = n2;\n\tthis.buildExtent(this._node1, this._node2);\n}\ninherits(IntervalRTreeBranchNode, IntervalRTreeNode);\nextend(IntervalRTreeBranchNode.prototype, {\n\tbuildExtent: function (n1, n2) {\n\t\tthis._min = Math.min(n1._min, n2._min);\n\t\tthis._max = Math.max(n1._max, n2._max);\n\t},\n\tquery: function (queryMin, queryMax, visitor) {\n\t\tif (!this.intersects(queryMin, queryMax)) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this._node1 !== null) this._node1.query(queryMin, queryMax, visitor);\n\t\tif (this._node2 !== null) this._node2.query(queryMin, queryMax, visitor);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn IntervalRTreeBranchNode;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/index/intervalrtree/IntervalRTreeBranchNode.js\n// module id = 233\n// module chunks = 0","import LineString from '../LineString';\nimport Geometry from '../Geometry';\nimport hasInterface from '../../../../../hasInterface';\nimport Collection from '../../../../../java/util/Collection';\nimport LinearRing from '../LinearRing';\nimport extend from '../../../../../extend';\nimport GeometryComponentFilter from '../GeometryComponentFilter';\nimport ArrayList from '../../../../../java/util/ArrayList';\nexport default function LinearComponentExtracter() {\n\tthis._lines = null;\n\tthis._isForcedToLineString = false;\n\tif (arguments.length === 1) {\n\t\tlet lines = arguments[0];\n\t\tthis._lines = lines;\n\t} else if (arguments.length === 2) {\n\t\tlet lines = arguments[0], isForcedToLineString = arguments[1];\n\t\tthis._lines = lines;\n\t\tthis._isForcedToLineString = isForcedToLineString;\n\t}\n}\nextend(LinearComponentExtracter.prototype, {\n\tfilter: function (geom) {\n\t\tif (this._isForcedToLineString && geom instanceof LinearRing) {\n\t\t\tvar line = geom.getFactory().createLineString(geom.getCoordinateSequence());\n\t\t\tthis._lines.add(line);\n\t\t\treturn null;\n\t\t}\n\t\tif (geom instanceof LineString) this._lines.add(geom);\n\t},\n\tsetForceToLineString: function (isForcedToLineString) {\n\t\tthis._isForcedToLineString = isForcedToLineString;\n\t},\n\tinterfaces_: function () {\n\t\treturn [GeometryComponentFilter];\n\t},\n\tgetClass: function () {\n\t\treturn LinearComponentExtracter;\n\t}\n});\nLinearComponentExtracter.getGeometry = function () {\n\tif (arguments.length === 1) {\n\t\tlet geom = arguments[0];\n\t\treturn geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom));\n\t} else if (arguments.length === 2) {\n\t\tlet geom = arguments[0], forceToLineString = arguments[1];\n\t\treturn geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom, forceToLineString));\n\t}\n};\nLinearComponentExtracter.getLines = function () {\n\tif (arguments.length === 1) {\n\t\tlet geom = arguments[0];\n\t\treturn LinearComponentExtracter.getLines(geom, false);\n\t} else if (arguments.length === 2) {\n\t\tif (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {\n\t\t\tlet geoms = arguments[0], lines = arguments[1];\n\t\t\tfor (var i = geoms.iterator(); i.hasNext(); ) {\n\t\t\t\tvar g = i.next();\n\t\t\t\tLinearComponentExtracter.getLines(g, lines);\n\t\t\t}\n\t\t\treturn lines;\n\t\t} else if (arguments[0] instanceof Geometry && typeof arguments[1] === \"boolean\") {\n\t\t\tlet geom = arguments[0], forceToLineString = arguments[1];\n\t\t\tvar lines = new ArrayList();\n\t\t\tgeom.apply(new LinearComponentExtracter(lines, forceToLineString));\n\t\t\treturn lines;\n\t\t} else if (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {\n\t\t\tlet geom = arguments[0], lines = arguments[1];\n\t\t\tif (geom instanceof LineString) {\n\t\t\t\tlines.add(geom);\n\t\t\t} else {\n\t\t\t\tgeom.apply(new LinearComponentExtracter(lines));\n\t\t\t}\n\t\t\treturn lines;\n\t\t}\n\t} else if (arguments.length === 3) {\n\t\tif (typeof arguments[2] === \"boolean\" && (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection))) {\n\t\t\tlet geoms = arguments[0], lines = arguments[1], forceToLineString = arguments[2];\n\t\t\tfor (var i = geoms.iterator(); i.hasNext(); ) {\n\t\t\t\tvar g = i.next();\n\t\t\t\tLinearComponentExtracter.getLines(g, lines, forceToLineString);\n\t\t\t}\n\t\t\treturn lines;\n\t\t} else if (typeof arguments[2] === \"boolean\" && (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection))) {\n\t\t\tlet geom = arguments[0], lines = arguments[1], forceToLineString = arguments[2];\n\t\t\tgeom.apply(new LinearComponentExtracter(lines, forceToLineString));\n\t\t\treturn lines;\n\t\t}\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/geom/util/LinearComponentExtracter.js\n// module id = 234\n// module chunks = 0","import ItemVisitor from './ItemVisitor';\nimport extend from '../../../../extend';\nimport ArrayList from '../../../../java/util/ArrayList';\nexport default function ArrayListVisitor() {\n\tthis._items = new ArrayList();\n}\nextend(ArrayListVisitor.prototype, {\n\tvisitItem: function (item) {\n\t\tthis._items.add(item);\n\t},\n\tgetItems: function () {\n\t\treturn this._items;\n\t},\n\tinterfaces_: function () {\n\t\treturn [ItemVisitor];\n\t},\n\tgetClass: function () {\n\t\treturn ArrayListVisitor;\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsts/org/locationtech/jts/index/ArrayListVisitor.js\n// module id = 235\n// module chunks = 0","export default class Util {\n  /**\n   * TODO\n   */\n  static logError(e) {\n    /* eslint-disable */\n    console.error(e);\n    /* eslint-enable */\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/helper/util.js","module.exports = \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiCiAgIHhtbG5zOmlua3NjYXBlPSJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlIgogICB3aWR0aD0iMTE5Ljk4NzEzbW0iCiAgIGhlaWdodD0iMTIwLjI5MjU2bW0iCiAgIHZpZXdCb3g9IjAgMCA0MjUuMTUxMjcgNDI2LjIzMzUiCiAgIGlkPSJzdmcyIgogICB2ZXJzaW9uPSIxLjEiCiAgIGlua3NjYXBlOnZlcnNpb249IjAuOTEgcjEzNzI1IgogICBzb2RpcG9kaTpkb2NuYW1lPSJ1bmlvbi5zdmciCiAgIGlua3NjYXBlOmV4cG9ydC1maWxlbmFtZT0iL2hvbWUvbWFyaW8vcmVwb3NpdG9yaWVzL29sZTQvaW1nL3JvdGF0ZS5wbmciCiAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIxNi44MTg4NzIiCiAgIGlua3NjYXBlOmV4cG9ydC15ZHBpPSIxNi44MTg4NzIiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0IiAvPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0iYmFzZSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSIwLjk4OTk0OTQ5IgogICAgIGlua3NjYXBlOmN4PSIyMDIuNDMzNDIiCiAgICAgaW5rc2NhcGU6Y3k9IjMzMi43OTc4OSIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIHNob3dndWlkZXM9ImZhbHNlIgogICAgIGZpdC1tYXJnaW4tdG9wPSIwIgogICAgIGZpdC1tYXJnaW4tbGVmdD0iMCIKICAgICBmaXQtbWFyZ2luLXJpZ2h0PSIwIgogICAgIGZpdC1tYXJnaW4tYm90dG9tPSIwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTg2NSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSIxMDU2IgogICAgIGlua3NjYXBlOndpbmRvdy14PSI1NSIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMjQiCiAgICAgaW5rc2NhcGU6d2luZG93LW1heGltaXplZD0iMSIKICAgICBpbmtzY2FwZTpzbmFwLWNlbnRlcj0idHJ1ZSIKICAgICBpbmtzY2FwZTpzbmFwLWdyaWRzPSJmYWxzZSIKICAgICBpbmtzY2FwZTpzbmFwLW9iamVjdC1taWRwb2ludHM9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIHR5cGU9Inh5Z3JpZCIKICAgICAgIGlkPSJncmlkMzM0MCIKICAgICAgIG9yaWdpbng9Ii0xNzEuMjE5ODgiCiAgICAgICBvcmlnaW55PSItMjc0LjYzOTA5IiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgICAgPGRjOnRpdGxlPjwvZGM6dGl0bGU+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkViZW5lIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIgogICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xNzEuMjE5ODgsLTM1MS40ODk2OSkiPgogICAgPGNpcmNsZQogICAgICAgc3R5bGU9ImZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzhhOGE4YTtzdHJva2Utd2lkdGg6MjAuMDAwMDAxOTE7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBpZD0icGF0aDQxMzctNi01IgogICAgICAgY3g9IjMwOC45NDYxNyIKICAgICAgIGN5PSI0OTAuMjg2MTYiCiAgICAgICByPSIxMjMuNzQzNzEiIC8+CiAgICA8Y2lyY2xlCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojOGE4YThhO3N0cm9rZS13aWR0aDoyMi4zNDE0MDAxNTtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGlkPSJwYXRoNDEzNy0zLTctMyIKICAgICAgIGN4PSI0NDYuOTcwMDYiCiAgICAgICBjeT0iNjI4LjMyMjA4IgogICAgICAgcj0iMTM4LjIzMDM5IiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI1LjAwMDAwMTkxO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAzMDcuNDYyMDYsMzYzLjk4OTY5IGEgMTIzLjc0MzcxLDEyMy43NDM3MSAwIDAgMCAtMTIzLjc0MjE4LDEyMy43NDQxNCAxMjMuNzQzNzEsMTIzLjc0MzcxIDAgMCAwIDEyMy43NDIxOCwxMjMuNzQ0MTQgMTIzLjc0MzcxLDEyMy43NDM3MSAwIDAgMCAwLjU2MjUsLTAuMDE5NSAxMzguMjMwNCwxMzguMjMwNCAwIDAgMCAtMC43Njc1OCwxNC4zMTA1NSAxMzguMjMwNCwxMzguMjMwNCAwIDAgMCAxMzguMjMwNDcsMTM4LjIzMDQ3IDEzOC4yMzA0LDEzOC4yMzA0IDAgMCAwIDEzOC4yMzA0NywtMTM4LjIzMDQ3IDEzOC4yMzA0LDEzOC4yMzA0IDAgMCAwIC0xMzguMjMwNDcsLTEzOC4yMzA0NyAxMzguMjMwNCwxMzguMjMwNCAwIDAgMCAtMTQuMzE2NCwwLjg5ODQ0IDEyMy43NDM3MSwxMjMuNzQzNzEgMCAwIDAgMC4wMzUyLC0wLjcwMzEzIDEyMy43NDM3MSwxMjMuNzQzNzEgMCAwIDAgLTEyMy43NDQxNCwtMTIzLjc0NDE0IHoiCiAgICAgICBpZD0icGF0aDQxMzctNi01LTUiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPgogIDwvZz4KPC9zdmc+Cg==\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./img/union.svg\n// module id = 237\n// module chunks = 0","import OL3Parser from '../../node_modules/jsts/org/locationtech/jts/io/OL3Parser';\nimport OverlayOp from '../../node_modules/jsts/org/locationtech/jts/operation/overlay/OverlayOp';\nimport TopologyControl from './topology';\nimport intersectionSVG from '../../img/intersection.svg';\n\n/**\n * Control for intersection geometries.\n * @extends {ole.Control}\n * @alias ole.Intersection\n */\nclass Intersection extends TopologyControl {\n  /**\n   * @inheritdoc\n   * @param {Object} [options] Control options.\n   * @param {number} [options.hitTolerance] Select tolerance in pixels\n   *   (default is 10)\n   */\n  constructor(options) {\n    super(Object.assign({\n      title: 'Intersection',\n      className: 'ole-control-intersection',\n      image: intersectionSVG,\n    }, options));\n  }\n\n  /**\n   * Intersect given features.\n   * @param {Array.<ol.Feature>} features Features to inersect.\n   */\n  applyTopologyOperation(features) {\n    super.applyTopologyOperation(features);\n\n    if (features.length < 2) {\n      return;\n    }\n\n    const parser = new OL3Parser();\n\n    for (let i = 1; i < features.length; i += 1) {\n      const geom = parser.read(features[0].getGeometry());\n      const otherGeom = parser.read(features[i].getGeometry());\n      const intersectGeom = OverlayOp.intersection(geom, otherGeom);\n      features[0].setGeometry(parser.write(intersectGeom));\n      features[i].setGeometry(null);\n    }\n  }\n}\n\nexport default Intersection;\n\n\n\n// WEBPACK FOOTER //\n// ./src/control/intersection.js","module.exports = \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiCiAgIHhtbG5zOmlua3NjYXBlPSJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlIgogICB3aWR0aD0iMTE4Ljg2MzE0bW0iCiAgIGhlaWdodD0iMTE4Ljg2NjU0bW0iCiAgIHZpZXdCb3g9IjAgMCA0MjEuMTY4NjIgNDIxLjE4MDY4IgogICBpZD0ic3ZnMiIKICAgdmVyc2lvbj0iMS4xIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjkxIHIxMzcyNSIKICAgc29kaXBvZGk6ZG9jbmFtZT0iaW50ZXJzZWN0aW9uLnN2ZyIKICAgaW5rc2NhcGU6ZXhwb3J0LWZpbGVuYW1lPSIvaG9tZS9tYXJpby9yZXBvc2l0b3JpZXMvb2xlNC9pbWcvcm90YXRlLnBuZyIKICAgaW5rc2NhcGU6ZXhwb3J0LXhkcGk9IjE2LjgxODg3MiIKICAgaW5rc2NhcGU6ZXhwb3J0LXlkcGk9IjE2LjgxODg3MiI+CiAgPGRlZnMKICAgICBpZD0iZGVmczQiIC8+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjAuOTg5OTQ5NDkiCiAgICAgaW5rc2NhcGU6Y3g9IjE5OC40NTEyNiIKICAgICBpbmtzY2FwZTpjeT0iMjUxLjk4NTIiCiAgICAgaW5rc2NhcGU6ZG9jdW1lbnQtdW5pdHM9InB4IgogICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9ImxheWVyMSIKICAgICBzaG93Z3JpZD0idHJ1ZSIKICAgICBzaG93Z3VpZGVzPSJmYWxzZSIKICAgICBmaXQtbWFyZ2luLXRvcD0iMCIKICAgICBmaXQtbWFyZ2luLWxlZnQ9IjAiCiAgICAgZml0LW1hcmdpbi1yaWdodD0iMCIKICAgICBmaXQtbWFyZ2luLWJvdHRvbT0iMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjE4NjUiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iMTA1NiIKICAgICBpbmtzY2FwZTp3aW5kb3cteD0iNTUiCiAgICAgaW5rc2NhcGU6d2luZG93LXk9IjI0IgogICAgIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9IjEiCiAgICAgaW5rc2NhcGU6c25hcC1jZW50ZXI9InRydWUiCiAgICAgaW5rc2NhcGU6c25hcC1ncmlkcz0iZmFsc2UiCiAgICAgaW5rc2NhcGU6c25hcC1vYmplY3QtbWlkcG9pbnRzPSJ0cnVlIj4KICAgIDxpbmtzY2FwZTpncmlkCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBpZD0iZ3JpZDMzNDAiCiAgICAgICBvcmlnaW54PSItMTc1LjIwMjA1IgogICAgICAgb3JpZ2lueT0iLTI3NC42Mzk1NiIgLz4KICA8L3NvZGlwb2RpOm5hbWVkdmlldz4KICA8bWV0YWRhdGEKICAgICBpZD0ibWV0YWRhdGE3Ij4KICAgIDxyZGY6UkRGPgogICAgICA8Y2M6V29yawogICAgICAgICByZGY6YWJvdXQ9IiI+CiAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+CiAgICAgICAgPGRjOnR5cGUKICAgICAgICAgICByZGY6cmVzb3VyY2U9Imh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlIiAvPgogICAgICAgIDxkYzp0aXRsZT48L2RjOnRpdGxlPgogICAgICA8L2NjOldvcms+CiAgICA8L3JkZjpSREY+CiAgPC9tZXRhZGF0YT4KICA8ZwogICAgIGlua3NjYXBlOmxhYmVsPSJFYmVuZSAxIgogICAgIGlua3NjYXBlOmdyb3VwbW9kZT0ibGF5ZXIiCiAgICAgaWQ9ImxheWVyMSIKICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTc1LjIwMjA0LC0zNTYuNTQyMDEpIj4KICAgIDxjaXJjbGUKICAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiM4YThhOGE7c3Ryb2tlLXdpZHRoOjIwLjAwMDAwMTkxO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgaWQ9InBhdGg0MTM3LTYiCiAgICAgICBjeD0iMzA4Ljk0NTc0IgogICAgICAgY3k9IjQ5MC4yODU3MSIKICAgICAgIHI9IjEyMy43NDM3IiAvPgogICAgPGNpcmNsZQogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzhhOGE4YTtzdHJva2Utd2lkdGg6MjIuMzQxNDAwMTU7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBpZD0icGF0aDQxMzctMy03IgogICAgICAgY3g9IjQ0Ni45Njk1NyIKICAgICAgIGN5PSI2MjguMzIxNTkiCiAgICAgICByPSIxMzguMjMwMzgiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjUuMDAwMDAxOTE7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDQzMy40MjA5Miw0ODguNzgxMTUgYSAxMzguMjMwMzUsMTM4LjIzMDM1IDAgMCAwIC0xMjYuOTYyODksMTI2Ljk5NjA5IDEyMy43NDM2OCwxMjMuNzQzNjggMCAwIDAgMy4zMzk4NCwwLjE2NjAyIDEyMy43NDM2OCwxMjMuNzQzNjggMCAwIDAgMTIzLjc0NDE0LC0xMjMuNzQ0MTUgMTIzLjc0MzY4LDEyMy43NDM2OCAwIDAgMCAtMC4xMjEwOSwtMy40MTc5NiB6IgogICAgICAgaWQ9InBhdGg0MTM3IgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz4KICA8L2c+Cjwvc3ZnPgo=\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./img/intersection.svg\n// module id = 239\n// module chunks = 0","import OL3Parser from '../../node_modules/jsts/org/locationtech/jts/io/OL3Parser';\nimport OverlayOp from '../../node_modules/jsts/org/locationtech/jts/operation/overlay/OverlayOp';\nimport TopologyControl from './topology';\nimport diffSVG from '../../img/difference.svg';\n\n/**\n * Control for creating a difference of geometries.\n * @extends {ole.Control}\n * @alias ole.Difference\n */\nclass Difference extends TopologyControl {\n  /**\n   * @inheritdoc\n   * @param {Object} [options] Control options.\n   * @param {number} [options.hitTolerance] Select tolerance in pixels\n   *   (default is 10)\n   */\n  constructor(options) {\n    super(Object.assign({\n      title: 'Difference',\n      className: 'ole-control-difference',\n      image: diffSVG,\n    }, options));\n  }\n\n  /**\n   * Apply a difference operation for given features.\n   * @param {Array.<ol.Feature>} features Features.\n   */\n  applyTopologyOperation(features) {\n    super.applyTopologyOperation(features);\n\n    if (features.length < 2) {\n      return;\n    }\n\n    const parser = new OL3Parser();\n\n    for (let i = 1; i < features.length; i += 1) {\n      const geom = parser.read(features[0].getGeometry());\n      const otherGeom = parser.read(features[i].getGeometry());\n      const diffGeom = OverlayOp.difference(geom, otherGeom);\n      features[0].setGeometry(parser.write(diffGeom));\n      features[i].setGeometry(null);\n    }\n  }\n}\n\nexport default Difference;\n\n\n\n// WEBPACK FOOTER //\n// ./src/control/difference.js","module.exports = \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiCiAgIHhtbG5zOmlua3NjYXBlPSJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlIgogICB3aWR0aD0iMTE4Ljg2MzE0bW0iCiAgIGhlaWdodD0iMTE4Ljg2NjU0bW0iCiAgIHZpZXdCb3g9IjAgMCA0MjEuMTY4NjIgNDIxLjE4MDY4IgogICBpZD0ic3ZnMiIKICAgdmVyc2lvbj0iMS4xIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjkxIHIxMzcyNSIKICAgc29kaXBvZGk6ZG9jbmFtZT0iZGlmZmVyZW5jZS5zdmciCiAgIGlua3NjYXBlOmV4cG9ydC1maWxlbmFtZT0iL2hvbWUvbWFyaW8vcmVwb3NpdG9yaWVzL29sZTQvaW1nL3JvdGF0ZS5wbmciCiAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIxNi44MTg4NzIiCiAgIGlua3NjYXBlOmV4cG9ydC15ZHBpPSIxNi44MTg4NzIiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0IiAvPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0iYmFzZSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSIwLjk4OTk0OTQ5IgogICAgIGlua3NjYXBlOmN4PSIxOTguNDUxMjYiCiAgICAgaW5rc2NhcGU6Y3k9IjMzMi43OTc0IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgc2hvd2d1aWRlcz0iZmFsc2UiCiAgICAgZml0LW1hcmdpbi10b3A9IjAiCiAgICAgZml0LW1hcmdpbi1sZWZ0PSIwIgogICAgIGZpdC1tYXJnaW4tcmlnaHQ9IjAiCiAgICAgZml0LW1hcmdpbi1ib3R0b209IjAiCiAgICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPSIxODY1IgogICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9IjEwNTYiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjU1IgogICAgIGlua3NjYXBlOndpbmRvdy15PSIyNCIKICAgICBpbmtzY2FwZTp3aW5kb3ctbWF4aW1pemVkPSIxIgogICAgIGlua3NjYXBlOnNuYXAtY2VudGVyPSJ0cnVlIgogICAgIGlua3NjYXBlOnNuYXAtZ3JpZHM9ImZhbHNlIgogICAgIGlua3NjYXBlOnNuYXAtb2JqZWN0LW1pZHBvaW50cz0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgaWQ9ImdyaWQzMzQwIgogICAgICAgb3JpZ2lueD0iLTE3NS4yMDIwNSIKICAgICAgIG9yaWdpbnk9Ii0yNzQuNjM5NTYiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgICA8ZGM6dGl0bGU+PC9kYzp0aXRsZT4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iRWJlbmUgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiCiAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTE3NS4yMDIwNCwtMzU2LjU0MjAxKSI+CiAgICA8Y2lyY2xlCiAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojOGE4YThhO3N0cm9rZS13aWR0aDoyMC4wMDAwMDE5MTtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGlkPSJwYXRoNDEzNy02LTUiCiAgICAgICBjeD0iMzA4Ljk0NjE3IgogICAgICAgY3k9IjQ5MC4yODYxNiIKICAgICAgIHI9IjEyMy43NDM3MSIgLz4KICAgIDxjaXJjbGUKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiM4YThhOGE7c3Ryb2tlLXdpZHRoOjIyLjM0MTQwMDE1O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgaWQ9InBhdGg0MTM3LTMtNy0zIgogICAgICAgY3g9IjQ0Ni45NzAwNiIKICAgICAgIGN5PSI2MjguMzIyMDgiCiAgICAgICByPSIxMzguMjMwMzkiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjUuMDAwMDAxNDk7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDMwOC45NDYxOCwzNjYuNTQyMDEgYSAxMjMuNzQzNjksMTIzLjc0MzY5IDAgMCAwIC0xMjMuNzQ0MTQsMTIzLjc0NDE0IDEyMy43NDM2OSwxMjMuNzQzNjkgMCAwIDAgMTIzLjc0NDE0LDEyMy43NDQxNCAxMjMuNzQzNjksMTIzLjc0MzY5IDAgMCAwIDAuNTYyNSwtMC4wMTk1IDEzOC4yMzAzNywxMzguMjMwMzcgMCAwIDEgMTIzLjE0NjQ4LC0xMjMuMDIzNDQgMTIzLjc0MzY5LDEyMy43NDM2OSAwIDAgMCAwLjAzNTIsLTAuNzAxMTcgMTIzLjc0MzY5LDEyMy43NDM2OSAwIDAgMCAtMTIzLjc0NDE0LC0xMjMuNzQ0MTQgeiIKICAgICAgIGlkPSJwYXRoNDEzNy02IgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz4KICA8L2c+Cjwvc3ZnPgo=\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./img/difference.svg\n// module id = 241\n// module chunks = 0"],"sourceRoot":""}